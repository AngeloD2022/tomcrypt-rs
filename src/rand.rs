//! Random number generation and pseudo-random number algorithms.
use ffi;
use std::ffi::{CStr, CString};
use std::io;
use std::mem;
use std::os::raw::*;
use Result;

/// A pseudo-random number generator algorithm.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Algorithm(c_int);

impl Algorithm {
    pub fn find(name: &str) -> Option<Self> {
        ::init();

        unsafe {
            let name = CString::new(name).unwrap();

            match ffi::find_prng(name.as_ptr()) {
                -1 => None,
                index => Some(Algorithm(index)),
            }
        }
    }

    /// Get a PRNG algorithm by name. Panics if the algorithm is not available.
    fn find_required(name: &str) -> Self {
        match Self::find(name) {
            Some(prng) => prng,
            None => panic!("{} algorithm not available", name),
        }
    }

    /// Secure PRNG using the system PRNG.
    ///
    /// This algorithm implements the PRNG interface by using the system PRNG underneath the hood. On UNIX-like systems,
    /// this will read data from `/dev/urandom` or `/dev/random`. On Windows, the function `CryptGenRandom()` is called
    /// to generate data.
    ///
    /// Note that adding entropy to an SPRNG does nothing.
    pub fn sprng() -> Self {
        Self::find_required("sprng")
    }

    /// ChaCha20 stream cipher algorithm as a PRNG (recommended, fast).
    ///
    /// ChaCha20 is a fast stream cipher built on a pseudorandom function designed by Daniel J. Bernstein. It can also
    /// double duty as a PRNG. It is recommended to use 40 bytes of truly random bytes for initialization.
    pub fn chacha20() -> Self {
        Self::find_required("chacha20")
    }

    /// Fast long-term PRNG (recommended, secure).
    ///
    /// Fortuna is a fast attack tolerant and more thoroughly designed PRNG suitable for long term usage. It is faster
    /// than the default implementation of Yarrow while providing more security.
    pub fn fortuna() -> Self {
        Self::find_required("fortuna")
    }

    /// Get the name of the PRNG.
    pub fn name(&self) -> &str {
        unsafe {
            CStr::from_ptr(self.descriptor().name).to_str().unwrap()
        }
    }

    #[inline]
    pub(crate) fn index(&self) -> c_int {
        self.0
    }

    #[inline]
    fn descriptor(&self) -> &'static ffi::ltc_prng_descriptor {
        unsafe {
            &*(&ffi::prng_descriptor as *const ffi::ltc_prng_descriptor).offset(self.0 as isize)
        }
    }
}

/// A pseudo-random number generator.
///
/// Generates an infinite stream of random data based on seed entropy using the configured algorithm. Entropy can be
/// added to a PRNG by writing to it, or by using the [`add_entropy`] method. Once you have finished adding entropy to
/// the PRNG, it can be initialized using the [`ready`] method.
///
/// When using the write-based API to seed the PRNG, you can also call [`flush`] to implicitly call [`ready`].
///
/// Some algorithms, such as ChaCha20, allow you to continue to add entropy to an existing instance even after it is
/// initialized, so you can continuously write to it even as you read from it. Be sure to always call [`ready`] in order
/// to make any additional entropy added to take effect.
///
/// After initialized, a PRNG can be read from to obtain random bytes generated by the algorithm.
///
/// [`add_entropy`]: #method.add_entropy
/// [`flush`]: #method.flush
/// [`ready`]: #method.ready
pub struct Prng {
    algorithm: Algorithm,
    raw: ffi::prng_state,
}

impl Default for Prng {
    fn default() -> Prng {
        Prng::sprng()
    }
}

impl Prng {
    /// Create a new pseudo-random number generator using the given algorithm.
    pub fn new(algorithm: Algorithm) -> Result<Self> {
        unsafe {
            let mut raw = mem::uninitialized();

            tryt! {
                (algorithm.descriptor().start.unwrap())(&mut raw)
            };

            Ok(Self {
                algorithm: algorithm,
                raw: raw,
            })
        }
    }

    /// Get an instance of the system PRNG.
    ///
    /// See [`Algorithm::sprng`] for details on how LibTomCrypt interacts with the system PRNG.
    ///
    /// [`Algorithm::sprng`]: struct.Algorithm.html#method.sprng
    pub fn sprng() -> Self {
        // This operation is always successful for the SPRNG.
        Self::new(Algorithm::sprng()).unwrap()
    }

    /// Get the algorithm used by this PRNG.
    #[inline]
    pub fn algorithm(&self) -> &Algorithm {
        &self.algorithm
    }

    /// Add entropy to the PRNG state.
    ///
    /// After adding entropy, [`ready`] must be called to actually use it.
    /// It is possible to read and add entropy from a prng at the same time.
    ///
    /// Alternatively you can write into this prng and flush afterwards (which
    /// calls [`ready`]).
    ///
    /// [`ready`]: #method.ready
    pub fn add_entropy(&mut self, input: &[u8]) -> Result<()> {
        unsafe {
            tryt! {
                (self.algorithm.descriptor().add_entropy.unwrap())(input.as_ptr(), input.len() as u64, &mut self.raw)
            }
        }

        Ok(())
    }

    /// Commit any added entropy to the PRNG and make the PRNG ready to read from.
    pub fn ready(&mut self) -> Result<()> {
        unsafe {
            tryt! {
                (self.algorithm.descriptor().ready.unwrap())(&mut self.raw)
            }
        }

        Ok(())
    }
}

impl io::Read for Prng {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        unsafe {
            Ok((self.algorithm.descriptor().read.unwrap())(
                buf.as_mut_ptr(),
                buf.len() as u64,
                &mut self.raw,
            ) as usize)
        }
    }
}

impl io::Write for Prng {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        match self.add_entropy(buf) {
            Ok(_) => Ok(buf.len()),
            Err(e) => Err(io::Error::new(io::ErrorKind::Other, e.to_string())),
        }
    }

    fn flush(&mut self) -> io::Result<()> {
        match self.ready() {
            Ok(_) => Ok(()),
            Err(e) => Err(io::Error::new(io::ErrorKind::Other, e.to_string())),
        }
    }
}

impl Drop for Prng {
    fn drop(&mut self) {
        unsafe {
            (self.algorithm.descriptor().done.unwrap())(&mut self.raw);
        }
    }
}

#[cfg(test)]
mod tests {
    use std::io::Read;
    use super::*;

    #[test]
    fn create_sprng() {
        let mut prng = Prng::sprng();
        test_prng(&mut prng);
    }

    #[test]
    fn create_chacha20() {
        let mut prng = Prng::new(Algorithm::chacha20()).unwrap();
        prng.add_entropy(&[12; 40]).unwrap();
        prng.ready().unwrap();

        test_prng(&mut prng);
    }

    #[test]
    fn create_fortuna() {
        let mut prng = Prng::new(Algorithm::fortuna()).unwrap();
        prng.add_entropy(&[12; 40]).unwrap();
        prng.ready().unwrap();

        test_prng(&mut prng);
    }

    fn test_prng(prng: &mut Prng) {
        let mut data = [0; 128];
        prng.read_exact(&mut data).unwrap();
    }
}
