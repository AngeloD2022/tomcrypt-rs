/* automatically generated by rust-bindgen */

pub const _ASSERT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201706;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 26;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __glibc_c99_flexarr_available: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __HAVE_GENERIC_SELECTION: ::std::os::raw::c_uint = 1;
pub const _STDIO_H: ::std::os::raw::c_uint = 1;
pub const __GLIBC_USE_LIB_EXT2: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: ::std::os::raw::c_uint = 0;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const ____FILE_defined: ::std::os::raw::c_uint = 1;
pub const __FILE_defined: ::std::os::raw::c_uint = 1;
pub const _G_config_h: ::std::os::raw::c_uint = 1;
pub const ____mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MMAP: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MREMAP: ::std::os::raw::c_uint = 1;
pub const _G_IO_IO_FILE_VERSION: ::std::os::raw::c_uint = 131073;
pub const _G_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const _IO_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const _IO_UNIFIED_JUMPTABLES: ::std::os::raw::c_uint = 1;
pub const EOF: ::std::os::raw::c_int = -1;
pub const _IOS_INPUT: ::std::os::raw::c_uint = 1;
pub const _IOS_OUTPUT: ::std::os::raw::c_uint = 2;
pub const _IOS_ATEND: ::std::os::raw::c_uint = 4;
pub const _IOS_APPEND: ::std::os::raw::c_uint = 8;
pub const _IOS_TRUNC: ::std::os::raw::c_uint = 16;
pub const _IOS_NOCREATE: ::std::os::raw::c_uint = 32;
pub const _IOS_NOREPLACE: ::std::os::raw::c_uint = 64;
pub const _IOS_BIN: ::std::os::raw::c_uint = 128;
pub const _IO_MAGIC: ::std::os::raw::c_uint = 4222418944;
pub const _OLD_STDIO_MAGIC: ::std::os::raw::c_uint = 4206624768;
pub const _IO_MAGIC_MASK: ::std::os::raw::c_uint = 4294901760;
pub const _IO_USER_BUF: ::std::os::raw::c_uint = 1;
pub const _IO_UNBUFFERED: ::std::os::raw::c_uint = 2;
pub const _IO_NO_READS: ::std::os::raw::c_uint = 4;
pub const _IO_NO_WRITES: ::std::os::raw::c_uint = 8;
pub const _IO_EOF_SEEN: ::std::os::raw::c_uint = 16;
pub const _IO_ERR_SEEN: ::std::os::raw::c_uint = 32;
pub const _IO_DELETE_DONT_CLOSE: ::std::os::raw::c_uint = 64;
pub const _IO_LINKED: ::std::os::raw::c_uint = 128;
pub const _IO_IN_BACKUP: ::std::os::raw::c_uint = 256;
pub const _IO_LINE_BUF: ::std::os::raw::c_uint = 512;
pub const _IO_TIED_PUT_GET: ::std::os::raw::c_uint = 1024;
pub const _IO_CURRENTLY_PUTTING: ::std::os::raw::c_uint = 2048;
pub const _IO_IS_APPENDING: ::std::os::raw::c_uint = 4096;
pub const _IO_IS_FILEBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_BAD_SEEN: ::std::os::raw::c_uint = 16384;
pub const _IO_USER_LOCK: ::std::os::raw::c_uint = 32768;
pub const _IO_FLAGS2_MMAP: ::std::os::raw::c_uint = 1;
pub const _IO_FLAGS2_NOTCANCEL: ::std::os::raw::c_uint = 2;
pub const _IO_FLAGS2_USER_WBUF: ::std::os::raw::c_uint = 8;
pub const _IO_SKIPWS: ::std::os::raw::c_uint = 1;
pub const _IO_LEFT: ::std::os::raw::c_uint = 2;
pub const _IO_RIGHT: ::std::os::raw::c_uint = 4;
pub const _IO_INTERNAL: ::std::os::raw::c_uint = 8;
pub const _IO_DEC: ::std::os::raw::c_uint = 16;
pub const _IO_OCT: ::std::os::raw::c_uint = 32;
pub const _IO_HEX: ::std::os::raw::c_uint = 64;
pub const _IO_SHOWBASE: ::std::os::raw::c_uint = 128;
pub const _IO_SHOWPOINT: ::std::os::raw::c_uint = 256;
pub const _IO_UPPERCASE: ::std::os::raw::c_uint = 512;
pub const _IO_SHOWPOS: ::std::os::raw::c_uint = 1024;
pub const _IO_SCIENTIFIC: ::std::os::raw::c_uint = 2048;
pub const _IO_FIXED: ::std::os::raw::c_uint = 4096;
pub const _IO_UNITBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_STDIO: ::std::os::raw::c_uint = 16384;
pub const _IO_DONT_CLOSE: ::std::os::raw::c_uint = 32768;
pub const _IO_BOOLALPHA: ::std::os::raw::c_uint = 65536;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\x00";
pub const _BITS_STDIO_LIM_H: ::std::os::raw::c_uint = 1;
pub const L_tmpnam: ::std::os::raw::c_uint = 20;
pub const TMP_MAX: ::std::os::raw::c_uint = 238328;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 4096;
pub const L_ctermid: ::std::os::raw::c_uint = 9;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 16;
pub const _STRING_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPES_LOCALE_T_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPES___LOCALE_T_H: ::std::os::raw::c_uint = 1;
pub const _STRINGS_H: ::std::os::raw::c_uint = 1;
pub const _STDLIB_H: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WSTOPPED: ::std::os::raw::c_uint = 2;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WCONTINUED: ::std::os::raw::c_uint = 8;
pub const WNOWAIT: ::std::os::raw::c_uint = 16777216;
pub const __WNOTHREAD: ::std::os::raw::c_uint = 536870912;
pub const __WALL: ::std::os::raw::c_uint = 1073741824;
pub const __WCLONE: ::std::os::raw::c_uint = 2147483648;
pub const __W_CONTINUED: ::std::os::raw::c_uint = 65535;
pub const __WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const __HAVE_FLOAT128: ::std::os::raw::c_uint = 0;
pub const __HAVE_DISTINCT_FLOAT128: ::std::os::raw::c_uint = 0;
pub const __ldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const __lldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const _BITS_STDINT_INTN_H: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _BITS_UINTN_IDENTITY_H: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const __sigset_t_defined: ::std::os::raw::c_uint = 1;
pub const __timeval_defined: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: ::std::os::raw::c_uint = 1;
pub const _THREAD_SHARED_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const _ALLOCA_H: ::std::os::raw::c_uint = 1;
pub const _TIME_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TIME_H: ::std::os::raw::c_uint = 1;
pub const CLOCK_REALTIME: ::std::os::raw::c_uint = 0;
pub const CLOCK_MONOTONIC: ::std::os::raw::c_uint = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: ::std::os::raw::c_uint = 2;
pub const CLOCK_THREAD_CPUTIME_ID: ::std::os::raw::c_uint = 3;
pub const CLOCK_MONOTONIC_RAW: ::std::os::raw::c_uint = 4;
pub const CLOCK_REALTIME_COARSE: ::std::os::raw::c_uint = 5;
pub const CLOCK_MONOTONIC_COARSE: ::std::os::raw::c_uint = 6;
pub const CLOCK_BOOTTIME: ::std::os::raw::c_uint = 7;
pub const CLOCK_REALTIME_ALARM: ::std::os::raw::c_uint = 8;
pub const CLOCK_BOOTTIME_ALARM: ::std::os::raw::c_uint = 9;
pub const CLOCK_TAI: ::std::os::raw::c_uint = 11;
pub const TIMER_ABSTIME: ::std::os::raw::c_uint = 1;
pub const __struct_tm_defined: ::std::os::raw::c_uint = 1;
pub const __itimerspec_defined: ::std::os::raw::c_uint = 1;
pub const TIME_UTC: ::std::os::raw::c_uint = 1;
pub const _CTYPE_H: ::std::os::raw::c_uint = 1;
pub const _LIBC_LIMITS_H_: ::std::os::raw::c_uint = 1;
pub const MB_LEN_MAX: ::std::os::raw::c_uint = 16;
pub const _BITS_POSIX1_LIM_H: ::std::os::raw::c_uint = 1;
pub const _POSIX_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_AIO_MAX: ::std::os::raw::c_uint = 1;
pub const _POSIX_ARG_MAX: ::std::os::raw::c_uint = 4096;
pub const _POSIX_CHILD_MAX: ::std::os::raw::c_uint = 25;
pub const _POSIX_DELAYTIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_HOST_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_LINK_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_MAX_CANON: ::std::os::raw::c_uint = 255;
pub const _POSIX_MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const _POSIX_MQ_OPEN_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MQ_PRIO_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX_NGROUPS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_OPEN_MAX: ::std::os::raw::c_uint = 20;
pub const _POSIX_PATH_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const _POSIX_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_RTSIG_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_SEM_VALUE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_SIGQUEUE_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_SSIZE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_STREAM_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SYMLINK_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_SYMLOOP_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TTY_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _POSIX_CLOCKRES_MIN: ::std::os::raw::c_uint = 20000000;
pub const NR_OPEN: ::std::os::raw::c_uint = 1024;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 65536;
pub const ARG_MAX: ::std::os::raw::c_uint = 131072;
pub const LINK_MAX: ::std::os::raw::c_uint = 127;
pub const MAX_CANON: ::std::os::raw::c_uint = 255;
pub const MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const PATH_MAX: ::std::os::raw::c_uint = 4096;
pub const PIPE_BUF: ::std::os::raw::c_uint = 4096;
pub const XATTR_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const XATTR_SIZE_MAX: ::std::os::raw::c_uint = 65536;
pub const XATTR_LIST_MAX: ::std::os::raw::c_uint = 65536;
pub const RTSIG_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 128;
pub const PTHREAD_KEYS_MAX: ::std::os::raw::c_uint = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const _POSIX_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 64;
pub const AIO_PRIO_DELTA_MAX: ::std::os::raw::c_uint = 20;
pub const PTHREAD_STACK_MIN: ::std::os::raw::c_uint = 16384;
pub const DELAYTIMER_MAX: ::std::os::raw::c_uint = 2147483647;
pub const TTY_NAME_MAX: ::std::os::raw::c_uint = 32;
pub const LOGIN_NAME_MAX: ::std::os::raw::c_uint = 256;
pub const HOST_NAME_MAX: ::std::os::raw::c_uint = 64;
pub const MQ_PRIO_MAX: ::std::os::raw::c_uint = 32768;
pub const SEM_VALUE_MAX: ::std::os::raw::c_uint = 2147483647;
pub const _BITS_POSIX2_LIM_H: ::std::os::raw::c_uint = 1;
pub const _POSIX2_BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX2_EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX2_LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 255;
pub const EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 2048;
pub const RE_DUP_MAX: ::std::os::raw::c_uint = 32767;
pub const LTC_YARROW_AES: ::std::os::raw::c_uint = 2;
pub const LTC_FORTUNA_WD: ::std::os::raw::c_uint = 10;
pub const LTC_FORTUNA_POOLS: ::std::os::raw::c_uint = 32;
pub const LTC_PK_MAX_RETRIES: ::std::os::raw::c_uint = 20;
pub const LTC_FILE_READ_BUFSIZE: ::std::os::raw::c_uint = 8192;
pub const CRYPT: ::std::os::raw::c_uint = 280;
pub const SCRYPT: &'static [u8; 7usize] = b"1.18.0\x00";
pub const MAXBLOCKSIZE: ::std::os::raw::c_uint = 128;
pub const TAB_SIZE: ::std::os::raw::c_uint = 32;
pub const ARGTYPE: ::std::os::raw::c_uint = 0;
pub const LTC_ENCRYPT: ::std::os::raw::c_uint = 0;
pub const LTC_DECRYPT: ::std::os::raw::c_uint = 1;
pub const LTC_SAFER_K64_DEFAULT_NOF_ROUNDS: ::std::os::raw::c_uint = 6;
pub const LTC_SAFER_K128_DEFAULT_NOF_ROUNDS: ::std::os::raw::c_uint = 10;
pub const LTC_SAFER_SK64_DEFAULT_NOF_ROUNDS: ::std::os::raw::c_uint = 8;
pub const LTC_SAFER_SK128_DEFAULT_NOF_ROUNDS: ::std::os::raw::c_uint = 10;
pub const LTC_SAFER_MAX_NOF_ROUNDS: ::std::os::raw::c_uint = 13;
pub const LTC_SAFER_BLOCK_LEN: ::std::os::raw::c_uint = 8;
pub const LTC_SAFER_KEY_LEN: ::std::os::raw::c_uint = 217;
pub const CTR_COUNTER_LITTLE_ENDIAN: ::std::os::raw::c_uint = 0;
pub const CTR_COUNTER_BIG_ENDIAN: ::std::os::raw::c_uint = 4096;
pub const LTC_CTR_RFC3686: ::std::os::raw::c_uint = 8192;
pub const LRW_ENCRYPT: ::std::os::raw::c_uint = 0;
pub const LRW_DECRYPT: ::std::os::raw::c_uint = 1;
pub const CCM_ENCRYPT: ::std::os::raw::c_uint = 0;
pub const CCM_DECRYPT: ::std::os::raw::c_uint = 1;
pub const GCM_ENCRYPT: ::std::os::raw::c_uint = 0;
pub const GCM_DECRYPT: ::std::os::raw::c_uint = 1;
pub const LTC_GCM_MODE_IV: ::std::os::raw::c_uint = 0;
pub const LTC_GCM_MODE_AAD: ::std::os::raw::c_uint = 1;
pub const LTC_GCM_MODE_TEXT: ::std::os::raw::c_uint = 2;
pub const LTC_XCBC_PURE: ::std::os::raw::c_uint = 32768;
pub const CHCHA20POLY1305_ENCRYPT: ::std::os::raw::c_uint = 0;
pub const CHCHA20POLY1305_DECRYPT: ::std::os::raw::c_uint = 1;
pub const PK_STD: ::std::os::raw::c_uint = 4096;
pub const ECC_BUF_SIZE: ::std::os::raw::c_uint = 256;
pub const ECC_MAXSIZE: ::std::os::raw::c_uint = 66;
pub const LTC_MDSA_DELTA: ::std::os::raw::c_uint = 512;
pub const LTC_MDSA_MAX_GROUP: ::std::os::raw::c_uint = 512;
pub const _WCHAR_H: ::std::os::raw::c_uint = 1;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const __wint_t_defined: ::std::os::raw::c_uint = 1;
pub const _WINT_T: ::std::os::raw::c_uint = 1;
pub const __mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const WEOF: ::std::os::raw::c_uint = 4294967295;
pub const LTC_MP_LT: ::std::os::raw::c_int = -1;
pub const LTC_MP_EQ: ::std::os::raw::c_uint = 0;
pub const LTC_MP_GT: ::std::os::raw::c_uint = 1;
pub const LTC_MP_NO: ::std::os::raw::c_uint = 0;
pub const LTC_MP_YES: ::std::os::raw::c_uint = 1;
pub const LTC_MILLER_RABIN_REPS: ::std::os::raw::c_uint = 40;
pub const _BITS_SIGNUM_H: ::std::os::raw::c_uint = 1;
pub const _BITS_SIGNUM_GENERIC_H: ::std::os::raw::c_uint = 1;
pub const SIGINT: ::std::os::raw::c_uint = 2;
pub const SIGILL: ::std::os::raw::c_uint = 4;
pub const SIGABRT: ::std::os::raw::c_uint = 6;
pub const SIGFPE: ::std::os::raw::c_uint = 8;
pub const SIGSEGV: ::std::os::raw::c_uint = 11;
pub const SIGTERM: ::std::os::raw::c_uint = 15;
pub const SIGHUP: ::std::os::raw::c_uint = 1;
pub const SIGQUIT: ::std::os::raw::c_uint = 3;
pub const SIGTRAP: ::std::os::raw::c_uint = 5;
pub const SIGKILL: ::std::os::raw::c_uint = 9;
pub const SIGBUS: ::std::os::raw::c_uint = 10;
pub const SIGSYS: ::std::os::raw::c_uint = 12;
pub const SIGPIPE: ::std::os::raw::c_uint = 13;
pub const SIGALRM: ::std::os::raw::c_uint = 14;
pub const SIGURG: ::std::os::raw::c_uint = 16;
pub const SIGSTOP: ::std::os::raw::c_uint = 17;
pub const SIGTSTP: ::std::os::raw::c_uint = 18;
pub const SIGCONT: ::std::os::raw::c_uint = 19;
pub const SIGCHLD: ::std::os::raw::c_uint = 20;
pub const SIGTTIN: ::std::os::raw::c_uint = 21;
pub const SIGTTOU: ::std::os::raw::c_uint = 22;
pub const SIGPOLL: ::std::os::raw::c_uint = 23;
pub const SIGXCPU: ::std::os::raw::c_uint = 24;
pub const SIGXFSZ: ::std::os::raw::c_uint = 25;
pub const SIGVTALRM: ::std::os::raw::c_uint = 26;
pub const SIGPROF: ::std::os::raw::c_uint = 27;
pub const SIGUSR1: ::std::os::raw::c_uint = 30;
pub const SIGUSR2: ::std::os::raw::c_uint = 31;
pub const SIGWINCH: ::std::os::raw::c_uint = 28;
pub const SIGIO: ::std::os::raw::c_uint = 23;
pub const SIGIOT: ::std::os::raw::c_uint = 6;
pub const SIGCLD: ::std::os::raw::c_uint = 20;
pub const __SIGRTMIN: ::std::os::raw::c_uint = 32;
pub const __SIGRTMAX: ::std::os::raw::c_uint = 32;
pub const _NSIG: ::std::os::raw::c_uint = 33;
pub const SIGSTKFLT: ::std::os::raw::c_uint = 16;
pub const SIGPWR: ::std::os::raw::c_uint = 30;
pub const __sig_atomic_t_defined: ::std::os::raw::c_uint = 1;
pub const __siginfo_t_defined: ::std::os::raw::c_uint = 1;
pub const __SI_MAX_SIZE: ::std::os::raw::c_uint = 128;
pub const _BITS_SIGINFO_ARCH_H: ::std::os::raw::c_uint = 1;
pub const __SI_ERRNO_THEN_CODE: ::std::os::raw::c_uint = 1;
pub const __SI_HAVE_SIGSYS: ::std::os::raw::c_uint = 1;
pub const _BITS_SIGINFO_CONSTS_H: ::std::os::raw::c_uint = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: ::std::os::raw::c_uint = 1;
pub const __sigevent_t_defined: ::std::os::raw::c_uint = 1;
pub const __SIGEV_MAX_SIZE: ::std::os::raw::c_uint = 64;
pub const _BITS_SIGEVENT_CONSTS_H: ::std::os::raw::c_uint = 1;
pub const NSIG: ::std::os::raw::c_uint = 33;
pub const SA_NOCLDSTOP: ::std::os::raw::c_uint = 1;
pub const SA_NOCLDWAIT: ::std::os::raw::c_uint = 2;
pub const SA_SIGINFO: ::std::os::raw::c_uint = 4;
pub const SA_ONSTACK: ::std::os::raw::c_uint = 134217728;
pub const SA_RESTART: ::std::os::raw::c_uint = 268435456;
pub const SA_NODEFER: ::std::os::raw::c_uint = 1073741824;
pub const SA_RESETHAND: ::std::os::raw::c_uint = 2147483648;
pub const SA_INTERRUPT: ::std::os::raw::c_uint = 536870912;
pub const SA_NOMASK: ::std::os::raw::c_uint = 1073741824;
pub const SA_ONESHOT: ::std::os::raw::c_uint = 2147483648;
pub const SA_STACK: ::std::os::raw::c_uint = 134217728;
pub const SIG_BLOCK: ::std::os::raw::c_uint = 0;
pub const SIG_UNBLOCK: ::std::os::raw::c_uint = 1;
pub const SIG_SETMASK: ::std::os::raw::c_uint = 2;
pub const _BITS_SIGCONTEXT_H: ::std::os::raw::c_uint = 1;
pub const FP_XSTATE_MAGIC1: ::std::os::raw::c_uint = 1179670611;
pub const FP_XSTATE_MAGIC2: ::std::os::raw::c_uint = 1179670597;
pub const __stack_t_defined: ::std::os::raw::c_uint = 1;
pub const _SYS_UCONTEXT_H: ::std::os::raw::c_uint = 1;
pub const __NGREG: ::std::os::raw::c_uint = 23;
pub const NGREG: ::std::os::raw::c_uint = 23;
pub const _BITS_SIGSTACK_H: ::std::os::raw::c_uint = 1;
pub const MINSIGSTKSZ: ::std::os::raw::c_uint = 2048;
pub const SIGSTKSZ: ::std::os::raw::c_uint = 8192;
pub const _BITS_SS_FLAGS_H: ::std::os::raw::c_uint = 1;
pub const __sigstack_defined: ::std::os::raw::c_uint = 1;
pub const _BITS_SIGTHREAD_H: ::std::os::raw::c_uint = 1;
extern "C" {
    pub fn __assert_fail(__assertion: *const ::std::os::raw::c_char,
                         __file: *const ::std::os::raw::c_char,
                         __line: ::std::os::raw::c_uint,
                         __function: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __assert_perror_fail(__errnum: ::std::os::raw::c_int,
                                __file: *const ::std::os::raw::c_char,
                                __line: ::std::os::raw::c_uint,
                                __function: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __assert(__assertion: *const ::std::os::raw::c_char,
                    __file: *const ::std::os::raw::c_char,
                    __line: ::std::os::raw::c_int);
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>() , 216usize , concat ! (
               "Size of: " , stringify ! ( _IO_FILE ) ));
    assert_eq! (::std::mem::align_of::<_IO_FILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_FILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_ptr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_end as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_base as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_base as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_ptr as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_end as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_base as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_end as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_base as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_backup_base as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_backup_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_end as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _markers as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _markers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _chain as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _chain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _fileno as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _fileno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags2 as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _old_offset as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _old_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _cur_column as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _cur_column ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _vtable_offset as * const
                _ as usize } , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _vtable_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _shortbuf as * const _ as
                usize } , 131usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _shortbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _lock as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad1 as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad2 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad3 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad4 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad5 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _mode as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _unused2 as * const _ as
                usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _unused2 ) ));
}
impl Clone for _IO_FILE {
    fn clone(&self) -> Self { *self }
}
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wch as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wchb as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb )
                ));
}
impl Clone for __mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __value as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __value ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos64_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos64_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos64_t {
    fn clone(&self) -> Self { *self }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::std::mem::size_of::<_IO_marker>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _IO_marker ) ));
    assert_eq! (::std::mem::align_of::<_IO_marker>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_marker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _sbuf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _pos as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _pos ) ));
}
impl Clone for _IO_marker {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *mut ::std::os::raw::c_char,
                                               __nbytes: usize) -> __ssize_t>;
pub type __io_write_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *const ::std::os::raw::c_char,
                                               __n: usize) -> __ssize_t>;
pub type __io_seek_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __pos: *mut __off64_t,
                                               __w: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type __io_close_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *mut __va_list_tag,
                       arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void,
                     arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: usize,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                     __format: *const ::std::os::raw::c_char,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: ::std::os::raw::c_int,
                    __fmt: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_sscanf"]
    pub fn sscanf1(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfscanf"]
    pub fn vfscanf1(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vscanf"]
    pub fn vscanf1(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vsscanf"]
    pub fn vsscanf1(__s: *const ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut usize, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __n: usize, __s: *mut FILE) -> usize;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                          __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: usize, __n: usize, __stream: *mut FILE)
     -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(__s: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize , concat !
               ( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq! (::std::mem::align_of::<__locale_struct>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __locales as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __locales ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __names as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __names ) ));
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char,
                     __s2: *const ::std::os::raw::c_char, __l: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize,
                     __l: locale_t) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __reject: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __accept: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __accept: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const ::std::os::raw::c_char,
                  __needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(__s: *mut ::std::os::raw::c_char,
                      __delim: *const ::std::os::raw::c_char,
                      __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(__s: *mut ::std::os::raw::c_char,
                    __delim: *const ::std::os::raw::c_char,
                    __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize)
     -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__xpg_strerror_r"]
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __buf: *mut ::std::os::raw::c_char, __buflen: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: locale_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(__s1: *const ::std::os::raw::c_void,
                __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const ::std::os::raw::c_void,
                 __dest: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn index(__s: *const ::std::os::raw::c_char,
                 __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char,
                       __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(__s1: *const ::std::os::raw::c_char,
                        __s2: *const ::std::os::raw::c_char, __loc: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(__s1: *const ::std::os::raw::c_char,
                         __s2: *const ::std::os::raw::c_char, __n: usize,
                         __loc: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char,
                    __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint) -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(::std::mem::size_of::<__pthread_rwlock_arch_t>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_rwlock_arch_t ) ));
    assert_eq! (::std::mem::align_of::<__pthread_rwlock_arch_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_rwlock_arch_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __readers
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __writers
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __writers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) .
                __wrphase_futex as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __wrphase_futex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) .
                __writers_futex as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __writers_futex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __pad3 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __pad4 as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) .
                __cur_writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __cur_writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __shared as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __rwelision
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __pad1 as *
                const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __pad2 as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __flags as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __flags ) ));
}
impl Clone for __pthread_rwlock_arch_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<__pthread_mutex_s>() , 40usize , concat !
               ( "Size of: " , stringify ! ( __pthread_mutex_s ) ));
    assert_eq! (::std::mem::align_of::<__pthread_mutex_s>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( __pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_mutex_s ) ) . __lock as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_mutex_s ) ,
                "::" , stringify ! ( __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_mutex_s ) ) . __count as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_mutex_s ) ,
                "::" , stringify ! ( __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_mutex_s ) ) . __owner as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_mutex_s ) ,
                "::" , stringify ! ( __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_mutex_s ) ) . __nusers as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_mutex_s ) ,
                "::" , stringify ! ( __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_mutex_s ) ) . __kind as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_mutex_s ) ,
                "::" , stringify ! ( __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_mutex_s ) ) . __spins as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_mutex_s ) ,
                "::" , stringify ! ( __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_mutex_s ) ) . __elision as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_mutex_s ) ,
                "::" , stringify ! ( __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_mutex_s ) ) . __list as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_mutex_s ) ,
                "::" , stringify ! ( __list ) ));
}
impl Clone for __pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const __pthread_cond_s__bindgen_ty_1__bindgen_ty_1
                ) ) . __low as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( __low ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const __pthread_cond_s__bindgen_ty_1__bindgen_ty_1
                ) ) . __high as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( __high ) ));
}
impl Clone for __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_1 ) ) .
                __wseq as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __pthread_cond_s__bindgen_ty_1 ) , "::" , stringify ! ( __wseq
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_1 ) ) .
                __wseq32 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __pthread_cond_s__bindgen_ty_1 ) , "::" , stringify ! (
                __wseq32 ) ));
}
impl Clone for __pthread_cond_s__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const __pthread_cond_s__bindgen_ty_2__bindgen_ty_1
                ) ) . __low as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( __low ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const __pthread_cond_s__bindgen_ty_2__bindgen_ty_1
                ) ) . __high as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( __high ) ));
}
impl Clone for __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_2 ) ) .
                __g1_start as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __pthread_cond_s__bindgen_ty_2 ) , "::" , stringify ! (
                __g1_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_2 ) ) .
                __g1_start32 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __pthread_cond_s__bindgen_ty_2 ) , "::" , stringify ! (
                __g1_start32 ) ));
}
impl Clone for __pthread_cond_s__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(::std::mem::size_of::<__pthread_cond_s>() , 48usize , concat !
               ( "Size of: " , stringify ! ( __pthread_cond_s ) ));
    assert_eq! (::std::mem::align_of::<__pthread_cond_s>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __pthread_cond_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s ) ) . __g_refs as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cond_s ) ,
                "::" , stringify ! ( __g_refs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s ) ) . __g_size as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cond_s ) ,
                "::" , stringify ! ( __g_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s ) ) . __g1_orig_size as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cond_s ) ,
                "::" , stringify ! ( __g1_orig_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s ) ) . __wrefs as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cond_s ) ,
                "::" , stringify ! ( __wrefs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s ) ) . __g_signals as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cond_s ) ,
                "::" , stringify ! ( __g_signals ) ));
}
impl Clone for __pthread_cond_s {
    fn clone(&self) -> Self { *self }
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( random_data ) ));
    assert_eq! (::std::mem::align_of::<random_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( random_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . fptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( fptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rptr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_deg as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_deg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_sep as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . end_ptr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( end_ptr ) ));
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: usize, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drand48_data ) ));
    assert_eq! (::std::mem::align_of::<drand48_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drand48_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __old_x as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __old_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __c as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __init as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __a as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __a ) ));
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                 __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *const ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::std::mem::size_of::<max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce1 as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce2 as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce2 ) ));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 56usize , concat ! (
               "Size of: " , stringify ! ( tm ) ));
    assert_eq! (::std::mem::align_of::<tm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_sec as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_min as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_hour as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mday as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mon as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_year as * const _ as usize }
                , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_wday as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_wday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_yday as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_yday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_isdst as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_isdst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_gmtoff as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_gmtoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_zone as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_zone ) ));
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::std::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::std::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! (
               sigevent__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1__bindgen_ty_1 ) )
                . _function as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                _function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1__bindgen_ty_1 ) )
                . _attribute as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                _attribute ) ));
}
impl Clone for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigevent__bindgen_ty_1>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( sigevent__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<sigevent__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigevent__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) . _pad as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) . _tid as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _tid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) .
                _sigev_thread as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _sigev_thread ) ));
}
impl Clone for sigevent__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(::std::mem::size_of::<sigevent>() , 64usize , concat ! (
               "Size of: " , stringify ! ( sigevent ) ));
    assert_eq! (::std::mem::align_of::<sigevent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_value as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_signo as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . _sigev_un as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( _sigev_un ) ));
}
impl Clone for sigevent {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(__s: *mut ::std::os::raw::c_char, __maxsize: usize,
                    __format: *const ::std::os::raw::c_char, __tp: *const tm)
     -> usize;
}
extern "C" {
    pub fn strftime_l(__s: *mut ::std::os::raw::c_char, __maxsize: usize,
                      __format: *const ::std::os::raw::c_char,
                      __tp: *const tm, __loc: locale_t) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__tzname"]
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "__daylight"]
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__timezone"]
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    #[link_name = "daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec,
                     __remaining: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(__clock_id: clockid_t,
                           __flags: ::std::os::raw::c_int,
                           __req: *const timespec, __rem: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut sigevent,
                        __timerid: *mut timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(__timerid: timer_t, __flags: ::std::os::raw::c_int,
                         __value: *const itimerspec,
                         __ovalue: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub const _ISupper: _bindgen_ty_1 = _bindgen_ty_1::_ISupper;
pub const _ISlower: _bindgen_ty_1 = _bindgen_ty_1::_ISlower;
pub const _ISalpha: _bindgen_ty_1 = _bindgen_ty_1::_ISalpha;
pub const _ISdigit: _bindgen_ty_1 = _bindgen_ty_1::_ISdigit;
pub const _ISxdigit: _bindgen_ty_1 = _bindgen_ty_1::_ISxdigit;
pub const _ISspace: _bindgen_ty_1 = _bindgen_ty_1::_ISspace;
pub const _ISprint: _bindgen_ty_1 = _bindgen_ty_1::_ISprint;
pub const _ISgraph: _bindgen_ty_1 = _bindgen_ty_1::_ISgraph;
pub const _ISblank: _bindgen_ty_1 = _bindgen_ty_1::_ISblank;
pub const _IScntrl: _bindgen_ty_1 = _bindgen_ty_1::_IScntrl;
pub const _ISpunct: _bindgen_ty_1 = _bindgen_ty_1::_ISpunct;
pub const _ISalnum: _bindgen_ty_1 = _bindgen_ty_1::_ISalnum;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8,
}
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t)
     -> ::std::os::raw::c_int;
}
pub const CRYPT_OK: _bindgen_ty_2 = _bindgen_ty_2::CRYPT_OK;
pub const CRYPT_ERROR: _bindgen_ty_2 = _bindgen_ty_2::CRYPT_ERROR;
pub const CRYPT_NOP: _bindgen_ty_2 = _bindgen_ty_2::CRYPT_NOP;
pub const CRYPT_INVALID_KEYSIZE: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_INVALID_KEYSIZE;
pub const CRYPT_INVALID_ROUNDS: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_INVALID_ROUNDS;
pub const CRYPT_FAIL_TESTVECTOR: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_FAIL_TESTVECTOR;
pub const CRYPT_BUFFER_OVERFLOW: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_BUFFER_OVERFLOW;
pub const CRYPT_INVALID_PACKET: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_INVALID_PACKET;
pub const CRYPT_INVALID_PRNGSIZE: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_INVALID_PRNGSIZE;
pub const CRYPT_ERROR_READPRNG: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_ERROR_READPRNG;
pub const CRYPT_INVALID_CIPHER: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_INVALID_CIPHER;
pub const CRYPT_INVALID_HASH: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_INVALID_HASH;
pub const CRYPT_INVALID_PRNG: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_INVALID_PRNG;
pub const CRYPT_MEM: _bindgen_ty_2 = _bindgen_ty_2::CRYPT_MEM;
pub const CRYPT_PK_TYPE_MISMATCH: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_PK_TYPE_MISMATCH;
pub const CRYPT_PK_NOT_PRIVATE: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_PK_NOT_PRIVATE;
pub const CRYPT_INVALID_ARG: _bindgen_ty_2 = _bindgen_ty_2::CRYPT_INVALID_ARG;
pub const CRYPT_FILE_NOTFOUND: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_FILE_NOTFOUND;
pub const CRYPT_PK_INVALID_TYPE: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_PK_INVALID_TYPE;
pub const CRYPT_OVERFLOW: _bindgen_ty_2 = _bindgen_ty_2::CRYPT_OVERFLOW;
pub const CRYPT_UNUSED1: _bindgen_ty_2 = _bindgen_ty_2::CRYPT_UNUSED1;
pub const CRYPT_INPUT_TOO_LONG: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_INPUT_TOO_LONG;
pub const CRYPT_PK_INVALID_SIZE: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_PK_INVALID_SIZE;
pub const CRYPT_INVALID_PRIME_SIZE: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_INVALID_PRIME_SIZE;
pub const CRYPT_PK_INVALID_PADDING: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_PK_INVALID_PADDING;
pub const CRYPT_HASH_OVERFLOW: _bindgen_ty_2 =
    _bindgen_ty_2::CRYPT_HASH_OVERFLOW;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    CRYPT_OK = 0,
    CRYPT_ERROR = 1,
    CRYPT_NOP = 2,
    CRYPT_INVALID_KEYSIZE = 3,
    CRYPT_INVALID_ROUNDS = 4,
    CRYPT_FAIL_TESTVECTOR = 5,
    CRYPT_BUFFER_OVERFLOW = 6,
    CRYPT_INVALID_PACKET = 7,
    CRYPT_INVALID_PRNGSIZE = 8,
    CRYPT_ERROR_READPRNG = 9,
    CRYPT_INVALID_CIPHER = 10,
    CRYPT_INVALID_HASH = 11,
    CRYPT_INVALID_PRNG = 12,
    CRYPT_MEM = 13,
    CRYPT_PK_TYPE_MISMATCH = 14,
    CRYPT_PK_NOT_PRIVATE = 15,
    CRYPT_INVALID_ARG = 16,
    CRYPT_FILE_NOTFOUND = 17,
    CRYPT_PK_INVALID_TYPE = 18,
    CRYPT_OVERFLOW = 19,
    CRYPT_UNUSED1 = 20,
    CRYPT_INPUT_TOO_LONG = 21,
    CRYPT_PK_INVALID_SIZE = 22,
    CRYPT_INVALID_PRIME_SIZE = 23,
    CRYPT_PK_INVALID_PADDING = 24,
    CRYPT_HASH_OVERFLOW = 25,
}
pub type ulong64 = ::std::os::raw::c_ulonglong;
pub type ulong32 = ::std::os::raw::c_uint;
pub type ltc_mp_digit = ::std::os::raw::c_ulonglong;
pub type LTC_FAST_TYPE = ulong64;
#[repr(C)]
#[derive(Copy)]
pub struct blowfish_key {
    pub S: [[ulong32; 256usize]; 4usize],
    pub K: [ulong32; 18usize],
}
#[test]
fn bindgen_test_layout_blowfish_key() {
    assert_eq!(::std::mem::size_of::<blowfish_key>() , 4168usize , concat ! (
               "Size of: " , stringify ! ( blowfish_key ) ));
    assert_eq! (::std::mem::align_of::<blowfish_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( blowfish_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blowfish_key ) ) . S as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( blowfish_key ) , "::" ,
                stringify ! ( S ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blowfish_key ) ) . K as * const _ as
                usize } , 4096usize , concat ! (
                "Alignment of field: " , stringify ! ( blowfish_key ) , "::" ,
                stringify ! ( K ) ));
}
impl Clone for blowfish_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct rc5_key {
    pub rounds: ::std::os::raw::c_int,
    pub K: [ulong32; 50usize],
}
#[test]
fn bindgen_test_layout_rc5_key() {
    assert_eq!(::std::mem::size_of::<rc5_key>() , 204usize , concat ! (
               "Size of: " , stringify ! ( rc5_key ) ));
    assert_eq! (::std::mem::align_of::<rc5_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rc5_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rc5_key ) ) . rounds as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rc5_key ) , "::" ,
                stringify ! ( rounds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rc5_key ) ) . K as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( rc5_key ) , "::" ,
                stringify ! ( K ) ));
}
impl Clone for rc5_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct rc6_key {
    pub K: [ulong32; 44usize],
}
#[test]
fn bindgen_test_layout_rc6_key() {
    assert_eq!(::std::mem::size_of::<rc6_key>() , 176usize , concat ! (
               "Size of: " , stringify ! ( rc6_key ) ));
    assert_eq! (::std::mem::align_of::<rc6_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rc6_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rc6_key ) ) . K as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( rc6_key ) , "::" ,
                stringify ! ( K ) ));
}
impl Clone for rc6_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct saferp_key {
    pub K: [[::std::os::raw::c_uchar; 16usize]; 33usize],
    pub rounds: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_saferp_key() {
    assert_eq!(::std::mem::size_of::<saferp_key>() , 536usize , concat ! (
               "Size of: " , stringify ! ( saferp_key ) ));
    assert_eq! (::std::mem::align_of::<saferp_key>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( saferp_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const saferp_key ) ) . K as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( saferp_key ) , "::" ,
                stringify ! ( K ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const saferp_key ) ) . rounds as * const _ as
                usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( saferp_key ) , "::" ,
                stringify ! ( rounds ) ));
}
impl Clone for saferp_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct rijndael_key {
    pub eK: [ulong32; 60usize],
    pub dK: [ulong32; 60usize],
    pub Nr: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rijndael_key() {
    assert_eq!(::std::mem::size_of::<rijndael_key>() , 484usize , concat ! (
               "Size of: " , stringify ! ( rijndael_key ) ));
    assert_eq! (::std::mem::align_of::<rijndael_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rijndael_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rijndael_key ) ) . eK as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rijndael_key ) , "::" ,
                stringify ! ( eK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rijndael_key ) ) . dK as * const _ as
                usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( rijndael_key ) , "::" ,
                stringify ! ( dK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rijndael_key ) ) . Nr as * const _ as
                usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( rijndael_key ) , "::" ,
                stringify ! ( Nr ) ));
}
impl Clone for rijndael_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kseed_key {
    pub K: [ulong32; 32usize],
    pub dK: [ulong32; 32usize],
}
#[test]
fn bindgen_test_layout_kseed_key() {
    assert_eq!(::std::mem::size_of::<kseed_key>() , 256usize , concat ! (
               "Size of: " , stringify ! ( kseed_key ) ));
    assert_eq! (::std::mem::align_of::<kseed_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kseed_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kseed_key ) ) . K as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kseed_key ) , "::" ,
                stringify ! ( K ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kseed_key ) ) . dK as * const _ as usize
                } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( kseed_key ) , "::" ,
                stringify ! ( dK ) ));
}
impl Clone for kseed_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kasumi_key {
    pub KLi1: [ulong32; 8usize],
    pub KLi2: [ulong32; 8usize],
    pub KOi1: [ulong32; 8usize],
    pub KOi2: [ulong32; 8usize],
    pub KOi3: [ulong32; 8usize],
    pub KIi1: [ulong32; 8usize],
    pub KIi2: [ulong32; 8usize],
    pub KIi3: [ulong32; 8usize],
}
#[test]
fn bindgen_test_layout_kasumi_key() {
    assert_eq!(::std::mem::size_of::<kasumi_key>() , 256usize , concat ! (
               "Size of: " , stringify ! ( kasumi_key ) ));
    assert_eq! (::std::mem::align_of::<kasumi_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kasumi_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kasumi_key ) ) . KLi1 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kasumi_key ) , "::" ,
                stringify ! ( KLi1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kasumi_key ) ) . KLi2 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( kasumi_key ) , "::" ,
                stringify ! ( KLi2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kasumi_key ) ) . KOi1 as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( kasumi_key ) , "::" ,
                stringify ! ( KOi1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kasumi_key ) ) . KOi2 as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( kasumi_key ) , "::" ,
                stringify ! ( KOi2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kasumi_key ) ) . KOi3 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( kasumi_key ) , "::" ,
                stringify ! ( KOi3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kasumi_key ) ) . KIi1 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( kasumi_key ) , "::" ,
                stringify ! ( KIi1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kasumi_key ) ) . KIi2 as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( kasumi_key ) , "::" ,
                stringify ! ( KIi2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kasumi_key ) ) . KIi3 as * const _ as
                usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( kasumi_key ) , "::" ,
                stringify ! ( KIi3 ) ));
}
impl Clone for kasumi_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xtea_key {
    pub A: [::std::os::raw::c_ulong; 32usize],
    pub B: [::std::os::raw::c_ulong; 32usize],
}
#[test]
fn bindgen_test_layout_xtea_key() {
    assert_eq!(::std::mem::size_of::<xtea_key>() , 512usize , concat ! (
               "Size of: " , stringify ! ( xtea_key ) ));
    assert_eq! (::std::mem::align_of::<xtea_key>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( xtea_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xtea_key ) ) . A as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xtea_key ) , "::" ,
                stringify ! ( A ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xtea_key ) ) . B as * const _ as usize }
                , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( xtea_key ) , "::" ,
                stringify ! ( B ) ));
}
impl Clone for xtea_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct twofish_key {
    pub S: [[ulong32; 256usize]; 4usize],
    pub K: [ulong32; 40usize],
}
#[test]
fn bindgen_test_layout_twofish_key() {
    assert_eq!(::std::mem::size_of::<twofish_key>() , 4256usize , concat ! (
               "Size of: " , stringify ! ( twofish_key ) ));
    assert_eq! (::std::mem::align_of::<twofish_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( twofish_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const twofish_key ) ) . S as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( twofish_key ) , "::" ,
                stringify ! ( S ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const twofish_key ) ) . K as * const _ as usize
                } , 4096usize , concat ! (
                "Alignment of field: " , stringify ! ( twofish_key ) , "::" ,
                stringify ! ( K ) ));
}
impl Clone for twofish_key {
    fn clone(&self) -> Self { *self }
}
pub type safer_block_t = [::std::os::raw::c_uchar; 8usize];
pub type safer_key_t = [::std::os::raw::c_uchar; 217usize];
#[repr(C)]
#[derive(Copy)]
pub struct safer_key {
    pub key: safer_key_t,
}
#[test]
fn bindgen_test_layout_safer_key() {
    assert_eq!(::std::mem::size_of::<safer_key>() , 217usize , concat ! (
               "Size of: " , stringify ! ( safer_key ) ));
    assert_eq! (::std::mem::align_of::<safer_key>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( safer_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const safer_key ) ) . key as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( safer_key ) , "::" ,
                stringify ! ( key ) ));
}
impl Clone for safer_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct rc2_key {
    pub xkey: [::std::os::raw::c_uint; 64usize],
}
#[test]
fn bindgen_test_layout_rc2_key() {
    assert_eq!(::std::mem::size_of::<rc2_key>() , 256usize , concat ! (
               "Size of: " , stringify ! ( rc2_key ) ));
    assert_eq! (::std::mem::align_of::<rc2_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rc2_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rc2_key ) ) . xkey as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rc2_key ) , "::" ,
                stringify ! ( xkey ) ));
}
impl Clone for rc2_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct des_key {
    pub ek: [ulong32; 32usize],
    pub dk: [ulong32; 32usize],
}
#[test]
fn bindgen_test_layout_des_key() {
    assert_eq!(::std::mem::size_of::<des_key>() , 256usize , concat ! (
               "Size of: " , stringify ! ( des_key ) ));
    assert_eq! (::std::mem::align_of::<des_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( des_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const des_key ) ) . ek as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( des_key ) , "::" ,
                stringify ! ( ek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const des_key ) ) . dk as * const _ as usize }
                , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( des_key ) , "::" ,
                stringify ! ( dk ) ));
}
impl Clone for des_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct des3_key {
    pub ek: [[ulong32; 32usize]; 3usize],
    pub dk: [[ulong32; 32usize]; 3usize],
}
#[test]
fn bindgen_test_layout_des3_key() {
    assert_eq!(::std::mem::size_of::<des3_key>() , 768usize , concat ! (
               "Size of: " , stringify ! ( des3_key ) ));
    assert_eq! (::std::mem::align_of::<des3_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( des3_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const des3_key ) ) . ek as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( des3_key ) , "::" ,
                stringify ! ( ek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const des3_key ) ) . dk as * const _ as usize }
                , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( des3_key ) , "::" ,
                stringify ! ( dk ) ));
}
impl Clone for des3_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cast5_key {
    pub K: [ulong32; 32usize],
    pub keylen: ulong32,
}
#[test]
fn bindgen_test_layout_cast5_key() {
    assert_eq!(::std::mem::size_of::<cast5_key>() , 132usize , concat ! (
               "Size of: " , stringify ! ( cast5_key ) ));
    assert_eq! (::std::mem::align_of::<cast5_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( cast5_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cast5_key ) ) . K as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cast5_key ) , "::" ,
                stringify ! ( K ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cast5_key ) ) . keylen as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( cast5_key ) , "::" ,
                stringify ! ( keylen ) ));
}
impl Clone for cast5_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct noekeon_key {
    pub K: [ulong32; 4usize],
    pub dK: [ulong32; 4usize],
}
#[test]
fn bindgen_test_layout_noekeon_key() {
    assert_eq!(::std::mem::size_of::<noekeon_key>() , 32usize , concat ! (
               "Size of: " , stringify ! ( noekeon_key ) ));
    assert_eq! (::std::mem::align_of::<noekeon_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( noekeon_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const noekeon_key ) ) . K as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( noekeon_key ) , "::" ,
                stringify ! ( K ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const noekeon_key ) ) . dK as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( noekeon_key ) , "::" ,
                stringify ! ( dK ) ));
}
impl Clone for noekeon_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct skipjack_key {
    pub key: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout_skipjack_key() {
    assert_eq!(::std::mem::size_of::<skipjack_key>() , 10usize , concat ! (
               "Size of: " , stringify ! ( skipjack_key ) ));
    assert_eq! (::std::mem::align_of::<skipjack_key>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( skipjack_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const skipjack_key ) ) . key as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( skipjack_key ) , "::" ,
                stringify ! ( key ) ));
}
impl Clone for skipjack_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct khazad_key {
    pub roundKeyEnc: [ulong64; 9usize],
    pub roundKeyDec: [ulong64; 9usize],
}
#[test]
fn bindgen_test_layout_khazad_key() {
    assert_eq!(::std::mem::size_of::<khazad_key>() , 144usize , concat ! (
               "Size of: " , stringify ! ( khazad_key ) ));
    assert_eq! (::std::mem::align_of::<khazad_key>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( khazad_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const khazad_key ) ) . roundKeyEnc as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( khazad_key ) , "::" ,
                stringify ! ( roundKeyEnc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const khazad_key ) ) . roundKeyDec as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( khazad_key ) , "::" ,
                stringify ! ( roundKeyDec ) ));
}
impl Clone for khazad_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct anubis_key {
    pub keyBits: ::std::os::raw::c_int,
    pub R: ::std::os::raw::c_int,
    pub roundKeyEnc: [[ulong32; 4usize]; 19usize],
    pub roundKeyDec: [[ulong32; 4usize]; 19usize],
}
#[test]
fn bindgen_test_layout_anubis_key() {
    assert_eq!(::std::mem::size_of::<anubis_key>() , 616usize , concat ! (
               "Size of: " , stringify ! ( anubis_key ) ));
    assert_eq! (::std::mem::align_of::<anubis_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( anubis_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const anubis_key ) ) . keyBits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( anubis_key ) , "::" ,
                stringify ! ( keyBits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const anubis_key ) ) . R as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( anubis_key ) , "::" ,
                stringify ! ( R ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const anubis_key ) ) . roundKeyEnc as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( anubis_key ) , "::" ,
                stringify ! ( roundKeyEnc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const anubis_key ) ) . roundKeyDec as * const _
                as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( anubis_key ) , "::" ,
                stringify ! ( roundKeyDec ) ));
}
impl Clone for anubis_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct multi2_key {
    pub N: ::std::os::raw::c_int,
    pub uk: [ulong32; 8usize],
}
#[test]
fn bindgen_test_layout_multi2_key() {
    assert_eq!(::std::mem::size_of::<multi2_key>() , 36usize , concat ! (
               "Size of: " , stringify ! ( multi2_key ) ));
    assert_eq! (::std::mem::align_of::<multi2_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( multi2_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multi2_key ) ) . N as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( multi2_key ) , "::" ,
                stringify ! ( N ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multi2_key ) ) . uk as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( multi2_key ) , "::" ,
                stringify ! ( uk ) ));
}
impl Clone for multi2_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct camellia_key {
    pub R: ::std::os::raw::c_int,
    pub kw: [ulong64; 4usize],
    pub k: [ulong64; 24usize],
    pub kl: [ulong64; 6usize],
}
#[test]
fn bindgen_test_layout_camellia_key() {
    assert_eq!(::std::mem::size_of::<camellia_key>() , 280usize , concat ! (
               "Size of: " , stringify ! ( camellia_key ) ));
    assert_eq! (::std::mem::align_of::<camellia_key>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( camellia_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const camellia_key ) ) . R as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( camellia_key ) , "::" ,
                stringify ! ( R ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const camellia_key ) ) . kw as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( camellia_key ) , "::" ,
                stringify ! ( kw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const camellia_key ) ) . k as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( camellia_key ) , "::" ,
                stringify ! ( k ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const camellia_key ) ) . kl as * const _ as
                usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( camellia_key ) , "::" ,
                stringify ! ( kl ) ));
}
impl Clone for camellia_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union Symmetric_key {
    pub des: des_key,
    pub des3: des3_key,
    pub rc2: rc2_key,
    pub safer: safer_key,
    pub twofish: twofish_key,
    pub blowfish: blowfish_key,
    pub rc5: rc5_key,
    pub rc6: rc6_key,
    pub saferp: saferp_key,
    pub rijndael: rijndael_key,
    pub xtea: xtea_key,
    pub cast5: cast5_key,
    pub noekeon: noekeon_key,
    pub skipjack: skipjack_key,
    pub khazad: khazad_key,
    pub anubis: anubis_key,
    pub kseed: kseed_key,
    pub kasumi: kasumi_key,
    pub multi2: multi2_key,
    pub camellia: camellia_key,
    pub data: *mut ::std::os::raw::c_void,
    _bindgen_union_align: [u64; 532usize],
}
#[test]
fn bindgen_test_layout_Symmetric_key() {
    assert_eq!(::std::mem::size_of::<Symmetric_key>() , 4256usize , concat ! (
               "Size of: " , stringify ! ( Symmetric_key ) ));
    assert_eq! (::std::mem::align_of::<Symmetric_key>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Symmetric_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . des as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( des ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . des3 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( des3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . rc2 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( rc2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . safer as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( safer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . twofish as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( twofish ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . blowfish as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( blowfish ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . rc5 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( rc5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . rc6 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( rc6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . saferp as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( saferp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . rijndael as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( rijndael ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . xtea as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( xtea ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . cast5 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( cast5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . noekeon as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( noekeon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . skipjack as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( skipjack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . khazad as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( khazad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . anubis as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( anubis ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . kseed as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( kseed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . kasumi as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( kasumi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . multi2 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( multi2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . camellia as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( camellia ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Symmetric_key ) ) . data as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Symmetric_key ) , "::"
                , stringify ! ( data ) ));
}
impl Clone for Symmetric_key {
    fn clone(&self) -> Self { *self }
}
pub type symmetric_key = Symmetric_key;
/// A block cipher ECB structure
#[repr(C)]
#[derive(Copy)]
pub struct symmetric_ECB {
    /// The index of the cipher chosen
    pub cipher: ::std::os::raw::c_int,
    /// The block size of the given cipher
    pub blocklen: ::std::os::raw::c_int,
    /// The scheduled key
    pub key: symmetric_key,
}
#[test]
fn bindgen_test_layout_symmetric_ECB() {
    assert_eq!(::std::mem::size_of::<symmetric_ECB>() , 4264usize , concat ! (
               "Size of: " , stringify ! ( symmetric_ECB ) ));
    assert_eq! (::std::mem::align_of::<symmetric_ECB>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( symmetric_ECB ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_ECB ) ) . cipher as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_ECB ) , "::"
                , stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_ECB ) ) . blocklen as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_ECB ) , "::"
                , stringify ! ( blocklen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_ECB ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_ECB ) , "::"
                , stringify ! ( key ) ));
}
impl Clone for symmetric_ECB {
    fn clone(&self) -> Self { *self }
}
/// A block cipher CFB structure
#[repr(C)]
#[derive(Copy)]
pub struct symmetric_CFB {
    /// The index of the cipher chosen
    pub cipher: ::std::os::raw::c_int,
    /// The block size of the given cipher
    pub blocklen: ::std::os::raw::c_int,
    /// The padding offset
    pub padlen: ::std::os::raw::c_int,
    /// The current IV
    pub IV: [::std::os::raw::c_uchar; 128usize],
    /// The pad used to encrypt/decrypt
    pub pad: [::std::os::raw::c_uchar; 128usize],
    /// The scheduled key
    pub key: symmetric_key,
}
#[test]
fn bindgen_test_layout_symmetric_CFB() {
    assert_eq!(::std::mem::size_of::<symmetric_CFB>() , 4528usize , concat ! (
               "Size of: " , stringify ! ( symmetric_CFB ) ));
    assert_eq! (::std::mem::align_of::<symmetric_CFB>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( symmetric_CFB ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CFB ) ) . cipher as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CFB ) , "::"
                , stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CFB ) ) . blocklen as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CFB ) , "::"
                , stringify ! ( blocklen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CFB ) ) . padlen as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CFB ) , "::"
                , stringify ! ( padlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CFB ) ) . IV as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CFB ) , "::"
                , stringify ! ( IV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CFB ) ) . pad as * const _ as
                usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CFB ) , "::"
                , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CFB ) ) . key as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CFB ) , "::"
                , stringify ! ( key ) ));
}
impl Clone for symmetric_CFB {
    fn clone(&self) -> Self { *self }
}
/// A block cipher OFB structure
#[repr(C)]
#[derive(Copy)]
pub struct symmetric_OFB {
    /// The index of the cipher chosen
    pub cipher: ::std::os::raw::c_int,
    /// The block size of the given cipher
    pub blocklen: ::std::os::raw::c_int,
    /// The padding offset
    pub padlen: ::std::os::raw::c_int,
    /// The current IV
    pub IV: [::std::os::raw::c_uchar; 128usize],
    /// The scheduled key
    pub key: symmetric_key,
}
#[test]
fn bindgen_test_layout_symmetric_OFB() {
    assert_eq!(::std::mem::size_of::<symmetric_OFB>() , 4400usize , concat ! (
               "Size of: " , stringify ! ( symmetric_OFB ) ));
    assert_eq! (::std::mem::align_of::<symmetric_OFB>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( symmetric_OFB ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_OFB ) ) . cipher as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_OFB ) , "::"
                , stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_OFB ) ) . blocklen as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_OFB ) , "::"
                , stringify ! ( blocklen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_OFB ) ) . padlen as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_OFB ) , "::"
                , stringify ! ( padlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_OFB ) ) . IV as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_OFB ) , "::"
                , stringify ! ( IV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_OFB ) ) . key as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_OFB ) , "::"
                , stringify ! ( key ) ));
}
impl Clone for symmetric_OFB {
    fn clone(&self) -> Self { *self }
}
/// A block cipher CBC structure
#[repr(C)]
#[derive(Copy)]
pub struct symmetric_CBC {
    /// The index of the cipher chosen
    pub cipher: ::std::os::raw::c_int,
    /// The block size of the given cipher
    pub blocklen: ::std::os::raw::c_int,
    /// The current IV
    pub IV: [::std::os::raw::c_uchar; 128usize],
    /// The scheduled key
    pub key: symmetric_key,
}
#[test]
fn bindgen_test_layout_symmetric_CBC() {
    assert_eq!(::std::mem::size_of::<symmetric_CBC>() , 4392usize , concat ! (
               "Size of: " , stringify ! ( symmetric_CBC ) ));
    assert_eq! (::std::mem::align_of::<symmetric_CBC>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( symmetric_CBC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CBC ) ) . cipher as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CBC ) , "::"
                , stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CBC ) ) . blocklen as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CBC ) , "::"
                , stringify ! ( blocklen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CBC ) ) . IV as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CBC ) , "::"
                , stringify ! ( IV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CBC ) ) . key as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CBC ) , "::"
                , stringify ! ( key ) ));
}
impl Clone for symmetric_CBC {
    fn clone(&self) -> Self { *self }
}
/// A block cipher CTR structure
#[repr(C)]
#[derive(Copy)]
pub struct symmetric_CTR {
    /// The index of the cipher chosen
    pub cipher: ::std::os::raw::c_int,
    /// The block size of the given cipher
    pub blocklen: ::std::os::raw::c_int,
    /// The padding offset
    pub padlen: ::std::os::raw::c_int,
    /// The mode (endianess) of the CTR, 0==little, 1==big
    pub mode: ::std::os::raw::c_int,
    /// counter width
    pub ctrlen: ::std::os::raw::c_int,
    /// The counter
    pub ctr: [::std::os::raw::c_uchar; 128usize],
    /// The pad used to encrypt/decrypt
    pub pad: [::std::os::raw::c_uchar; 128usize],
    /// The scheduled key
    pub key: symmetric_key,
}
#[test]
fn bindgen_test_layout_symmetric_CTR() {
    assert_eq!(::std::mem::size_of::<symmetric_CTR>() , 4536usize , concat ! (
               "Size of: " , stringify ! ( symmetric_CTR ) ));
    assert_eq! (::std::mem::align_of::<symmetric_CTR>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( symmetric_CTR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CTR ) ) . cipher as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CTR ) , "::"
                , stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CTR ) ) . blocklen as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CTR ) , "::"
                , stringify ! ( blocklen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CTR ) ) . padlen as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CTR ) , "::"
                , stringify ! ( padlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CTR ) ) . mode as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CTR ) , "::"
                , stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CTR ) ) . ctrlen as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CTR ) , "::"
                , stringify ! ( ctrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CTR ) ) . ctr as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CTR ) , "::"
                , stringify ! ( ctr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CTR ) ) . pad as * const _ as
                usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CTR ) , "::"
                , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_CTR ) ) . key as * const _ as
                usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_CTR ) , "::"
                , stringify ! ( key ) ));
}
impl Clone for symmetric_CTR {
    fn clone(&self) -> Self { *self }
}
/// A LRW structure
#[repr(C)]
#[derive(Copy)]
pub struct symmetric_LRW {
    /// The index of the cipher chosen (must be a 128-bit block cipher)
    pub cipher: ::std::os::raw::c_int,
    /// The current IV
    pub IV: [::std::os::raw::c_uchar; 16usize],
    /// the tweak key
    pub tweak: [::std::os::raw::c_uchar; 16usize],
    /// The current pad, it's the product of the first 15 bytes against the tweak key
    pub pad: [::std::os::raw::c_uchar; 16usize],
    /// The scheduled symmetric key
    pub key: symmetric_key,
    /// The pre-computed multiplication table
    pub PC: [[[::std::os::raw::c_uchar; 16usize]; 256usize]; 16usize],
}
#[test]
fn bindgen_test_layout_symmetric_LRW() {
    assert_eq!(::std::mem::size_of::<symmetric_LRW>() , 69848usize , concat !
               ( "Size of: " , stringify ! ( symmetric_LRW ) ));
    assert_eq! (::std::mem::align_of::<symmetric_LRW>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( symmetric_LRW ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_LRW ) ) . cipher as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_LRW ) , "::"
                , stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_LRW ) ) . IV as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_LRW ) , "::"
                , stringify ! ( IV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_LRW ) ) . tweak as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_LRW ) , "::"
                , stringify ! ( tweak ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_LRW ) ) . pad as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_LRW ) , "::"
                , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_LRW ) ) . key as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_LRW ) , "::"
                , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_LRW ) ) . PC as * const _ as
                usize } , 4312usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_LRW ) , "::"
                , stringify ! ( PC ) ));
}
impl Clone for symmetric_LRW {
    fn clone(&self) -> Self { *self }
}
/// A block cipher F8 structure
#[repr(C)]
#[derive(Copy)]
pub struct symmetric_F8 {
    /// The index of the cipher chosen
    pub cipher: ::std::os::raw::c_int,
    /// The block size of the given cipher
    pub blocklen: ::std::os::raw::c_int,
    /// The padding offset
    pub padlen: ::std::os::raw::c_int,
    /// The current IV
    pub IV: [::std::os::raw::c_uchar; 128usize],
    /// The current IV
    pub MIV: [::std::os::raw::c_uchar; 128usize],
    /// Current block count
    pub blockcnt: ulong32,
    /// The scheduled key
    pub key: symmetric_key,
}
#[test]
fn bindgen_test_layout_symmetric_F8() {
    assert_eq!(::std::mem::size_of::<symmetric_F8>() , 4528usize , concat ! (
               "Size of: " , stringify ! ( symmetric_F8 ) ));
    assert_eq! (::std::mem::align_of::<symmetric_F8>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( symmetric_F8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_F8 ) ) . cipher as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_F8 ) , "::" ,
                stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_F8 ) ) . blocklen as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_F8 ) , "::" ,
                stringify ! ( blocklen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_F8 ) ) . padlen as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_F8 ) , "::" ,
                stringify ! ( padlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_F8 ) ) . IV as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_F8 ) , "::" ,
                stringify ! ( IV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_F8 ) ) . MIV as * const _ as
                usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_F8 ) , "::" ,
                stringify ! ( MIV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_F8 ) ) . blockcnt as * const _
                as usize } , 268usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_F8 ) , "::" ,
                stringify ! ( blockcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_F8 ) ) . key as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_F8 ) , "::" ,
                stringify ! ( key ) ));
}
impl Clone for symmetric_F8 {
    fn clone(&self) -> Self { *self }
}
/// cipher descriptor table, last entry has "name == NULL" to mark the end of table
#[repr(C)]
#[derive(Copy)]
pub struct ltc_cipher_descriptor {
    /// name of cipher
    pub name: *const ::std::os::raw::c_char,
    /// internal ID
    pub ID: ::std::os::raw::c_uchar,
    /// min keysize (octets)
    pub min_key_length: ::std::os::raw::c_int,
    /// max keysize (octets)
    pub max_key_length: ::std::os::raw::c_int,
    /// block size (octets)
    pub block_length: ::std::os::raw::c_int,
    /// default number of rounds
    pub default_rounds: ::std::os::raw::c_int,
    /// Setup the cipher
    /// @param key         The input symmetric key
    /// @param keylen      The length of the input key (octets)
    /// @param num_rounds  The requested number of rounds (0==default)
    /// @param skey        [out] The destination of the scheduled key
    /// @return CRYPT_OK if successful
    pub setup: ::std::option::Option<unsafe extern "C" fn(key:
                                                              *const ::std::os::raw::c_uchar,
                                                          keylen:
                                                              ::std::os::raw::c_int,
                                                          num_rounds:
                                                              ::std::os::raw::c_int,
                                                          skey:
                                                              *mut symmetric_key)
                                         -> ::std::os::raw::c_int>,
    /// Encrypt a block
    /// @param pt      The plaintext
    /// @param ct      [out] The ciphertext
    /// @param skey    The scheduled key
    /// @return CRYPT_OK if successful
    pub ecb_encrypt: ::std::option::Option<unsafe extern "C" fn(pt:
                                                                    *const ::std::os::raw::c_uchar,
                                                                ct:
                                                                    *mut ::std::os::raw::c_uchar,
                                                                skey:
                                                                    *mut symmetric_key)
                                               -> ::std::os::raw::c_int>,
    /// Decrypt a block
    /// @param ct      The ciphertext
    /// @param pt      [out] The plaintext
    /// @param skey    The scheduled key
    /// @return CRYPT_OK if successful
    pub ecb_decrypt: ::std::option::Option<unsafe extern "C" fn(ct:
                                                                    *const ::std::os::raw::c_uchar,
                                                                pt:
                                                                    *mut ::std::os::raw::c_uchar,
                                                                skey:
                                                                    *mut symmetric_key)
                                               -> ::std::os::raw::c_int>,
    /// Test the block cipher
    /// @return CRYPT_OK if successful, CRYPT_NOP if self-testing has been disabled
    pub test: ::std::option::Option<unsafe extern "C" fn()
                                        -> ::std::os::raw::c_int>,
    /// Terminate the context
    /// @param skey    The scheduled key
    pub done: ::std::option::Option<unsafe extern "C" fn(skey:
                                                             *mut symmetric_key)>,
    /// Determine a key size
    /// @param keysize    [in/out] The size of the key desired and the suggested size
    /// @return CRYPT_OK if successful
    pub keysize: ::std::option::Option<unsafe extern "C" fn(keysize:
                                                                *mut ::std::os::raw::c_int)
                                           -> ::std::os::raw::c_int>,
    /// Accelerators **/
    /// /** Accelerated ECB encryption
    /// @param pt      Plaintext
    /// @param ct      Ciphertext
    /// @param blocks  The number of complete blocks to process
    /// @param skey    The scheduled key context
    /// @return CRYPT_OK if successful
    pub accel_ecb_encrypt: ::std::option::Option<unsafe extern "C" fn(pt:
                                                                          *const ::std::os::raw::c_uchar,
                                                                      ct:
                                                                          *mut ::std::os::raw::c_uchar,
                                                                      blocks:
                                                                          ::std::os::raw::c_ulong,
                                                                      skey:
                                                                          *mut symmetric_key)
                                                     ->
                                                         ::std::os::raw::c_int>,
    /// Accelerated ECB decryption
    /// @param pt      Plaintext
    /// @param ct      Ciphertext
    /// @param blocks  The number of complete blocks to process
    /// @param skey    The scheduled key context
    /// @return CRYPT_OK if successful
    pub accel_ecb_decrypt: ::std::option::Option<unsafe extern "C" fn(ct:
                                                                          *const ::std::os::raw::c_uchar,
                                                                      pt:
                                                                          *mut ::std::os::raw::c_uchar,
                                                                      blocks:
                                                                          ::std::os::raw::c_ulong,
                                                                      skey:
                                                                          *mut symmetric_key)
                                                     ->
                                                         ::std::os::raw::c_int>,
    /// Accelerated CBC encryption
    /// @param pt      Plaintext
    /// @param ct      Ciphertext
    /// @param blocks  The number of complete blocks to process
    /// @param IV      The initial value (input/output)
    /// @param skey    The scheduled key context
    /// @return CRYPT_OK if successful
    pub accel_cbc_encrypt: ::std::option::Option<unsafe extern "C" fn(pt:
                                                                          *const ::std::os::raw::c_uchar,
                                                                      ct:
                                                                          *mut ::std::os::raw::c_uchar,
                                                                      blocks:
                                                                          ::std::os::raw::c_ulong,
                                                                      IV:
                                                                          *mut ::std::os::raw::c_uchar,
                                                                      skey:
                                                                          *mut symmetric_key)
                                                     ->
                                                         ::std::os::raw::c_int>,
    /// Accelerated CBC decryption
    /// @param pt      Plaintext
    /// @param ct      Ciphertext
    /// @param blocks  The number of complete blocks to process
    /// @param IV      The initial value (input/output)
    /// @param skey    The scheduled key context
    /// @return CRYPT_OK if successful
    pub accel_cbc_decrypt: ::std::option::Option<unsafe extern "C" fn(ct:
                                                                          *const ::std::os::raw::c_uchar,
                                                                      pt:
                                                                          *mut ::std::os::raw::c_uchar,
                                                                      blocks:
                                                                          ::std::os::raw::c_ulong,
                                                                      IV:
                                                                          *mut ::std::os::raw::c_uchar,
                                                                      skey:
                                                                          *mut symmetric_key)
                                                     ->
                                                         ::std::os::raw::c_int>,
    /// Accelerated CTR encryption
    /// @param pt      Plaintext
    /// @param ct      Ciphertext
    /// @param blocks  The number of complete blocks to process
    /// @param IV      The initial value (input/output)
    /// @param mode    little or big endian counter (mode=0 or mode=1)
    /// @param skey    The scheduled key context
    /// @return CRYPT_OK if successful
    pub accel_ctr_encrypt: ::std::option::Option<unsafe extern "C" fn(pt:
                                                                          *const ::std::os::raw::c_uchar,
                                                                      ct:
                                                                          *mut ::std::os::raw::c_uchar,
                                                                      blocks:
                                                                          ::std::os::raw::c_ulong,
                                                                      IV:
                                                                          *mut ::std::os::raw::c_uchar,
                                                                      mode:
                                                                          ::std::os::raw::c_int,
                                                                      skey:
                                                                          *mut symmetric_key)
                                                     ->
                                                         ::std::os::raw::c_int>,
    /// Accelerated LRW
    /// @param pt      Plaintext
    /// @param ct      Ciphertext
    /// @param blocks  The number of complete blocks to process
    /// @param IV      The initial value (input/output)
    /// @param tweak   The LRW tweak
    /// @param skey    The scheduled key context
    /// @return CRYPT_OK if successful
    pub accel_lrw_encrypt: ::std::option::Option<unsafe extern "C" fn(pt:
                                                                          *const ::std::os::raw::c_uchar,
                                                                      ct:
                                                                          *mut ::std::os::raw::c_uchar,
                                                                      blocks:
                                                                          ::std::os::raw::c_ulong,
                                                                      IV:
                                                                          *mut ::std::os::raw::c_uchar,
                                                                      tweak:
                                                                          *const ::std::os::raw::c_uchar,
                                                                      skey:
                                                                          *mut symmetric_key)
                                                     ->
                                                         ::std::os::raw::c_int>,
    /// Accelerated LRW
    /// @param ct      Ciphertext
    /// @param pt      Plaintext
    /// @param blocks  The number of complete blocks to process
    /// @param IV      The initial value (input/output)
    /// @param tweak   The LRW tweak
    /// @param skey    The scheduled key context
    /// @return CRYPT_OK if successful
    pub accel_lrw_decrypt: ::std::option::Option<unsafe extern "C" fn(ct:
                                                                          *const ::std::os::raw::c_uchar,
                                                                      pt:
                                                                          *mut ::std::os::raw::c_uchar,
                                                                      blocks:
                                                                          ::std::os::raw::c_ulong,
                                                                      IV:
                                                                          *mut ::std::os::raw::c_uchar,
                                                                      tweak:
                                                                          *const ::std::os::raw::c_uchar,
                                                                      skey:
                                                                          *mut symmetric_key)
                                                     ->
                                                         ::std::os::raw::c_int>,
    /// Accelerated CCM packet (one-shot)
    /// @param key        The secret key to use
    /// @param keylen     The length of the secret key (octets)
    /// @param uskey      A previously scheduled key [optional can be NULL]
    /// @param nonce      The session nonce [use once]
    /// @param noncelen   The length of the nonce
    /// @param header     The header for the session
    /// @param headerlen  The length of the header (octets)
    /// @param pt         [out] The plaintext
    /// @param ptlen      The length of the plaintext (octets)
    /// @param ct         [out] The ciphertext
    /// @param tag        [out] The destination tag
    /// @param taglen     [in/out] The max size and resulting size of the authentication tag
    /// @param direction  Encrypt or Decrypt direction (0 or 1)
    /// @return CRYPT_OK if successful
    pub accel_ccm_memory: ::std::option::Option<unsafe extern "C" fn(key:
                                                                         *const ::std::os::raw::c_uchar,
                                                                     keylen:
                                                                         ::std::os::raw::c_ulong,
                                                                     uskey:
                                                                         *mut symmetric_key,
                                                                     nonce:
                                                                         *const ::std::os::raw::c_uchar,
                                                                     noncelen:
                                                                         ::std::os::raw::c_ulong,
                                                                     header:
                                                                         *const ::std::os::raw::c_uchar,
                                                                     headerlen:
                                                                         ::std::os::raw::c_ulong,
                                                                     pt:
                                                                         *mut ::std::os::raw::c_uchar,
                                                                     ptlen:
                                                                         ::std::os::raw::c_ulong,
                                                                     ct:
                                                                         *mut ::std::os::raw::c_uchar,
                                                                     tag:
                                                                         *mut ::std::os::raw::c_uchar,
                                                                     taglen:
                                                                         *mut ::std::os::raw::c_ulong,
                                                                     direction:
                                                                         ::std::os::raw::c_int)
                                                    -> ::std::os::raw::c_int>,
    /// Accelerated GCM packet (one shot)
    /// @param key        The secret key
    /// @param keylen     The length of the secret key
    /// @param IV         The initialization vector
    /// @param IVlen      The length of the initialization vector
    /// @param adata      The additional authentication data (header)
    /// @param adatalen   The length of the adata
    /// @param pt         The plaintext
    /// @param ptlen      The length of the plaintext (ciphertext length is the same)
    /// @param ct         The ciphertext
    /// @param tag        [out] The MAC tag
    /// @param taglen     [in/out] The MAC tag length
    /// @param direction  Encrypt or Decrypt mode (GCM_ENCRYPT or GCM_DECRYPT)
    /// @return CRYPT_OK on success
    pub accel_gcm_memory: ::std::option::Option<unsafe extern "C" fn(key:
                                                                         *const ::std::os::raw::c_uchar,
                                                                     keylen:
                                                                         ::std::os::raw::c_ulong,
                                                                     IV:
                                                                         *const ::std::os::raw::c_uchar,
                                                                     IVlen:
                                                                         ::std::os::raw::c_ulong,
                                                                     adata:
                                                                         *const ::std::os::raw::c_uchar,
                                                                     adatalen:
                                                                         ::std::os::raw::c_ulong,
                                                                     pt:
                                                                         *mut ::std::os::raw::c_uchar,
                                                                     ptlen:
                                                                         ::std::os::raw::c_ulong,
                                                                     ct:
                                                                         *mut ::std::os::raw::c_uchar,
                                                                     tag:
                                                                         *mut ::std::os::raw::c_uchar,
                                                                     taglen:
                                                                         *mut ::std::os::raw::c_ulong,
                                                                     direction:
                                                                         ::std::os::raw::c_int)
                                                    -> ::std::os::raw::c_int>,
    /// Accelerated one shot LTC_OMAC
    /// @param key            The secret key
    /// @param keylen         The key length (octets)
    /// @param in             The message
    /// @param inlen          Length of message (octets)
    /// @param out            [out] Destination for tag
    /// @param outlen         [in/out] Initial and final size of out
    /// @return CRYPT_OK on success
    pub omac_memory: ::std::option::Option<unsafe extern "C" fn(key:
                                                                    *const ::std::os::raw::c_uchar,
                                                                keylen:
                                                                    ::std::os::raw::c_ulong,
                                                                in_:
                                                                    *const ::std::os::raw::c_uchar,
                                                                inlen:
                                                                    ::std::os::raw::c_ulong,
                                                                out:
                                                                    *mut ::std::os::raw::c_uchar,
                                                                outlen:
                                                                    *mut ::std::os::raw::c_ulong)
                                               -> ::std::os::raw::c_int>,
    /// Accelerated one shot XCBC
    /// @param key            The secret key
    /// @param keylen         The key length (octets)
    /// @param in             The message
    /// @param inlen          Length of message (octets)
    /// @param out            [out] Destination for tag
    /// @param outlen         [in/out] Initial and final size of out
    /// @return CRYPT_OK on success
    pub xcbc_memory: ::std::option::Option<unsafe extern "C" fn(key:
                                                                    *const ::std::os::raw::c_uchar,
                                                                keylen:
                                                                    ::std::os::raw::c_ulong,
                                                                in_:
                                                                    *const ::std::os::raw::c_uchar,
                                                                inlen:
                                                                    ::std::os::raw::c_ulong,
                                                                out:
                                                                    *mut ::std::os::raw::c_uchar,
                                                                outlen:
                                                                    *mut ::std::os::raw::c_ulong)
                                               -> ::std::os::raw::c_int>,
    /// Accelerated one shot F9
    /// @param key            The secret key
    /// @param keylen         The key length (octets)
    /// @param in             The message
    /// @param inlen          Length of message (octets)
    /// @param out            [out] Destination for tag
    /// @param outlen         [in/out] Initial and final size of out
    /// @return CRYPT_OK on success
    /// @remark Requires manual padding
    pub f9_memory: ::std::option::Option<unsafe extern "C" fn(key:
                                                                  *const ::std::os::raw::c_uchar,
                                                              keylen:
                                                                  ::std::os::raw::c_ulong,
                                                              in_:
                                                                  *const ::std::os::raw::c_uchar,
                                                              inlen:
                                                                  ::std::os::raw::c_ulong,
                                                              out:
                                                                  *mut ::std::os::raw::c_uchar,
                                                              outlen:
                                                                  *mut ::std::os::raw::c_ulong)
                                             -> ::std::os::raw::c_int>,
    /// Accelerated XTS encryption
    /// @param pt      Plaintext
    /// @param ct      Ciphertext
    /// @param blocks  The number of complete blocks to process
    /// @param tweak   The 128-bit encryption tweak (input/output).
    /// The tweak should not be encrypted on input, but
    /// next tweak will be copied encrypted on output.
    /// @param skey1   The first scheduled key context
    /// @param skey2   The second scheduled key context
    /// @return CRYPT_OK if successful
    pub accel_xts_encrypt: ::std::option::Option<unsafe extern "C" fn(pt:
                                                                          *const ::std::os::raw::c_uchar,
                                                                      ct:
                                                                          *mut ::std::os::raw::c_uchar,
                                                                      blocks:
                                                                          ::std::os::raw::c_ulong,
                                                                      tweak:
                                                                          *mut ::std::os::raw::c_uchar,
                                                                      skey1:
                                                                          *mut symmetric_key,
                                                                      skey2:
                                                                          *mut symmetric_key)
                                                     ->
                                                         ::std::os::raw::c_int>,
    /// Accelerated XTS decryption
    /// @param ct      Ciphertext
    /// @param pt      Plaintext
    /// @param blocks  The number of complete blocks to process
    /// @param tweak   The 128-bit encryption tweak (input/output).
    /// The tweak should not be encrypted on input, but
    /// next tweak will be copied encrypted on output.
    /// @param skey1   The first scheduled key context
    /// @param skey2   The second scheduled key context
    /// @return CRYPT_OK if successful
    pub accel_xts_decrypt: ::std::option::Option<unsafe extern "C" fn(ct:
                                                                          *const ::std::os::raw::c_uchar,
                                                                      pt:
                                                                          *mut ::std::os::raw::c_uchar,
                                                                      blocks:
                                                                          ::std::os::raw::c_ulong,
                                                                      tweak:
                                                                          *mut ::std::os::raw::c_uchar,
                                                                      skey1:
                                                                          *mut symmetric_key,
                                                                      skey2:
                                                                          *mut symmetric_key)
                                                     ->
                                                         ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_ltc_cipher_descriptor() {
    assert_eq!(::std::mem::size_of::<ltc_cipher_descriptor>() , 192usize ,
               concat ! ( "Size of: " , stringify ! ( ltc_cipher_descriptor )
               ));
    assert_eq! (::std::mem::align_of::<ltc_cipher_descriptor>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ltc_cipher_descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) . ID as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( ID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) .
                min_key_length as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( min_key_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) .
                max_key_length as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( max_key_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) . block_length
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( block_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) .
                default_rounds as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( default_rounds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) . setup as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( setup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) . ecb_encrypt
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( ecb_encrypt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) . ecb_decrypt
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( ecb_decrypt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) . test as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( test ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) . done as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) . keysize as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( keysize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) .
                accel_ecb_encrypt as * const _ as usize } , 80usize , concat !
                (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( accel_ecb_encrypt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) .
                accel_ecb_decrypt as * const _ as usize } , 88usize , concat !
                (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( accel_ecb_decrypt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) .
                accel_cbc_encrypt as * const _ as usize } , 96usize , concat !
                (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( accel_cbc_encrypt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) .
                accel_cbc_decrypt as * const _ as usize } , 104usize , concat
                ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( accel_cbc_decrypt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) .
                accel_ctr_encrypt as * const _ as usize } , 112usize , concat
                ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( accel_ctr_encrypt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) .
                accel_lrw_encrypt as * const _ as usize } , 120usize , concat
                ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( accel_lrw_encrypt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) .
                accel_lrw_decrypt as * const _ as usize } , 128usize , concat
                ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( accel_lrw_decrypt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) .
                accel_ccm_memory as * const _ as usize } , 136usize , concat !
                (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( accel_ccm_memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) .
                accel_gcm_memory as * const _ as usize } , 144usize , concat !
                (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( accel_gcm_memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) . omac_memory
                as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( omac_memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) . xcbc_memory
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( xcbc_memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) . f9_memory as
                * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( f9_memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) .
                accel_xts_encrypt as * const _ as usize } , 176usize , concat
                ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( accel_xts_encrypt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_cipher_descriptor ) ) .
                accel_xts_decrypt as * const _ as usize } , 184usize , concat
                ! (
                "Alignment of field: " , stringify ! ( ltc_cipher_descriptor )
                , "::" , stringify ! ( accel_xts_decrypt ) ));
}
impl Clone for ltc_cipher_descriptor {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "cipher_descriptor"]
    pub static mut cipher_descriptor: [ltc_cipher_descriptor; 0usize];
}
extern "C" {
    pub fn blowfish_setup(key: *const ::std::os::raw::c_uchar,
                          keylen: ::std::os::raw::c_int,
                          num_rounds: ::std::os::raw::c_int,
                          skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blowfish_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                                ct: *mut ::std::os::raw::c_uchar,
                                skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blowfish_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                                pt: *mut ::std::os::raw::c_uchar,
                                skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blowfish_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blowfish_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn blowfish_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "blowfish_desc"]
    pub static blowfish_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn rc5_setup(key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_int,
                     num_rounds: ::std::os::raw::c_int,
                     skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc5_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                           ct: *mut ::std::os::raw::c_uchar,
                           skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc5_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                           pt: *mut ::std::os::raw::c_uchar,
                           skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc5_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc5_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn rc5_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "rc5_desc"]
    pub static rc5_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn rc6_setup(key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_int,
                     num_rounds: ::std::os::raw::c_int,
                     skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc6_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                           ct: *mut ::std::os::raw::c_uchar,
                           skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc6_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                           pt: *mut ::std::os::raw::c_uchar,
                           skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc6_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc6_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn rc6_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "rc6_desc"]
    pub static rc6_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn rc2_setup(key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_int,
                     num_rounds: ::std::os::raw::c_int,
                     skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc2_setup_ex(key: *const ::std::os::raw::c_uchar,
                        keylen: ::std::os::raw::c_int,
                        bits: ::std::os::raw::c_int,
                        num_rounds: ::std::os::raw::c_int,
                        skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc2_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                           ct: *mut ::std::os::raw::c_uchar,
                           skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc2_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                           pt: *mut ::std::os::raw::c_uchar,
                           skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc2_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc2_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn rc2_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "rc2_desc"]
    pub static rc2_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn saferp_setup(key: *const ::std::os::raw::c_uchar,
                        keylen: ::std::os::raw::c_int,
                        num_rounds: ::std::os::raw::c_int,
                        skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn saferp_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                              ct: *mut ::std::os::raw::c_uchar,
                              skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn saferp_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                              pt: *mut ::std::os::raw::c_uchar,
                              skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn saferp_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn saferp_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn saferp_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "saferp_desc"]
    pub static saferp_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn safer_k64_setup(key: *const ::std::os::raw::c_uchar,
                           keylen: ::std::os::raw::c_int,
                           num_rounds: ::std::os::raw::c_int,
                           skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn safer_sk64_setup(key: *const ::std::os::raw::c_uchar,
                            keylen: ::std::os::raw::c_int,
                            num_rounds: ::std::os::raw::c_int,
                            skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn safer_k128_setup(key: *const ::std::os::raw::c_uchar,
                            keylen: ::std::os::raw::c_int,
                            num_rounds: ::std::os::raw::c_int,
                            skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn safer_sk128_setup(key: *const ::std::os::raw::c_uchar,
                             keylen: ::std::os::raw::c_int,
                             num_rounds: ::std::os::raw::c_int,
                             skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn safer_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                             ct: *mut ::std::os::raw::c_uchar,
                             key: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn safer_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                             pt: *mut ::std::os::raw::c_uchar,
                             key: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn safer_k64_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn safer_sk64_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn safer_sk128_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn safer_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn safer_64_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn safer_128_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "safer_k64_desc"]
    pub static safer_k64_desc: ltc_cipher_descriptor;
}
extern "C" {
    #[link_name = "safer_k128_desc"]
    pub static safer_k128_desc: ltc_cipher_descriptor;
}
extern "C" {
    #[link_name = "safer_sk64_desc"]
    pub static safer_sk64_desc: ltc_cipher_descriptor;
}
extern "C" {
    #[link_name = "safer_sk128_desc"]
    pub static safer_sk128_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn rijndael_setup(key: *const ::std::os::raw::c_uchar,
                          keylen: ::std::os::raw::c_int,
                          num_rounds: ::std::os::raw::c_int,
                          skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rijndael_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                                ct: *mut ::std::os::raw::c_uchar,
                                skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rijndael_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                                pt: *mut ::std::os::raw::c_uchar,
                                skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rijndael_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rijndael_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn rijndael_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rijndael_enc_setup(key: *const ::std::os::raw::c_uchar,
                              keylen: ::std::os::raw::c_int,
                              num_rounds: ::std::os::raw::c_int,
                              skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rijndael_enc_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                                    ct: *mut ::std::os::raw::c_uchar,
                                    skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rijndael_enc_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn rijndael_enc_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "rijndael_desc"]
    pub static rijndael_desc: ltc_cipher_descriptor;
}
extern "C" {
    #[link_name = "aes_desc"]
    pub static aes_desc: ltc_cipher_descriptor;
}
extern "C" {
    #[link_name = "rijndael_enc_desc"]
    pub static rijndael_enc_desc: ltc_cipher_descriptor;
}
extern "C" {
    #[link_name = "aes_enc_desc"]
    pub static aes_enc_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn xtea_setup(key: *const ::std::os::raw::c_uchar,
                      keylen: ::std::os::raw::c_int,
                      num_rounds: ::std::os::raw::c_int,
                      skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xtea_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                            ct: *mut ::std::os::raw::c_uchar,
                            skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xtea_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                            pt: *mut ::std::os::raw::c_uchar,
                            skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xtea_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xtea_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn xtea_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "xtea_desc"]
    pub static xtea_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn twofish_setup(key: *const ::std::os::raw::c_uchar,
                         keylen: ::std::os::raw::c_int,
                         num_rounds: ::std::os::raw::c_int,
                         skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn twofish_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                               ct: *mut ::std::os::raw::c_uchar,
                               skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn twofish_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                               pt: *mut ::std::os::raw::c_uchar,
                               skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn twofish_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn twofish_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn twofish_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "twofish_desc"]
    pub static twofish_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn des_setup(key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_int,
                     num_rounds: ::std::os::raw::c_int,
                     skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn des_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                           ct: *mut ::std::os::raw::c_uchar,
                           skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn des_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                           pt: *mut ::std::os::raw::c_uchar,
                           skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn des_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn des_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn des_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn des3_setup(key: *const ::std::os::raw::c_uchar,
                      keylen: ::std::os::raw::c_int,
                      num_rounds: ::std::os::raw::c_int,
                      skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn des3_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                            ct: *mut ::std::os::raw::c_uchar,
                            skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn des3_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                            pt: *mut ::std::os::raw::c_uchar,
                            skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn des3_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn des3_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn des3_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "des_desc"]
    pub static des_desc: ltc_cipher_descriptor;
}
extern "C" {
    #[link_name = "des3_desc"]
    pub static des3_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn cast5_setup(key: *const ::std::os::raw::c_uchar,
                       keylen: ::std::os::raw::c_int,
                       num_rounds: ::std::os::raw::c_int,
                       skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cast5_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                             ct: *mut ::std::os::raw::c_uchar,
                             skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cast5_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                             pt: *mut ::std::os::raw::c_uchar,
                             skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cast5_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cast5_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn cast5_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "cast5_desc"]
    pub static cast5_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn noekeon_setup(key: *const ::std::os::raw::c_uchar,
                         keylen: ::std::os::raw::c_int,
                         num_rounds: ::std::os::raw::c_int,
                         skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn noekeon_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                               ct: *mut ::std::os::raw::c_uchar,
                               skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn noekeon_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                               pt: *mut ::std::os::raw::c_uchar,
                               skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn noekeon_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn noekeon_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn noekeon_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "noekeon_desc"]
    pub static noekeon_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn skipjack_setup(key: *const ::std::os::raw::c_uchar,
                          keylen: ::std::os::raw::c_int,
                          num_rounds: ::std::os::raw::c_int,
                          skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn skipjack_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                                ct: *mut ::std::os::raw::c_uchar,
                                skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn skipjack_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                                pt: *mut ::std::os::raw::c_uchar,
                                skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn skipjack_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn skipjack_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn skipjack_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "skipjack_desc"]
    pub static skipjack_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn khazad_setup(key: *const ::std::os::raw::c_uchar,
                        keylen: ::std::os::raw::c_int,
                        num_rounds: ::std::os::raw::c_int,
                        skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn khazad_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                              ct: *mut ::std::os::raw::c_uchar,
                              skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn khazad_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                              pt: *mut ::std::os::raw::c_uchar,
                              skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn khazad_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn khazad_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn khazad_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "khazad_desc"]
    pub static khazad_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn anubis_setup(key: *const ::std::os::raw::c_uchar,
                        keylen: ::std::os::raw::c_int,
                        num_rounds: ::std::os::raw::c_int,
                        skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn anubis_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                              ct: *mut ::std::os::raw::c_uchar,
                              skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn anubis_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                              pt: *mut ::std::os::raw::c_uchar,
                              skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn anubis_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn anubis_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn anubis_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "anubis_desc"]
    pub static anubis_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn kseed_setup(key: *const ::std::os::raw::c_uchar,
                       keylen: ::std::os::raw::c_int,
                       num_rounds: ::std::os::raw::c_int,
                       skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kseed_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                             ct: *mut ::std::os::raw::c_uchar,
                             skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kseed_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                             pt: *mut ::std::os::raw::c_uchar,
                             skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kseed_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kseed_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn kseed_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "kseed_desc"]
    pub static kseed_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn kasumi_setup(key: *const ::std::os::raw::c_uchar,
                        keylen: ::std::os::raw::c_int,
                        num_rounds: ::std::os::raw::c_int,
                        skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kasumi_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                              ct: *mut ::std::os::raw::c_uchar,
                              skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kasumi_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                              pt: *mut ::std::os::raw::c_uchar,
                              skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kasumi_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kasumi_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn kasumi_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "kasumi_desc"]
    pub static kasumi_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn multi2_setup(key: *const ::std::os::raw::c_uchar,
                        keylen: ::std::os::raw::c_int,
                        num_rounds: ::std::os::raw::c_int,
                        skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn multi2_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                              ct: *mut ::std::os::raw::c_uchar,
                              skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn multi2_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                              pt: *mut ::std::os::raw::c_uchar,
                              skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn multi2_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn multi2_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn multi2_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "multi2_desc"]
    pub static multi2_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn camellia_setup(key: *const ::std::os::raw::c_uchar,
                          keylen: ::std::os::raw::c_int,
                          num_rounds: ::std::os::raw::c_int,
                          skey: *mut symmetric_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn camellia_ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                                ct: *mut ::std::os::raw::c_uchar,
                                skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn camellia_ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                                pt: *mut ::std::os::raw::c_uchar,
                                skey: *mut symmetric_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn camellia_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn camellia_done(skey: *mut symmetric_key);
}
extern "C" {
    pub fn camellia_keysize(keysize: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "camellia_desc"]
    pub static camellia_desc: ltc_cipher_descriptor;
}
extern "C" {
    pub fn ecb_start(cipher: ::std::os::raw::c_int,
                     key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_int,
                     num_rounds: ::std::os::raw::c_int,
                     ecb: *mut symmetric_ECB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecb_encrypt(pt: *const ::std::os::raw::c_uchar,
                       ct: *mut ::std::os::raw::c_uchar,
                       len: ::std::os::raw::c_ulong, ecb: *mut symmetric_ECB)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecb_decrypt(ct: *const ::std::os::raw::c_uchar,
                       pt: *mut ::std::os::raw::c_uchar,
                       len: ::std::os::raw::c_ulong, ecb: *mut symmetric_ECB)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecb_done(ecb: *mut symmetric_ECB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfb_start(cipher: ::std::os::raw::c_int,
                     IV: *const ::std::os::raw::c_uchar,
                     key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_int,
                     num_rounds: ::std::os::raw::c_int,
                     cfb: *mut symmetric_CFB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfb_encrypt(pt: *const ::std::os::raw::c_uchar,
                       ct: *mut ::std::os::raw::c_uchar,
                       len: ::std::os::raw::c_ulong, cfb: *mut symmetric_CFB)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfb_decrypt(ct: *const ::std::os::raw::c_uchar,
                       pt: *mut ::std::os::raw::c_uchar,
                       len: ::std::os::raw::c_ulong, cfb: *mut symmetric_CFB)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfb_getiv(IV: *mut ::std::os::raw::c_uchar,
                     len: *mut ::std::os::raw::c_ulong,
                     cfb: *mut symmetric_CFB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfb_setiv(IV: *const ::std::os::raw::c_uchar,
                     len: ::std::os::raw::c_ulong, cfb: *mut symmetric_CFB)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfb_done(cfb: *mut symmetric_CFB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ofb_start(cipher: ::std::os::raw::c_int,
                     IV: *const ::std::os::raw::c_uchar,
                     key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_int,
                     num_rounds: ::std::os::raw::c_int,
                     ofb: *mut symmetric_OFB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ofb_encrypt(pt: *const ::std::os::raw::c_uchar,
                       ct: *mut ::std::os::raw::c_uchar,
                       len: ::std::os::raw::c_ulong, ofb: *mut symmetric_OFB)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ofb_decrypt(ct: *const ::std::os::raw::c_uchar,
                       pt: *mut ::std::os::raw::c_uchar,
                       len: ::std::os::raw::c_ulong, ofb: *mut symmetric_OFB)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ofb_getiv(IV: *mut ::std::os::raw::c_uchar,
                     len: *mut ::std::os::raw::c_ulong,
                     ofb: *mut symmetric_OFB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ofb_setiv(IV: *const ::std::os::raw::c_uchar,
                     len: ::std::os::raw::c_ulong, ofb: *mut symmetric_OFB)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ofb_done(ofb: *mut symmetric_OFB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cbc_start(cipher: ::std::os::raw::c_int,
                     IV: *const ::std::os::raw::c_uchar,
                     key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_int,
                     num_rounds: ::std::os::raw::c_int,
                     cbc: *mut symmetric_CBC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cbc_encrypt(pt: *const ::std::os::raw::c_uchar,
                       ct: *mut ::std::os::raw::c_uchar,
                       len: ::std::os::raw::c_ulong, cbc: *mut symmetric_CBC)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cbc_decrypt(ct: *const ::std::os::raw::c_uchar,
                       pt: *mut ::std::os::raw::c_uchar,
                       len: ::std::os::raw::c_ulong, cbc: *mut symmetric_CBC)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cbc_getiv(IV: *mut ::std::os::raw::c_uchar,
                     len: *mut ::std::os::raw::c_ulong,
                     cbc: *mut symmetric_CBC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cbc_setiv(IV: *const ::std::os::raw::c_uchar,
                     len: ::std::os::raw::c_ulong, cbc: *mut symmetric_CBC)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cbc_done(cbc: *mut symmetric_CBC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctr_start(cipher: ::std::os::raw::c_int,
                     IV: *const ::std::os::raw::c_uchar,
                     key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_int,
                     num_rounds: ::std::os::raw::c_int,
                     ctr_mode: ::std::os::raw::c_int, ctr: *mut symmetric_CTR)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctr_encrypt(pt: *const ::std::os::raw::c_uchar,
                       ct: *mut ::std::os::raw::c_uchar,
                       len: ::std::os::raw::c_ulong, ctr: *mut symmetric_CTR)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctr_decrypt(ct: *const ::std::os::raw::c_uchar,
                       pt: *mut ::std::os::raw::c_uchar,
                       len: ::std::os::raw::c_ulong, ctr: *mut symmetric_CTR)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctr_getiv(IV: *mut ::std::os::raw::c_uchar,
                     len: *mut ::std::os::raw::c_ulong,
                     ctr: *mut symmetric_CTR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctr_setiv(IV: *const ::std::os::raw::c_uchar,
                     len: ::std::os::raw::c_ulong, ctr: *mut symmetric_CTR)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctr_done(ctr: *mut symmetric_CTR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctr_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrw_start(cipher: ::std::os::raw::c_int,
                     IV: *const ::std::os::raw::c_uchar,
                     key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_int,
                     tweak: *const ::std::os::raw::c_uchar,
                     num_rounds: ::std::os::raw::c_int,
                     lrw: *mut symmetric_LRW) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrw_encrypt(pt: *const ::std::os::raw::c_uchar,
                       ct: *mut ::std::os::raw::c_uchar,
                       len: ::std::os::raw::c_ulong, lrw: *mut symmetric_LRW)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrw_decrypt(ct: *const ::std::os::raw::c_uchar,
                       pt: *mut ::std::os::raw::c_uchar,
                       len: ::std::os::raw::c_ulong, lrw: *mut symmetric_LRW)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrw_getiv(IV: *mut ::std::os::raw::c_uchar,
                     len: *mut ::std::os::raw::c_ulong,
                     lrw: *mut symmetric_LRW) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrw_setiv(IV: *const ::std::os::raw::c_uchar,
                     len: ::std::os::raw::c_ulong, lrw: *mut symmetric_LRW)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrw_done(lrw: *mut symmetric_LRW) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrw_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrw_process(pt: *const ::std::os::raw::c_uchar,
                       ct: *mut ::std::os::raw::c_uchar,
                       len: ::std::os::raw::c_ulong,
                       mode: ::std::os::raw::c_int, lrw: *mut symmetric_LRW)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn f8_start(cipher: ::std::os::raw::c_int,
                    IV: *const ::std::os::raw::c_uchar,
                    key: *const ::std::os::raw::c_uchar,
                    keylen: ::std::os::raw::c_int,
                    salt_key: *const ::std::os::raw::c_uchar,
                    skeylen: ::std::os::raw::c_int,
                    num_rounds: ::std::os::raw::c_int, f8: *mut symmetric_F8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn f8_encrypt(pt: *const ::std::os::raw::c_uchar,
                      ct: *mut ::std::os::raw::c_uchar,
                      len: ::std::os::raw::c_ulong, f8: *mut symmetric_F8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn f8_decrypt(ct: *const ::std::os::raw::c_uchar,
                      pt: *mut ::std::os::raw::c_uchar,
                      len: ::std::os::raw::c_ulong, f8: *mut symmetric_F8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn f8_getiv(IV: *mut ::std::os::raw::c_uchar,
                    len: *mut ::std::os::raw::c_ulong, f8: *mut symmetric_F8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn f8_setiv(IV: *const ::std::os::raw::c_uchar,
                    len: ::std::os::raw::c_ulong, f8: *mut symmetric_F8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn f8_done(f8: *mut symmetric_F8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn f8_test_mode() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct symmetric_xts {
    pub key1: symmetric_key,
    pub key2: symmetric_key,
    pub cipher: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_symmetric_xts() {
    assert_eq!(::std::mem::size_of::<symmetric_xts>() , 8520usize , concat ! (
               "Size of: " , stringify ! ( symmetric_xts ) ));
    assert_eq! (::std::mem::align_of::<symmetric_xts>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( symmetric_xts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_xts ) ) . key1 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_xts ) , "::"
                , stringify ! ( key1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_xts ) ) . key2 as * const _ as
                usize } , 4256usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_xts ) , "::"
                , stringify ! ( key2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symmetric_xts ) ) . cipher as * const _
                as usize } , 8512usize , concat ! (
                "Alignment of field: " , stringify ! ( symmetric_xts ) , "::"
                , stringify ! ( cipher ) ));
}
impl Clone for symmetric_xts {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn xts_start(cipher: ::std::os::raw::c_int,
                     key1: *const ::std::os::raw::c_uchar,
                     key2: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_ulong,
                     num_rounds: ::std::os::raw::c_int,
                     xts: *mut symmetric_xts) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xts_encrypt(pt: *const ::std::os::raw::c_uchar,
                       ptlen: ::std::os::raw::c_ulong,
                       ct: *mut ::std::os::raw::c_uchar,
                       tweak: *mut ::std::os::raw::c_uchar,
                       xts: *mut symmetric_xts) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xts_decrypt(ct: *const ::std::os::raw::c_uchar,
                       ptlen: ::std::os::raw::c_ulong,
                       pt: *mut ::std::os::raw::c_uchar,
                       tweak: *mut ::std::os::raw::c_uchar,
                       xts: *mut symmetric_xts) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xts_done(xts: *mut symmetric_xts);
}
extern "C" {
    pub fn xts_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xts_mult_x(I: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn find_cipher(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn find_cipher_any(name: *const ::std::os::raw::c_char,
                           blocklen: ::std::os::raw::c_int,
                           keylen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn find_cipher_id(ID: ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn register_cipher(cipher: *const ltc_cipher_descriptor)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unregister_cipher(cipher: *const ltc_cipher_descriptor)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn register_all_ciphers() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cipher_is_valid(idx: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct chacha_state {
    pub input: [ulong32; 16usize],
    pub kstream: [::std::os::raw::c_uchar; 64usize],
    pub ksleft: ::std::os::raw::c_ulong,
    pub ivlen: ::std::os::raw::c_ulong,
    pub rounds: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_chacha_state() {
    assert_eq!(::std::mem::size_of::<chacha_state>() , 152usize , concat ! (
               "Size of: " , stringify ! ( chacha_state ) ));
    assert_eq! (::std::mem::align_of::<chacha_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( chacha_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chacha_state ) ) . input as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( chacha_state ) , "::" ,
                stringify ! ( input ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chacha_state ) ) . kstream as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( chacha_state ) , "::" ,
                stringify ! ( kstream ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chacha_state ) ) . ksleft as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( chacha_state ) , "::" ,
                stringify ! ( ksleft ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chacha_state ) ) . ivlen as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( chacha_state ) , "::" ,
                stringify ! ( ivlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chacha_state ) ) . rounds as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( chacha_state ) , "::" ,
                stringify ! ( rounds ) ));
}
impl Clone for chacha_state {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn chacha_setup(st: *mut chacha_state,
                        key: *const ::std::os::raw::c_uchar,
                        keylen: ::std::os::raw::c_ulong,
                        rounds: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha_ivctr32(st: *mut chacha_state,
                          iv: *const ::std::os::raw::c_uchar,
                          ivlen: ::std::os::raw::c_ulong, counter: ulong32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha_ivctr64(st: *mut chacha_state,
                          iv: *const ::std::os::raw::c_uchar,
                          ivlen: ::std::os::raw::c_ulong, counter: ulong64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha_crypt(st: *mut chacha_state,
                        in_: *const ::std::os::raw::c_uchar,
                        inlen: ::std::os::raw::c_ulong,
                        out: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha_keystream(st: *mut chacha_state,
                            out: *mut ::std::os::raw::c_uchar,
                            outlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha_done(st: *mut chacha_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha_test() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct rc4_state {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub buf: [::std::os::raw::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_rc4_state() {
    assert_eq!(::std::mem::size_of::<rc4_state>() , 264usize , concat ! (
               "Size of: " , stringify ! ( rc4_state ) ));
    assert_eq! (::std::mem::align_of::<rc4_state>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rc4_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rc4_state ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rc4_state ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rc4_state ) ) . y as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rc4_state ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rc4_state ) ) . buf as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rc4_state ) , "::" ,
                stringify ! ( buf ) ));
}
impl Clone for rc4_state {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn rc4_stream_setup(st: *mut rc4_state,
                            key: *const ::std::os::raw::c_uchar,
                            keylen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc4_stream_crypt(st: *mut rc4_state,
                            in_: *const ::std::os::raw::c_uchar,
                            inlen: ::std::os::raw::c_ulong,
                            out: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc4_stream_keystream(st: *mut rc4_state,
                                out: *mut ::std::os::raw::c_uchar,
                                outlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc4_stream_done(st: *mut rc4_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc4_stream_test() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sober128_state {
    pub R: [ulong32; 17usize],
    pub initR: [ulong32; 17usize],
    pub konst: ulong32,
    pub sbuf: ulong32,
    pub nbuf: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sober128_state() {
    assert_eq!(::std::mem::size_of::<sober128_state>() , 148usize , concat ! (
               "Size of: " , stringify ! ( sober128_state ) ));
    assert_eq! (::std::mem::align_of::<sober128_state>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sober128_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sober128_state ) ) . R as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sober128_state ) , "::"
                , stringify ! ( R ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sober128_state ) ) . initR as * const _
                as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( sober128_state ) , "::"
                , stringify ! ( initR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sober128_state ) ) . konst as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( sober128_state ) , "::"
                , stringify ! ( konst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sober128_state ) ) . sbuf as * const _ as
                usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( sober128_state ) , "::"
                , stringify ! ( sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sober128_state ) ) . nbuf as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( sober128_state ) , "::"
                , stringify ! ( nbuf ) ));
}
impl Clone for sober128_state {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn sober128_stream_setup(st: *mut sober128_state,
                                 key: *const ::std::os::raw::c_uchar,
                                 keylen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sober128_stream_setiv(st: *mut sober128_state,
                                 iv: *const ::std::os::raw::c_uchar,
                                 ivlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sober128_stream_crypt(st: *mut sober128_state,
                                 in_: *const ::std::os::raw::c_uchar,
                                 inlen: ::std::os::raw::c_ulong,
                                 out: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sober128_stream_keystream(st: *mut sober128_state,
                                     out: *mut ::std::os::raw::c_uchar,
                                     outlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sober128_stream_done(st: *mut sober128_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sober128_stream_test() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct sha3_state {
    pub saved: ulong64,
    pub s: [ulong64; 25usize],
    pub sb: [::std::os::raw::c_uchar; 200usize],
    pub byte_index: ::std::os::raw::c_ushort,
    pub word_index: ::std::os::raw::c_ushort,
    pub capacity_words: ::std::os::raw::c_ushort,
    pub xof_flag: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_sha3_state() {
    assert_eq!(::std::mem::size_of::<sha3_state>() , 416usize , concat ! (
               "Size of: " , stringify ! ( sha3_state ) ));
    assert_eq! (::std::mem::align_of::<sha3_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sha3_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha3_state ) ) . saved as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sha3_state ) , "::" ,
                stringify ! ( saved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha3_state ) ) . s as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sha3_state ) , "::" ,
                stringify ! ( s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha3_state ) ) . sb as * const _ as usize
                } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( sha3_state ) , "::" ,
                stringify ! ( sb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha3_state ) ) . byte_index as * const _
                as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( sha3_state ) , "::" ,
                stringify ! ( byte_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha3_state ) ) . word_index as * const _
                as usize } , 410usize , concat ! (
                "Alignment of field: " , stringify ! ( sha3_state ) , "::" ,
                stringify ! ( word_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha3_state ) ) . capacity_words as *
                const _ as usize } , 412usize , concat ! (
                "Alignment of field: " , stringify ! ( sha3_state ) , "::" ,
                stringify ! ( capacity_words ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha3_state ) ) . xof_flag as * const _ as
                usize } , 414usize , concat ! (
                "Alignment of field: " , stringify ! ( sha3_state ) , "::" ,
                stringify ! ( xof_flag ) ));
}
impl Clone for sha3_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sha512_state {
    pub length: ulong64,
    pub state: [ulong64; 8usize],
    pub curlen: ::std::os::raw::c_ulong,
    pub buf: [::std::os::raw::c_uchar; 128usize],
}
#[test]
fn bindgen_test_layout_sha512_state() {
    assert_eq!(::std::mem::size_of::<sha512_state>() , 208usize , concat ! (
               "Size of: " , stringify ! ( sha512_state ) ));
    assert_eq! (::std::mem::align_of::<sha512_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sha512_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha512_state ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sha512_state ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha512_state ) ) . state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sha512_state ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha512_state ) ) . curlen as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sha512_state ) , "::" ,
                stringify ! ( curlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha512_state ) ) . buf as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sha512_state ) , "::" ,
                stringify ! ( buf ) ));
}
impl Clone for sha512_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sha256_state {
    pub length: ulong64,
    pub state: [ulong32; 8usize],
    pub curlen: ulong32,
    pub buf: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_sha256_state() {
    assert_eq!(::std::mem::size_of::<sha256_state>() , 112usize , concat ! (
               "Size of: " , stringify ! ( sha256_state ) ));
    assert_eq! (::std::mem::align_of::<sha256_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sha256_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha256_state ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sha256_state ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha256_state ) ) . state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sha256_state ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha256_state ) ) . curlen as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sha256_state ) , "::" ,
                stringify ! ( curlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha256_state ) ) . buf as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( sha256_state ) , "::" ,
                stringify ! ( buf ) ));
}
impl Clone for sha256_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sha1_state {
    pub length: ulong64,
    pub state: [ulong32; 5usize],
    pub curlen: ulong32,
    pub buf: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_sha1_state() {
    assert_eq!(::std::mem::size_of::<sha1_state>() , 96usize , concat ! (
               "Size of: " , stringify ! ( sha1_state ) ));
    assert_eq! (::std::mem::align_of::<sha1_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sha1_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha1_state ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sha1_state ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha1_state ) ) . state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sha1_state ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha1_state ) ) . curlen as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( sha1_state ) , "::" ,
                stringify ! ( curlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sha1_state ) ) . buf as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sha1_state ) , "::" ,
                stringify ! ( buf ) ));
}
impl Clone for sha1_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct md5_state {
    pub length: ulong64,
    pub state: [ulong32; 4usize],
    pub curlen: ulong32,
    pub buf: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_md5_state() {
    assert_eq!(::std::mem::size_of::<md5_state>() , 96usize , concat ! (
               "Size of: " , stringify ! ( md5_state ) ));
    assert_eq! (::std::mem::align_of::<md5_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( md5_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md5_state ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( md5_state ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md5_state ) ) . state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( md5_state ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md5_state ) ) . curlen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( md5_state ) , "::" ,
                stringify ! ( curlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md5_state ) ) . buf as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( md5_state ) , "::" ,
                stringify ! ( buf ) ));
}
impl Clone for md5_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct md4_state {
    pub length: ulong64,
    pub state: [ulong32; 4usize],
    pub curlen: ulong32,
    pub buf: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_md4_state() {
    assert_eq!(::std::mem::size_of::<md4_state>() , 96usize , concat ! (
               "Size of: " , stringify ! ( md4_state ) ));
    assert_eq! (::std::mem::align_of::<md4_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( md4_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md4_state ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( md4_state ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md4_state ) ) . state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( md4_state ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md4_state ) ) . curlen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( md4_state ) , "::" ,
                stringify ! ( curlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md4_state ) ) . buf as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( md4_state ) , "::" ,
                stringify ! ( buf ) ));
}
impl Clone for md4_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct tiger_state {
    pub state: [ulong64; 3usize],
    pub length: ulong64,
    pub curlen: ::std::os::raw::c_ulong,
    pub buf: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_tiger_state() {
    assert_eq!(::std::mem::size_of::<tiger_state>() , 104usize , concat ! (
               "Size of: " , stringify ! ( tiger_state ) ));
    assert_eq! (::std::mem::align_of::<tiger_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tiger_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tiger_state ) ) . state as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tiger_state ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tiger_state ) ) . length as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tiger_state ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tiger_state ) ) . curlen as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tiger_state ) , "::" ,
                stringify ! ( curlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tiger_state ) ) . buf as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tiger_state ) , "::" ,
                stringify ! ( buf ) ));
}
impl Clone for tiger_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct md2_state {
    pub chksum: [::std::os::raw::c_uchar; 16usize],
    pub X: [::std::os::raw::c_uchar; 48usize],
    pub buf: [::std::os::raw::c_uchar; 16usize],
    pub curlen: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_md2_state() {
    assert_eq!(::std::mem::size_of::<md2_state>() , 88usize , concat ! (
               "Size of: " , stringify ! ( md2_state ) ));
    assert_eq! (::std::mem::align_of::<md2_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( md2_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md2_state ) ) . chksum as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( md2_state ) , "::" ,
                stringify ! ( chksum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md2_state ) ) . X as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( md2_state ) , "::" ,
                stringify ! ( X ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md2_state ) ) . buf as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( md2_state ) , "::" ,
                stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md2_state ) ) . curlen as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( md2_state ) , "::" ,
                stringify ! ( curlen ) ));
}
impl Clone for md2_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct rmd128_state {
    pub length: ulong64,
    pub buf: [::std::os::raw::c_uchar; 64usize],
    pub curlen: ulong32,
    pub state: [ulong32; 4usize],
}
#[test]
fn bindgen_test_layout_rmd128_state() {
    assert_eq!(::std::mem::size_of::<rmd128_state>() , 96usize , concat ! (
               "Size of: " , stringify ! ( rmd128_state ) ));
    assert_eq! (::std::mem::align_of::<rmd128_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmd128_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmd128_state ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmd128_state ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmd128_state ) ) . buf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rmd128_state ) , "::" ,
                stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmd128_state ) ) . curlen as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rmd128_state ) , "::" ,
                stringify ! ( curlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmd128_state ) ) . state as * const _ as
                usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( rmd128_state ) , "::" ,
                stringify ! ( state ) ));
}
impl Clone for rmd128_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct rmd160_state {
    pub length: ulong64,
    pub buf: [::std::os::raw::c_uchar; 64usize],
    pub curlen: ulong32,
    pub state: [ulong32; 5usize],
}
#[test]
fn bindgen_test_layout_rmd160_state() {
    assert_eq!(::std::mem::size_of::<rmd160_state>() , 96usize , concat ! (
               "Size of: " , stringify ! ( rmd160_state ) ));
    assert_eq! (::std::mem::align_of::<rmd160_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmd160_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmd160_state ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmd160_state ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmd160_state ) ) . buf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rmd160_state ) , "::" ,
                stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmd160_state ) ) . curlen as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rmd160_state ) , "::" ,
                stringify ! ( curlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmd160_state ) ) . state as * const _ as
                usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( rmd160_state ) , "::" ,
                stringify ! ( state ) ));
}
impl Clone for rmd160_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct rmd256_state {
    pub length: ulong64,
    pub buf: [::std::os::raw::c_uchar; 64usize],
    pub curlen: ulong32,
    pub state: [ulong32; 8usize],
}
#[test]
fn bindgen_test_layout_rmd256_state() {
    assert_eq!(::std::mem::size_of::<rmd256_state>() , 112usize , concat ! (
               "Size of: " , stringify ! ( rmd256_state ) ));
    assert_eq! (::std::mem::align_of::<rmd256_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmd256_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmd256_state ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmd256_state ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmd256_state ) ) . buf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rmd256_state ) , "::" ,
                stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmd256_state ) ) . curlen as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rmd256_state ) , "::" ,
                stringify ! ( curlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmd256_state ) ) . state as * const _ as
                usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( rmd256_state ) , "::" ,
                stringify ! ( state ) ));
}
impl Clone for rmd256_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct rmd320_state {
    pub length: ulong64,
    pub buf: [::std::os::raw::c_uchar; 64usize],
    pub curlen: ulong32,
    pub state: [ulong32; 10usize],
}
#[test]
fn bindgen_test_layout_rmd320_state() {
    assert_eq!(::std::mem::size_of::<rmd320_state>() , 120usize , concat ! (
               "Size of: " , stringify ! ( rmd320_state ) ));
    assert_eq! (::std::mem::align_of::<rmd320_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmd320_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmd320_state ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmd320_state ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmd320_state ) ) . buf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rmd320_state ) , "::" ,
                stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmd320_state ) ) . curlen as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rmd320_state ) , "::" ,
                stringify ! ( curlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmd320_state ) ) . state as * const _ as
                usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( rmd320_state ) , "::" ,
                stringify ! ( state ) ));
}
impl Clone for rmd320_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct whirlpool_state {
    pub length: ulong64,
    pub state: [ulong64; 8usize],
    pub buf: [::std::os::raw::c_uchar; 64usize],
    pub curlen: ulong32,
}
#[test]
fn bindgen_test_layout_whirlpool_state() {
    assert_eq!(::std::mem::size_of::<whirlpool_state>() , 144usize , concat !
               ( "Size of: " , stringify ! ( whirlpool_state ) ));
    assert_eq! (::std::mem::align_of::<whirlpool_state>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( whirlpool_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const whirlpool_state ) ) . length as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( whirlpool_state ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const whirlpool_state ) ) . state as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( whirlpool_state ) ,
                "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const whirlpool_state ) ) . buf as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( whirlpool_state ) ,
                "::" , stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const whirlpool_state ) ) . curlen as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( whirlpool_state ) ,
                "::" , stringify ! ( curlen ) ));
}
impl Clone for whirlpool_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct chc_state {
    pub length: ulong64,
    pub state: [::std::os::raw::c_uchar; 128usize],
    pub buf: [::std::os::raw::c_uchar; 128usize],
    pub curlen: ulong32,
}
#[test]
fn bindgen_test_layout_chc_state() {
    assert_eq!(::std::mem::size_of::<chc_state>() , 272usize , concat ! (
               "Size of: " , stringify ! ( chc_state ) ));
    assert_eq! (::std::mem::align_of::<chc_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( chc_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chc_state ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( chc_state ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chc_state ) ) . state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( chc_state ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chc_state ) ) . buf as * const _ as usize
                } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( chc_state ) , "::" ,
                stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chc_state ) ) . curlen as * const _ as
                usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( chc_state ) , "::" ,
                stringify ! ( curlen ) ));
}
impl Clone for chc_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct blake2s_state {
    pub h: [ulong32; 8usize],
    pub t: [ulong32; 2usize],
    pub f: [ulong32; 2usize],
    pub buf: [::std::os::raw::c_uchar; 64usize],
    pub curlen: ::std::os::raw::c_ulong,
    pub outlen: ::std::os::raw::c_ulong,
    pub last_node: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_blake2s_state() {
    assert_eq!(::std::mem::size_of::<blake2s_state>() , 136usize , concat ! (
               "Size of: " , stringify ! ( blake2s_state ) ));
    assert_eq! (::std::mem::align_of::<blake2s_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( blake2s_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blake2s_state ) ) . h as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( blake2s_state ) , "::"
                , stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blake2s_state ) ) . t as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( blake2s_state ) , "::"
                , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blake2s_state ) ) . f as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( blake2s_state ) , "::"
                , stringify ! ( f ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blake2s_state ) ) . buf as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( blake2s_state ) , "::"
                , stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blake2s_state ) ) . curlen as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( blake2s_state ) , "::"
                , stringify ! ( curlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blake2s_state ) ) . outlen as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( blake2s_state ) , "::"
                , stringify ! ( outlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blake2s_state ) ) . last_node as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( blake2s_state ) , "::"
                , stringify ! ( last_node ) ));
}
impl Clone for blake2s_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct blake2b_state {
    pub h: [ulong64; 8usize],
    pub t: [ulong64; 2usize],
    pub f: [ulong64; 2usize],
    pub buf: [::std::os::raw::c_uchar; 128usize],
    pub curlen: ::std::os::raw::c_ulong,
    pub outlen: ::std::os::raw::c_ulong,
    pub last_node: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_blake2b_state() {
    assert_eq!(::std::mem::size_of::<blake2b_state>() , 248usize , concat ! (
               "Size of: " , stringify ! ( blake2b_state ) ));
    assert_eq! (::std::mem::align_of::<blake2b_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( blake2b_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blake2b_state ) ) . h as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( blake2b_state ) , "::"
                , stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blake2b_state ) ) . t as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( blake2b_state ) , "::"
                , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blake2b_state ) ) . f as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( blake2b_state ) , "::"
                , stringify ! ( f ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blake2b_state ) ) . buf as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( blake2b_state ) , "::"
                , stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blake2b_state ) ) . curlen as * const _
                as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( blake2b_state ) , "::"
                , stringify ! ( curlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blake2b_state ) ) . outlen as * const _
                as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( blake2b_state ) , "::"
                , stringify ! ( outlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blake2b_state ) ) . last_node as * const
                _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( blake2b_state ) , "::"
                , stringify ! ( last_node ) ));
}
impl Clone for blake2b_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union Hash_state {
    pub dummy: [::std::os::raw::c_char; 1usize],
    pub chc: chc_state,
    pub whirlpool: whirlpool_state,
    pub sha3: sha3_state,
    pub sha512: sha512_state,
    pub sha256: sha256_state,
    pub sha1: sha1_state,
    pub md5: md5_state,
    pub md4: md4_state,
    pub md2: md2_state,
    pub tiger: tiger_state,
    pub rmd128: rmd128_state,
    pub rmd160: rmd160_state,
    pub rmd256: rmd256_state,
    pub rmd320: rmd320_state,
    pub blake2s: blake2s_state,
    pub blake2b: blake2b_state,
    pub data: *mut ::std::os::raw::c_void,
    _bindgen_union_align: [u64; 52usize],
}
#[test]
fn bindgen_test_layout_Hash_state() {
    assert_eq!(::std::mem::size_of::<Hash_state>() , 416usize , concat ! (
               "Size of: " , stringify ! ( Hash_state ) ));
    assert_eq! (::std::mem::align_of::<Hash_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Hash_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . dummy as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( dummy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . chc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( chc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . whirlpool as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( whirlpool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . sha3 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( sha3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . sha512 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( sha512 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . sha256 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( sha256 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . sha1 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( sha1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . md5 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( md5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . md4 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( md4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . md2 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( md2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . tiger as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( tiger ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . rmd128 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( rmd128 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . rmd160 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( rmd160 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . rmd256 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( rmd256 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . rmd320 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( rmd320 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . blake2s as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( blake2s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . blake2b as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( blake2b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hash_state ) ) . data as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hash_state ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for Hash_state {
    fn clone(&self) -> Self { *self }
}
pub type hash_state = Hash_state;
/// hash descriptor
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ltc_hash_descriptor {
    /// name of hash
    pub name: *const ::std::os::raw::c_char,
    /// internal ID
    pub ID: ::std::os::raw::c_uchar,
    /// Size of digest in octets
    pub hashsize: ::std::os::raw::c_ulong,
    /// Input block size in octets
    pub blocksize: ::std::os::raw::c_ulong,
    /// ASN.1 OID
    pub OID: [::std::os::raw::c_ulong; 16usize],
    /// Length of DER encoding
    pub OIDlen: ::std::os::raw::c_ulong,
    /// Init a hash state
    /// @param hash   The hash to initialize
    /// @return CRYPT_OK if successful
    pub init: ::std::option::Option<unsafe extern "C" fn(hash:
                                                             *mut hash_state)
                                        -> ::std::os::raw::c_int>,
    /// Process a block of data
    /// @param hash   The hash state
    /// @param in     The data to hash
    /// @param inlen  The length of the data (octets)
    /// @return CRYPT_OK if successful
    pub process: ::std::option::Option<unsafe extern "C" fn(hash:
                                                                *mut hash_state,
                                                            in_:
                                                                *const ::std::os::raw::c_uchar,
                                                            inlen:
                                                                ::std::os::raw::c_ulong)
                                           -> ::std::os::raw::c_int>,
    /// Produce the digest and store it
    /// @param hash   The hash state
    /// @param out    [out] The destination of the digest
    /// @return CRYPT_OK if successful
    pub done: ::std::option::Option<unsafe extern "C" fn(hash:
                                                             *mut hash_state,
                                                         out:
                                                             *mut ::std::os::raw::c_uchar)
                                        -> ::std::os::raw::c_int>,
    /// Self-test
    /// @return CRYPT_OK if successful, CRYPT_NOP if self-tests have been disabled
    pub test: ::std::option::Option<unsafe extern "C" fn()
                                        -> ::std::os::raw::c_int>,
    pub hmac_block: ::std::option::Option<unsafe extern "C" fn(key:
                                                                   *const ::std::os::raw::c_uchar,
                                                               keylen:
                                                                   ::std::os::raw::c_ulong,
                                                               in_:
                                                                   *const ::std::os::raw::c_uchar,
                                                               inlen:
                                                                   ::std::os::raw::c_ulong,
                                                               out:
                                                                   *mut ::std::os::raw::c_uchar,
                                                               outlen:
                                                                   *mut ::std::os::raw::c_ulong)
                                              -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_ltc_hash_descriptor() {
    assert_eq!(::std::mem::size_of::<ltc_hash_descriptor>() , 208usize ,
               concat ! ( "Size of: " , stringify ! ( ltc_hash_descriptor )
               ));
    assert_eq! (::std::mem::align_of::<ltc_hash_descriptor>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ltc_hash_descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_hash_descriptor ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_hash_descriptor ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_hash_descriptor ) ) . ID as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_hash_descriptor ) ,
                "::" , stringify ! ( ID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_hash_descriptor ) ) . hashsize as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_hash_descriptor ) ,
                "::" , stringify ! ( hashsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_hash_descriptor ) ) . blocksize as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_hash_descriptor ) ,
                "::" , stringify ! ( blocksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_hash_descriptor ) ) . OID as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_hash_descriptor ) ,
                "::" , stringify ! ( OID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_hash_descriptor ) ) . OIDlen as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_hash_descriptor ) ,
                "::" , stringify ! ( OIDlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_hash_descriptor ) ) . init as * const
                _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_hash_descriptor ) ,
                "::" , stringify ! ( init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_hash_descriptor ) ) . process as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_hash_descriptor ) ,
                "::" , stringify ! ( process ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_hash_descriptor ) ) . done as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_hash_descriptor ) ,
                "::" , stringify ! ( done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_hash_descriptor ) ) . test as * const
                _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_hash_descriptor ) ,
                "::" , stringify ! ( test ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_hash_descriptor ) ) . hmac_block as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_hash_descriptor ) ,
                "::" , stringify ! ( hmac_block ) ));
}
impl Clone for ltc_hash_descriptor {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "hash_descriptor"]
    pub static mut hash_descriptor: [ltc_hash_descriptor; 0usize];
}
extern "C" {
    pub fn chc_register(cipher: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chc_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chc_process(md: *mut hash_state,
                       in_: *const ::std::os::raw::c_uchar,
                       inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chc_done(md: *mut hash_state, hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chc_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "chc_desc"]
    pub static chc_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn whirlpool_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn whirlpool_process(md: *mut hash_state,
                             in_: *const ::std::os::raw::c_uchar,
                             inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn whirlpool_done(md: *mut hash_state,
                          hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn whirlpool_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "whirlpool_desc"]
    pub static whirlpool_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn sha3_512_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha3_512_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sha3_512_desc"]
    pub static sha3_512_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn sha3_384_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha3_384_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sha3_384_desc"]
    pub static sha3_384_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn sha3_256_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha3_256_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sha3_256_desc"]
    pub static sha3_256_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn sha3_224_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha3_224_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sha3_224_desc"]
    pub static sha3_224_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn sha3_process(md: *mut hash_state,
                        in_: *const ::std::os::raw::c_uchar,
                        inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha3_done(md: *mut hash_state, hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha3_shake_init(md: *mut hash_state, num: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha3_shake_done(md: *mut hash_state,
                           out: *mut ::std::os::raw::c_uchar,
                           outlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha3_shake_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha3_shake_memory(num: ::std::os::raw::c_int,
                             in_: *const ::std::os::raw::c_uchar,
                             inlen: ::std::os::raw::c_ulong,
                             out: *mut ::std::os::raw::c_uchar,
                             outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha512_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha512_process(md: *mut hash_state,
                          in_: *const ::std::os::raw::c_uchar,
                          inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha512_done(md: *mut hash_state,
                       hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha512_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sha512_desc"]
    pub static sha512_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn sha384_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha384_done(md: *mut hash_state,
                       hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha384_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sha384_desc"]
    pub static sha384_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn sha512_256_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha512_256_done(md: *mut hash_state,
                           hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha512_256_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sha512_256_desc"]
    pub static sha512_256_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn sha512_224_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha512_224_done(md: *mut hash_state,
                           hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha512_224_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sha512_224_desc"]
    pub static sha512_224_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn sha256_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha256_process(md: *mut hash_state,
                          in_: *const ::std::os::raw::c_uchar,
                          inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha256_done(md: *mut hash_state,
                       hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha256_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sha256_desc"]
    pub static sha256_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn sha224_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha224_done(md: *mut hash_state,
                       hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha224_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sha224_desc"]
    pub static sha224_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn sha1_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha1_process(md: *mut hash_state,
                        in_: *const ::std::os::raw::c_uchar,
                        inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha1_done(md: *mut hash_state, hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sha1_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sha1_desc"]
    pub static sha1_desc: ltc_hash_descriptor;
}
extern "C" {
    #[link_name = "blake2s_256_desc"]
    pub static blake2s_256_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn blake2s_256_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2s_256_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "blake2s_224_desc"]
    pub static blake2s_224_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn blake2s_224_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2s_224_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "blake2s_160_desc"]
    pub static blake2s_160_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn blake2s_160_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2s_160_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "blake2s_128_desc"]
    pub static blake2s_128_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn blake2s_128_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2s_128_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2s_init(md: *mut hash_state, outlen: ::std::os::raw::c_ulong,
                        key: *const ::std::os::raw::c_uchar,
                        keylen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2s_process(md: *mut hash_state,
                           in_: *const ::std::os::raw::c_uchar,
                           inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2s_done(md: *mut hash_state,
                        hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "blake2b_512_desc"]
    pub static blake2b_512_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn blake2b_512_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2b_512_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "blake2b_384_desc"]
    pub static blake2b_384_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn blake2b_384_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2b_384_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "blake2b_256_desc"]
    pub static blake2b_256_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn blake2b_256_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2b_256_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "blake2b_160_desc"]
    pub static blake2b_160_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn blake2b_160_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2b_160_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2b_init(md: *mut hash_state, outlen: ::std::os::raw::c_ulong,
                        key: *const ::std::os::raw::c_uchar,
                        keylen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2b_process(md: *mut hash_state,
                           in_: *const ::std::os::raw::c_uchar,
                           inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2b_done(md: *mut hash_state,
                        hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn md5_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn md5_process(md: *mut hash_state,
                       in_: *const ::std::os::raw::c_uchar,
                       inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn md5_done(md: *mut hash_state, hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn md5_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "md5_desc"]
    pub static md5_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn md4_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn md4_process(md: *mut hash_state,
                       in_: *const ::std::os::raw::c_uchar,
                       inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn md4_done(md: *mut hash_state, hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn md4_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "md4_desc"]
    pub static md4_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn md2_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn md2_process(md: *mut hash_state,
                       in_: *const ::std::os::raw::c_uchar,
                       inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn md2_done(md: *mut hash_state, hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn md2_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "md2_desc"]
    pub static md2_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn tiger_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tiger_process(md: *mut hash_state,
                         in_: *const ::std::os::raw::c_uchar,
                         inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tiger_done(md: *mut hash_state, hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tiger_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "tiger_desc"]
    pub static tiger_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn rmd128_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmd128_process(md: *mut hash_state,
                          in_: *const ::std::os::raw::c_uchar,
                          inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmd128_done(md: *mut hash_state,
                       hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmd128_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "rmd128_desc"]
    pub static rmd128_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn rmd160_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmd160_process(md: *mut hash_state,
                          in_: *const ::std::os::raw::c_uchar,
                          inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmd160_done(md: *mut hash_state,
                       hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmd160_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "rmd160_desc"]
    pub static rmd160_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn rmd256_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmd256_process(md: *mut hash_state,
                          in_: *const ::std::os::raw::c_uchar,
                          inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmd256_done(md: *mut hash_state,
                       hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmd256_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "rmd256_desc"]
    pub static rmd256_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn rmd320_init(md: *mut hash_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmd320_process(md: *mut hash_state,
                          in_: *const ::std::os::raw::c_uchar,
                          inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmd320_done(md: *mut hash_state,
                       hash: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmd320_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "rmd320_desc"]
    pub static rmd320_desc: ltc_hash_descriptor;
}
extern "C" {
    pub fn find_hash(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn find_hash_id(ID: ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn find_hash_oid(ID: *const ::std::os::raw::c_ulong,
                         IDlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn find_hash_any(name: *const ::std::os::raw::c_char,
                         digestlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn register_hash(hash: *const ltc_hash_descriptor)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unregister_hash(hash: *const ltc_hash_descriptor)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn register_all_hashes() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hash_is_valid(idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hash_memory(hash: ::std::os::raw::c_int,
                       in_: *const ::std::os::raw::c_uchar,
                       inlen: ::std::os::raw::c_ulong,
                       out: *mut ::std::os::raw::c_uchar,
                       outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hash_memory_multi(hash: ::std::os::raw::c_int,
                             out: *mut ::std::os::raw::c_uchar,
                             outlen: *mut ::std::os::raw::c_ulong,
                             in_: *const ::std::os::raw::c_uchar,
                             inlen: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hash_filehandle(hash: ::std::os::raw::c_int, in_: *mut FILE,
                           out: *mut ::std::os::raw::c_uchar,
                           outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hash_file(hash: ::std::os::raw::c_int,
                     fname: *const ::std::os::raw::c_char,
                     out: *mut ::std::os::raw::c_uchar,
                     outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct Hmac_state {
    pub md: hash_state,
    pub hash: ::std::os::raw::c_int,
    pub hashstate: hash_state,
    pub key: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_Hmac_state() {
    assert_eq!(::std::mem::size_of::<Hmac_state>() , 848usize , concat ! (
               "Size of: " , stringify ! ( Hmac_state ) ));
    assert_eq! (::std::mem::align_of::<Hmac_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Hmac_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hmac_state ) ) . md as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Hmac_state ) , "::" ,
                stringify ! ( md ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hmac_state ) ) . hash as * const _ as
                usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( Hmac_state ) , "::" ,
                stringify ! ( hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hmac_state ) ) . hashstate as * const _
                as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( Hmac_state ) , "::" ,
                stringify ! ( hashstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Hmac_state ) ) . key as * const _ as
                usize } , 840usize , concat ! (
                "Alignment of field: " , stringify ! ( Hmac_state ) , "::" ,
                stringify ! ( key ) ));
}
impl Clone for Hmac_state {
    fn clone(&self) -> Self { *self }
}
pub type hmac_state = Hmac_state;
extern "C" {
    pub fn hmac_init(hmac: *mut hmac_state, hash: ::std::os::raw::c_int,
                     key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hmac_process(hmac: *mut hmac_state,
                        in_: *const ::std::os::raw::c_uchar,
                        inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hmac_done(hmac: *mut hmac_state, out: *mut ::std::os::raw::c_uchar,
                     outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hmac_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hmac_memory(hash: ::std::os::raw::c_int,
                       key: *const ::std::os::raw::c_uchar,
                       keylen: ::std::os::raw::c_ulong,
                       in_: *const ::std::os::raw::c_uchar,
                       inlen: ::std::os::raw::c_ulong,
                       out: *mut ::std::os::raw::c_uchar,
                       outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hmac_memory_multi(hash: ::std::os::raw::c_int,
                             key: *const ::std::os::raw::c_uchar,
                             keylen: ::std::os::raw::c_ulong,
                             out: *mut ::std::os::raw::c_uchar,
                             outlen: *mut ::std::os::raw::c_ulong,
                             in_: *const ::std::os::raw::c_uchar,
                             inlen: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hmac_file(hash: ::std::os::raw::c_int,
                     fname: *const ::std::os::raw::c_char,
                     key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_ulong,
                     dst: *mut ::std::os::raw::c_uchar,
                     dstlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct omac_state {
    pub cipher_idx: ::std::os::raw::c_int,
    pub buflen: ::std::os::raw::c_int,
    pub blklen: ::std::os::raw::c_int,
    pub block: [::std::os::raw::c_uchar; 128usize],
    pub prev: [::std::os::raw::c_uchar; 128usize],
    pub Lu: [[::std::os::raw::c_uchar; 128usize]; 2usize],
    pub key: symmetric_key,
}
#[test]
fn bindgen_test_layout_omac_state() {
    assert_eq!(::std::mem::size_of::<omac_state>() , 4784usize , concat ! (
               "Size of: " , stringify ! ( omac_state ) ));
    assert_eq! (::std::mem::align_of::<omac_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( omac_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omac_state ) ) . cipher_idx as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( omac_state ) , "::" ,
                stringify ! ( cipher_idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omac_state ) ) . buflen as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( omac_state ) , "::" ,
                stringify ! ( buflen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omac_state ) ) . blklen as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( omac_state ) , "::" ,
                stringify ! ( blklen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omac_state ) ) . block as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( omac_state ) , "::" ,
                stringify ! ( block ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omac_state ) ) . prev as * const _ as
                usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( omac_state ) , "::" ,
                stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omac_state ) ) . Lu as * const _ as usize
                } , 268usize , concat ! (
                "Alignment of field: " , stringify ! ( omac_state ) , "::" ,
                stringify ! ( Lu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omac_state ) ) . key as * const _ as
                usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( omac_state ) , "::" ,
                stringify ! ( key ) ));
}
impl Clone for omac_state {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn omac_init(omac: *mut omac_state, cipher: ::std::os::raw::c_int,
                     key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn omac_process(omac: *mut omac_state,
                        in_: *const ::std::os::raw::c_uchar,
                        inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn omac_done(omac: *mut omac_state, out: *mut ::std::os::raw::c_uchar,
                     outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn omac_memory(cipher: ::std::os::raw::c_int,
                       key: *const ::std::os::raw::c_uchar,
                       keylen: ::std::os::raw::c_ulong,
                       in_: *const ::std::os::raw::c_uchar,
                       inlen: ::std::os::raw::c_ulong,
                       out: *mut ::std::os::raw::c_uchar,
                       outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn omac_memory_multi(cipher: ::std::os::raw::c_int,
                             key: *const ::std::os::raw::c_uchar,
                             keylen: ::std::os::raw::c_ulong,
                             out: *mut ::std::os::raw::c_uchar,
                             outlen: *mut ::std::os::raw::c_ulong,
                             in_: *const ::std::os::raw::c_uchar,
                             inlen: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn omac_file(cipher: ::std::os::raw::c_int,
                     key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_ulong,
                     filename: *const ::std::os::raw::c_char,
                     out: *mut ::std::os::raw::c_uchar,
                     outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn omac_test() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct pmac_state {
    pub Ls: [[::std::os::raw::c_uchar; 128usize]; 32usize],
    pub Li: [::std::os::raw::c_uchar; 128usize],
    pub Lr: [::std::os::raw::c_uchar; 128usize],
    pub block: [::std::os::raw::c_uchar; 128usize],
    pub checksum: [::std::os::raw::c_uchar; 128usize],
    pub key: symmetric_key,
    pub block_index: ::std::os::raw::c_ulong,
    pub cipher_idx: ::std::os::raw::c_int,
    pub block_len: ::std::os::raw::c_int,
    pub buflen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pmac_state() {
    assert_eq!(::std::mem::size_of::<pmac_state>() , 8888usize , concat ! (
               "Size of: " , stringify ! ( pmac_state ) ));
    assert_eq! (::std::mem::align_of::<pmac_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pmac_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmac_state ) ) . Ls as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pmac_state ) , "::" ,
                stringify ! ( Ls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmac_state ) ) . Li as * const _ as usize
                } , 4096usize , concat ! (
                "Alignment of field: " , stringify ! ( pmac_state ) , "::" ,
                stringify ! ( Li ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmac_state ) ) . Lr as * const _ as usize
                } , 4224usize , concat ! (
                "Alignment of field: " , stringify ! ( pmac_state ) , "::" ,
                stringify ! ( Lr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmac_state ) ) . block as * const _ as
                usize } , 4352usize , concat ! (
                "Alignment of field: " , stringify ! ( pmac_state ) , "::" ,
                stringify ! ( block ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmac_state ) ) . checksum as * const _ as
                usize } , 4480usize , concat ! (
                "Alignment of field: " , stringify ! ( pmac_state ) , "::" ,
                stringify ! ( checksum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmac_state ) ) . key as * const _ as
                usize } , 4608usize , concat ! (
                "Alignment of field: " , stringify ! ( pmac_state ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmac_state ) ) . block_index as * const _
                as usize } , 8864usize , concat ! (
                "Alignment of field: " , stringify ! ( pmac_state ) , "::" ,
                stringify ! ( block_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmac_state ) ) . cipher_idx as * const _
                as usize } , 8872usize , concat ! (
                "Alignment of field: " , stringify ! ( pmac_state ) , "::" ,
                stringify ! ( cipher_idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmac_state ) ) . block_len as * const _
                as usize } , 8876usize , concat ! (
                "Alignment of field: " , stringify ! ( pmac_state ) , "::" ,
                stringify ! ( block_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmac_state ) ) . buflen as * const _ as
                usize } , 8880usize , concat ! (
                "Alignment of field: " , stringify ! ( pmac_state ) , "::" ,
                stringify ! ( buflen ) ));
}
impl Clone for pmac_state {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn pmac_init(pmac: *mut pmac_state, cipher: ::std::os::raw::c_int,
                     key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pmac_process(pmac: *mut pmac_state,
                        in_: *const ::std::os::raw::c_uchar,
                        inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pmac_done(pmac: *mut pmac_state, out: *mut ::std::os::raw::c_uchar,
                     outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pmac_memory(cipher: ::std::os::raw::c_int,
                       key: *const ::std::os::raw::c_uchar,
                       keylen: ::std::os::raw::c_ulong,
                       msg: *const ::std::os::raw::c_uchar,
                       msglen: ::std::os::raw::c_ulong,
                       out: *mut ::std::os::raw::c_uchar,
                       outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pmac_memory_multi(cipher: ::std::os::raw::c_int,
                             key: *const ::std::os::raw::c_uchar,
                             keylen: ::std::os::raw::c_ulong,
                             out: *mut ::std::os::raw::c_uchar,
                             outlen: *mut ::std::os::raw::c_ulong,
                             in_: *const ::std::os::raw::c_uchar,
                             inlen: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pmac_file(cipher: ::std::os::raw::c_int,
                     key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_ulong,
                     filename: *const ::std::os::raw::c_char,
                     out: *mut ::std::os::raw::c_uchar,
                     outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pmac_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pmac_ntz(x: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pmac_shift_xor(pmac: *mut pmac_state);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct poly1305_state {
    pub r: [ulong32; 5usize],
    pub h: [ulong32; 5usize],
    pub pad: [ulong32; 4usize],
    pub leftover: ::std::os::raw::c_ulong,
    pub buffer: [::std::os::raw::c_uchar; 16usize],
    pub final_: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_poly1305_state() {
    assert_eq!(::std::mem::size_of::<poly1305_state>() , 88usize , concat ! (
               "Size of: " , stringify ! ( poly1305_state ) ));
    assert_eq! (::std::mem::align_of::<poly1305_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( poly1305_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poly1305_state ) ) . r as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( poly1305_state ) , "::"
                , stringify ! ( r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poly1305_state ) ) . h as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( poly1305_state ) , "::"
                , stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poly1305_state ) ) . pad as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( poly1305_state ) , "::"
                , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poly1305_state ) ) . leftover as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( poly1305_state ) , "::"
                , stringify ! ( leftover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poly1305_state ) ) . buffer as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( poly1305_state ) , "::"
                , stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poly1305_state ) ) . final_ as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( poly1305_state ) , "::"
                , stringify ! ( final_ ) ));
}
impl Clone for poly1305_state {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn poly1305_init(st: *mut poly1305_state,
                         key: *const ::std::os::raw::c_uchar,
                         keylen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poly1305_process(st: *mut poly1305_state,
                            in_: *const ::std::os::raw::c_uchar,
                            inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poly1305_done(st: *mut poly1305_state,
                         mac: *mut ::std::os::raw::c_uchar,
                         maclen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poly1305_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poly1305_memory(key: *const ::std::os::raw::c_uchar,
                           keylen: ::std::os::raw::c_ulong,
                           in_: *const ::std::os::raw::c_uchar,
                           inlen: ::std::os::raw::c_ulong,
                           mac: *mut ::std::os::raw::c_uchar,
                           maclen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poly1305_memory_multi(key: *const ::std::os::raw::c_uchar,
                                 keylen: ::std::os::raw::c_ulong,
                                 mac: *mut ::std::os::raw::c_uchar,
                                 maclen: *mut ::std::os::raw::c_ulong,
                                 in_: *const ::std::os::raw::c_uchar,
                                 inlen: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poly1305_file(fname: *const ::std::os::raw::c_char,
                         key: *const ::std::os::raw::c_uchar,
                         keylen: ::std::os::raw::c_ulong,
                         mac: *mut ::std::os::raw::c_uchar,
                         maclen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
pub type blake2smac_state = hash_state;
extern "C" {
    pub fn blake2smac_init(st: *mut blake2smac_state,
                           outlen: ::std::os::raw::c_ulong,
                           key: *const ::std::os::raw::c_uchar,
                           keylen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2smac_process(st: *mut blake2smac_state,
                              in_: *const ::std::os::raw::c_uchar,
                              inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2smac_done(st: *mut blake2smac_state,
                           mac: *mut ::std::os::raw::c_uchar,
                           maclen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2smac_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2smac_memory(key: *const ::std::os::raw::c_uchar,
                             keylen: ::std::os::raw::c_ulong,
                             in_: *const ::std::os::raw::c_uchar,
                             inlen: ::std::os::raw::c_ulong,
                             mac: *mut ::std::os::raw::c_uchar,
                             maclen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2smac_memory_multi(key: *const ::std::os::raw::c_uchar,
                                   keylen: ::std::os::raw::c_ulong,
                                   mac: *mut ::std::os::raw::c_uchar,
                                   maclen: *mut ::std::os::raw::c_ulong,
                                   in_: *const ::std::os::raw::c_uchar,
                                   inlen: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2smac_file(fname: *const ::std::os::raw::c_char,
                           key: *const ::std::os::raw::c_uchar,
                           keylen: ::std::os::raw::c_ulong,
                           mac: *mut ::std::os::raw::c_uchar,
                           maclen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
pub type blake2bmac_state = hash_state;
extern "C" {
    pub fn blake2bmac_init(st: *mut blake2bmac_state,
                           outlen: ::std::os::raw::c_ulong,
                           key: *const ::std::os::raw::c_uchar,
                           keylen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2bmac_process(st: *mut blake2bmac_state,
                              in_: *const ::std::os::raw::c_uchar,
                              inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2bmac_done(st: *mut blake2bmac_state,
                           mac: *mut ::std::os::raw::c_uchar,
                           maclen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2bmac_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2bmac_memory(key: *const ::std::os::raw::c_uchar,
                             keylen: ::std::os::raw::c_ulong,
                             in_: *const ::std::os::raw::c_uchar,
                             inlen: ::std::os::raw::c_ulong,
                             mac: *mut ::std::os::raw::c_uchar,
                             maclen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2bmac_memory_multi(key: *const ::std::os::raw::c_uchar,
                                   keylen: ::std::os::raw::c_ulong,
                                   mac: *mut ::std::os::raw::c_uchar,
                                   maclen: *mut ::std::os::raw::c_ulong,
                                   in_: *const ::std::os::raw::c_uchar,
                                   inlen: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blake2bmac_file(fname: *const ::std::os::raw::c_char,
                           key: *const ::std::os::raw::c_uchar,
                           keylen: ::std::os::raw::c_ulong,
                           mac: *mut ::std::os::raw::c_uchar,
                           maclen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct eax_state {
    pub N: [::std::os::raw::c_uchar; 128usize],
    pub ctr: symmetric_CTR,
    pub headeromac: omac_state,
    pub ctomac: omac_state,
}
#[test]
fn bindgen_test_layout_eax_state() {
    assert_eq!(::std::mem::size_of::<eax_state>() , 14232usize , concat ! (
               "Size of: " , stringify ! ( eax_state ) ));
    assert_eq! (::std::mem::align_of::<eax_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( eax_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eax_state ) ) . N as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( eax_state ) , "::" ,
                stringify ! ( N ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eax_state ) ) . ctr as * const _ as usize
                } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( eax_state ) , "::" ,
                stringify ! ( ctr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eax_state ) ) . headeromac as * const _
                as usize } , 4664usize , concat ! (
                "Alignment of field: " , stringify ! ( eax_state ) , "::" ,
                stringify ! ( headeromac ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eax_state ) ) . ctomac as * const _ as
                usize } , 9448usize , concat ! (
                "Alignment of field: " , stringify ! ( eax_state ) , "::" ,
                stringify ! ( ctomac ) ));
}
impl Clone for eax_state {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn eax_init(eax: *mut eax_state, cipher: ::std::os::raw::c_int,
                    key: *const ::std::os::raw::c_uchar,
                    keylen: ::std::os::raw::c_ulong,
                    nonce: *const ::std::os::raw::c_uchar,
                    noncelen: ::std::os::raw::c_ulong,
                    header: *const ::std::os::raw::c_uchar,
                    headerlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eax_encrypt(eax: *mut eax_state,
                       pt: *const ::std::os::raw::c_uchar,
                       ct: *mut ::std::os::raw::c_uchar,
                       length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eax_decrypt(eax: *mut eax_state,
                       ct: *const ::std::os::raw::c_uchar,
                       pt: *mut ::std::os::raw::c_uchar,
                       length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eax_addheader(eax: *mut eax_state,
                         header: *const ::std::os::raw::c_uchar,
                         length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eax_done(eax: *mut eax_state, tag: *mut ::std::os::raw::c_uchar,
                    taglen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eax_encrypt_authenticate_memory(cipher: ::std::os::raw::c_int,
                                           key:
                                               *const ::std::os::raw::c_uchar,
                                           keylen: ::std::os::raw::c_ulong,
                                           nonce:
                                               *const ::std::os::raw::c_uchar,
                                           noncelen: ::std::os::raw::c_ulong,
                                           header:
                                               *const ::std::os::raw::c_uchar,
                                           headerlen: ::std::os::raw::c_ulong,
                                           pt: *const ::std::os::raw::c_uchar,
                                           ptlen: ::std::os::raw::c_ulong,
                                           ct: *mut ::std::os::raw::c_uchar,
                                           tag: *mut ::std::os::raw::c_uchar,
                                           taglen:
                                               *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eax_decrypt_verify_memory(cipher: ::std::os::raw::c_int,
                                     key: *const ::std::os::raw::c_uchar,
                                     keylen: ::std::os::raw::c_ulong,
                                     nonce: *const ::std::os::raw::c_uchar,
                                     noncelen: ::std::os::raw::c_ulong,
                                     header: *const ::std::os::raw::c_uchar,
                                     headerlen: ::std::os::raw::c_ulong,
                                     ct: *const ::std::os::raw::c_uchar,
                                     ctlen: ::std::os::raw::c_ulong,
                                     pt: *mut ::std::os::raw::c_uchar,
                                     tag: *mut ::std::os::raw::c_uchar,
                                     taglen: ::std::os::raw::c_ulong,
                                     stat: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eax_test() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct ocb_state {
    pub L: [::std::os::raw::c_uchar; 128usize],
    pub Ls: [[::std::os::raw::c_uchar; 128usize]; 32usize],
    pub Li: [::std::os::raw::c_uchar; 128usize],
    pub Lr: [::std::os::raw::c_uchar; 128usize],
    pub R: [::std::os::raw::c_uchar; 128usize],
    pub checksum: [::std::os::raw::c_uchar; 128usize],
    pub key: symmetric_key,
    pub block_index: ::std::os::raw::c_ulong,
    pub cipher: ::std::os::raw::c_int,
    pub block_len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ocb_state() {
    assert_eq!(::std::mem::size_of::<ocb_state>() , 9008usize , concat ! (
               "Size of: " , stringify ! ( ocb_state ) ));
    assert_eq! (::std::mem::align_of::<ocb_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ocb_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb_state ) ) . L as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb_state ) , "::" ,
                stringify ! ( L ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb_state ) ) . Ls as * const _ as usize
                } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb_state ) , "::" ,
                stringify ! ( Ls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb_state ) ) . Li as * const _ as usize
                } , 4224usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb_state ) , "::" ,
                stringify ! ( Li ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb_state ) ) . Lr as * const _ as usize
                } , 4352usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb_state ) , "::" ,
                stringify ! ( Lr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb_state ) ) . R as * const _ as usize }
                , 4480usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb_state ) , "::" ,
                stringify ! ( R ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb_state ) ) . checksum as * const _ as
                usize } , 4608usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb_state ) , "::" ,
                stringify ! ( checksum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb_state ) ) . key as * const _ as usize
                } , 4736usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb_state ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb_state ) ) . block_index as * const _
                as usize } , 8992usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb_state ) , "::" ,
                stringify ! ( block_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb_state ) ) . cipher as * const _ as
                usize } , 9000usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb_state ) , "::" ,
                stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb_state ) ) . block_len as * const _ as
                usize } , 9004usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb_state ) , "::" ,
                stringify ! ( block_len ) ));
}
impl Clone for ocb_state {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn ocb_init(ocb: *mut ocb_state, cipher: ::std::os::raw::c_int,
                    key: *const ::std::os::raw::c_uchar,
                    keylen: ::std::os::raw::c_ulong,
                    nonce: *const ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb_encrypt(ocb: *mut ocb_state,
                       pt: *const ::std::os::raw::c_uchar,
                       ct: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb_decrypt(ocb: *mut ocb_state,
                       ct: *const ::std::os::raw::c_uchar,
                       pt: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb_done_encrypt(ocb: *mut ocb_state,
                            pt: *const ::std::os::raw::c_uchar,
                            ptlen: ::std::os::raw::c_ulong,
                            ct: *mut ::std::os::raw::c_uchar,
                            tag: *mut ::std::os::raw::c_uchar,
                            taglen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb_done_decrypt(ocb: *mut ocb_state,
                            ct: *const ::std::os::raw::c_uchar,
                            ctlen: ::std::os::raw::c_ulong,
                            pt: *mut ::std::os::raw::c_uchar,
                            tag: *const ::std::os::raw::c_uchar,
                            taglen: ::std::os::raw::c_ulong,
                            stat: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb_encrypt_authenticate_memory(cipher: ::std::os::raw::c_int,
                                           key:
                                               *const ::std::os::raw::c_uchar,
                                           keylen: ::std::os::raw::c_ulong,
                                           nonce:
                                               *const ::std::os::raw::c_uchar,
                                           pt: *const ::std::os::raw::c_uchar,
                                           ptlen: ::std::os::raw::c_ulong,
                                           ct: *mut ::std::os::raw::c_uchar,
                                           tag: *mut ::std::os::raw::c_uchar,
                                           taglen:
                                               *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb_decrypt_verify_memory(cipher: ::std::os::raw::c_int,
                                     key: *const ::std::os::raw::c_uchar,
                                     keylen: ::std::os::raw::c_ulong,
                                     nonce: *const ::std::os::raw::c_uchar,
                                     ct: *const ::std::os::raw::c_uchar,
                                     ctlen: ::std::os::raw::c_ulong,
                                     pt: *mut ::std::os::raw::c_uchar,
                                     tag: *const ::std::os::raw::c_uchar,
                                     taglen: ::std::os::raw::c_ulong,
                                     stat: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb_shift_xor(ocb: *mut ocb_state,
                         Z: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn ocb_ntz(x: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn s_ocb_done(ocb: *mut ocb_state, pt: *const ::std::os::raw::c_uchar,
                      ptlen: ::std::os::raw::c_ulong,
                      ct: *mut ::std::os::raw::c_uchar,
                      tag: *mut ::std::os::raw::c_uchar,
                      taglen: *mut ::std::os::raw::c_ulong,
                      mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct ocb3_state {
    pub Offset_0: [::std::os::raw::c_uchar; 128usize],
    pub Offset_current: [::std::os::raw::c_uchar; 128usize],
    pub L_dollar: [::std::os::raw::c_uchar; 128usize],
    pub L_star: [::std::os::raw::c_uchar; 128usize],
    pub L_: [[::std::os::raw::c_uchar; 128usize]; 32usize],
    pub tag_part: [::std::os::raw::c_uchar; 128usize],
    pub checksum: [::std::os::raw::c_uchar; 128usize],
    pub aSum_current: [::std::os::raw::c_uchar; 128usize],
    pub aOffset_current: [::std::os::raw::c_uchar; 128usize],
    pub adata_buffer: [::std::os::raw::c_uchar; 128usize],
    pub adata_buffer_bytes: ::std::os::raw::c_int,
    pub ablock_index: ::std::os::raw::c_ulong,
    pub key: symmetric_key,
    pub block_index: ::std::os::raw::c_ulong,
    pub cipher: ::std::os::raw::c_int,
    pub tag_len: ::std::os::raw::c_int,
    pub block_len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ocb3_state() {
    assert_eq!(::std::mem::size_of::<ocb3_state>() , 9544usize , concat ! (
               "Size of: " , stringify ! ( ocb3_state ) ));
    assert_eq! (::std::mem::align_of::<ocb3_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ocb3_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . Offset_0 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( Offset_0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . Offset_current as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( Offset_current ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . L_dollar as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( L_dollar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . L_star as * const _ as
                usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( L_star ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . L_ as * const _ as usize
                } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( L_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . tag_part as * const _ as
                usize } , 4608usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( tag_part ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . checksum as * const _ as
                usize } , 4736usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( checksum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . aSum_current as * const
                _ as usize } , 4864usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( aSum_current ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . aOffset_current as *
                const _ as usize } , 4992usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( aOffset_current ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . adata_buffer as * const
                _ as usize } , 5120usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( adata_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . adata_buffer_bytes as *
                const _ as usize } , 5248usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( adata_buffer_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . ablock_index as * const
                _ as usize } , 5256usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( ablock_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . key as * const _ as
                usize } , 5264usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . block_index as * const _
                as usize } , 9520usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( block_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . cipher as * const _ as
                usize } , 9528usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . tag_len as * const _ as
                usize } , 9532usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( tag_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ocb3_state ) ) . block_len as * const _
                as usize } , 9536usize , concat ! (
                "Alignment of field: " , stringify ! ( ocb3_state ) , "::" ,
                stringify ! ( block_len ) ));
}
impl Clone for ocb3_state {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn ocb3_init(ocb: *mut ocb3_state, cipher: ::std::os::raw::c_int,
                     key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_ulong,
                     nonce: *const ::std::os::raw::c_uchar,
                     noncelen: ::std::os::raw::c_ulong,
                     taglen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb3_encrypt(ocb: *mut ocb3_state,
                        pt: *const ::std::os::raw::c_uchar,
                        ptlen: ::std::os::raw::c_ulong,
                        ct: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb3_decrypt(ocb: *mut ocb3_state,
                        ct: *const ::std::os::raw::c_uchar,
                        ctlen: ::std::os::raw::c_ulong,
                        pt: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb3_encrypt_last(ocb: *mut ocb3_state,
                             pt: *const ::std::os::raw::c_uchar,
                             ptlen: ::std::os::raw::c_ulong,
                             ct: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb3_decrypt_last(ocb: *mut ocb3_state,
                             ct: *const ::std::os::raw::c_uchar,
                             ctlen: ::std::os::raw::c_ulong,
                             pt: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb3_add_aad(ocb: *mut ocb3_state,
                        aad: *const ::std::os::raw::c_uchar,
                        aadlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb3_done(ocb: *mut ocb3_state, tag: *mut ::std::os::raw::c_uchar,
                     taglen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb3_encrypt_authenticate_memory(cipher: ::std::os::raw::c_int,
                                            key:
                                                *const ::std::os::raw::c_uchar,
                                            keylen: ::std::os::raw::c_ulong,
                                            nonce:
                                                *const ::std::os::raw::c_uchar,
                                            noncelen: ::std::os::raw::c_ulong,
                                            adata:
                                                *const ::std::os::raw::c_uchar,
                                            adatalen: ::std::os::raw::c_ulong,
                                            pt:
                                                *const ::std::os::raw::c_uchar,
                                            ptlen: ::std::os::raw::c_ulong,
                                            ct: *mut ::std::os::raw::c_uchar,
                                            tag: *mut ::std::os::raw::c_uchar,
                                            taglen:
                                                *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb3_decrypt_verify_memory(cipher: ::std::os::raw::c_int,
                                      key: *const ::std::os::raw::c_uchar,
                                      keylen: ::std::os::raw::c_ulong,
                                      nonce: *const ::std::os::raw::c_uchar,
                                      noncelen: ::std::os::raw::c_ulong,
                                      adata: *const ::std::os::raw::c_uchar,
                                      adatalen: ::std::os::raw::c_ulong,
                                      ct: *const ::std::os::raw::c_uchar,
                                      ctlen: ::std::os::raw::c_ulong,
                                      pt: *mut ::std::os::raw::c_uchar,
                                      tag: *const ::std::os::raw::c_uchar,
                                      taglen: ::std::os::raw::c_ulong,
                                      stat: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb3_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb3_int_ntz(x: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocb3_int_xor_blocks(out: *mut ::std::os::raw::c_uchar,
                               block_a: *const ::std::os::raw::c_uchar,
                               block_b: *const ::std::os::raw::c_uchar,
                               block_len: ::std::os::raw::c_ulong);
}
#[repr(C)]
#[derive(Copy)]
pub struct ccm_state {
    pub K: symmetric_key,
    pub cipher: ::std::os::raw::c_int,
    pub taglen: ::std::os::raw::c_int,
    pub x: ::std::os::raw::c_int,
    pub L: ::std::os::raw::c_ulong,
    pub ptlen: ::std::os::raw::c_ulong,
    pub current_ptlen: ::std::os::raw::c_ulong,
    pub aadlen: ::std::os::raw::c_ulong,
    pub current_aadlen: ::std::os::raw::c_ulong,
    pub noncelen: ::std::os::raw::c_ulong,
    pub PAD: [::std::os::raw::c_uchar; 16usize],
    pub ctr: [::std::os::raw::c_uchar; 16usize],
    pub CTRPAD: [::std::os::raw::c_uchar; 16usize],
    pub CTRlen: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_ccm_state() {
    assert_eq!(::std::mem::size_of::<ccm_state>() , 4376usize , concat ! (
               "Size of: " , stringify ! ( ccm_state ) ));
    assert_eq! (::std::mem::align_of::<ccm_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ccm_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ccm_state ) ) . K as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ccm_state ) , "::" ,
                stringify ! ( K ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ccm_state ) ) . cipher as * const _ as
                usize } , 4256usize , concat ! (
                "Alignment of field: " , stringify ! ( ccm_state ) , "::" ,
                stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ccm_state ) ) . taglen as * const _ as
                usize } , 4260usize , concat ! (
                "Alignment of field: " , stringify ! ( ccm_state ) , "::" ,
                stringify ! ( taglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ccm_state ) ) . x as * const _ as usize }
                , 4264usize , concat ! (
                "Alignment of field: " , stringify ! ( ccm_state ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ccm_state ) ) . L as * const _ as usize }
                , 4272usize , concat ! (
                "Alignment of field: " , stringify ! ( ccm_state ) , "::" ,
                stringify ! ( L ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ccm_state ) ) . ptlen as * const _ as
                usize } , 4280usize , concat ! (
                "Alignment of field: " , stringify ! ( ccm_state ) , "::" ,
                stringify ! ( ptlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ccm_state ) ) . current_ptlen as * const
                _ as usize } , 4288usize , concat ! (
                "Alignment of field: " , stringify ! ( ccm_state ) , "::" ,
                stringify ! ( current_ptlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ccm_state ) ) . aadlen as * const _ as
                usize } , 4296usize , concat ! (
                "Alignment of field: " , stringify ! ( ccm_state ) , "::" ,
                stringify ! ( aadlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ccm_state ) ) . current_aadlen as * const
                _ as usize } , 4304usize , concat ! (
                "Alignment of field: " , stringify ! ( ccm_state ) , "::" ,
                stringify ! ( current_aadlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ccm_state ) ) . noncelen as * const _ as
                usize } , 4312usize , concat ! (
                "Alignment of field: " , stringify ! ( ccm_state ) , "::" ,
                stringify ! ( noncelen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ccm_state ) ) . PAD as * const _ as usize
                } , 4320usize , concat ! (
                "Alignment of field: " , stringify ! ( ccm_state ) , "::" ,
                stringify ! ( PAD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ccm_state ) ) . ctr as * const _ as usize
                } , 4336usize , concat ! (
                "Alignment of field: " , stringify ! ( ccm_state ) , "::" ,
                stringify ! ( ctr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ccm_state ) ) . CTRPAD as * const _ as
                usize } , 4352usize , concat ! (
                "Alignment of field: " , stringify ! ( ccm_state ) , "::" ,
                stringify ! ( CTRPAD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ccm_state ) ) . CTRlen as * const _ as
                usize } , 4368usize , concat ! (
                "Alignment of field: " , stringify ! ( ccm_state ) , "::" ,
                stringify ! ( CTRlen ) ));
}
impl Clone for ccm_state {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn ccm_init(ccm: *mut ccm_state, cipher: ::std::os::raw::c_int,
                    key: *const ::std::os::raw::c_uchar,
                    keylen: ::std::os::raw::c_int,
                    ptlen: ::std::os::raw::c_int,
                    taglen: ::std::os::raw::c_int,
                    aad_len: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ccm_reset(ccm: *mut ccm_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ccm_add_nonce(ccm: *mut ccm_state,
                         nonce: *const ::std::os::raw::c_uchar,
                         noncelen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ccm_add_aad(ccm: *mut ccm_state,
                       adata: *const ::std::os::raw::c_uchar,
                       adatalen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ccm_process(ccm: *mut ccm_state, pt: *mut ::std::os::raw::c_uchar,
                       ptlen: ::std::os::raw::c_ulong,
                       ct: *mut ::std::os::raw::c_uchar,
                       direction: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ccm_done(ccm: *mut ccm_state, tag: *mut ::std::os::raw::c_uchar,
                    taglen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ccm_memory(cipher: ::std::os::raw::c_int,
                      key: *const ::std::os::raw::c_uchar,
                      keylen: ::std::os::raw::c_ulong,
                      uskey: *mut symmetric_key,
                      nonce: *const ::std::os::raw::c_uchar,
                      noncelen: ::std::os::raw::c_ulong,
                      header: *const ::std::os::raw::c_uchar,
                      headerlen: ::std::os::raw::c_ulong,
                      pt: *mut ::std::os::raw::c_uchar,
                      ptlen: ::std::os::raw::c_ulong,
                      ct: *mut ::std::os::raw::c_uchar,
                      tag: *mut ::std::os::raw::c_uchar,
                      taglen: *mut ::std::os::raw::c_ulong,
                      direction: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ccm_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcm_gf_mult(a: *const ::std::os::raw::c_uchar,
                       b: *const ::std::os::raw::c_uchar,
                       c: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[link_name = "gcm_shift_table"]
    pub static mut gcm_shift_table: [::std::os::raw::c_uchar; 0usize];
}
#[repr(C)]
#[derive(Copy)]
pub struct gcm_state {
    pub K: symmetric_key,
    pub H: [::std::os::raw::c_uchar; 16usize],
    pub X: [::std::os::raw::c_uchar; 16usize],
    pub Y: [::std::os::raw::c_uchar; 16usize],
    pub Y_0: [::std::os::raw::c_uchar; 16usize],
    pub buf: [::std::os::raw::c_uchar; 16usize],
    pub cipher: ::std::os::raw::c_int,
    pub ivmode: ::std::os::raw::c_int,
    pub mode: ::std::os::raw::c_int,
    pub buflen: ::std::os::raw::c_int,
    pub totlen: ulong64,
    pub pttotlen: ulong64,
    pub PC: [[[::std::os::raw::c_uchar; 16usize]; 256usize]; 16usize],
}
#[test]
fn bindgen_test_layout_gcm_state() {
    assert_eq!(::std::mem::size_of::<gcm_state>() , 69904usize , concat ! (
               "Size of: " , stringify ! ( gcm_state ) ));
    assert_eq! (::std::mem::align_of::<gcm_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( gcm_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gcm_state ) ) . K as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( gcm_state ) , "::" ,
                stringify ! ( K ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gcm_state ) ) . H as * const _ as usize }
                , 4256usize , concat ! (
                "Alignment of field: " , stringify ! ( gcm_state ) , "::" ,
                stringify ! ( H ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gcm_state ) ) . X as * const _ as usize }
                , 4272usize , concat ! (
                "Alignment of field: " , stringify ! ( gcm_state ) , "::" ,
                stringify ! ( X ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gcm_state ) ) . Y as * const _ as usize }
                , 4288usize , concat ! (
                "Alignment of field: " , stringify ! ( gcm_state ) , "::" ,
                stringify ! ( Y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gcm_state ) ) . Y_0 as * const _ as usize
                } , 4304usize , concat ! (
                "Alignment of field: " , stringify ! ( gcm_state ) , "::" ,
                stringify ! ( Y_0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gcm_state ) ) . buf as * const _ as usize
                } , 4320usize , concat ! (
                "Alignment of field: " , stringify ! ( gcm_state ) , "::" ,
                stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gcm_state ) ) . cipher as * const _ as
                usize } , 4336usize , concat ! (
                "Alignment of field: " , stringify ! ( gcm_state ) , "::" ,
                stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gcm_state ) ) . ivmode as * const _ as
                usize } , 4340usize , concat ! (
                "Alignment of field: " , stringify ! ( gcm_state ) , "::" ,
                stringify ! ( ivmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gcm_state ) ) . mode as * const _ as
                usize } , 4344usize , concat ! (
                "Alignment of field: " , stringify ! ( gcm_state ) , "::" ,
                stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gcm_state ) ) . buflen as * const _ as
                usize } , 4348usize , concat ! (
                "Alignment of field: " , stringify ! ( gcm_state ) , "::" ,
                stringify ! ( buflen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gcm_state ) ) . totlen as * const _ as
                usize } , 4352usize , concat ! (
                "Alignment of field: " , stringify ! ( gcm_state ) , "::" ,
                stringify ! ( totlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gcm_state ) ) . pttotlen as * const _ as
                usize } , 4360usize , concat ! (
                "Alignment of field: " , stringify ! ( gcm_state ) , "::" ,
                stringify ! ( pttotlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gcm_state ) ) . PC as * const _ as usize
                } , 4368usize , concat ! (
                "Alignment of field: " , stringify ! ( gcm_state ) , "::" ,
                stringify ! ( PC ) ));
}
impl Clone for gcm_state {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn gcm_mult_h(gcm: *mut gcm_state, I: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn gcm_init(gcm: *mut gcm_state, cipher: ::std::os::raw::c_int,
                    key: *const ::std::os::raw::c_uchar,
                    keylen: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcm_reset(gcm: *mut gcm_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcm_add_iv(gcm: *mut gcm_state, IV: *const ::std::os::raw::c_uchar,
                      IVlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcm_add_aad(gcm: *mut gcm_state,
                       adata: *const ::std::os::raw::c_uchar,
                       adatalen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcm_process(gcm: *mut gcm_state, pt: *mut ::std::os::raw::c_uchar,
                       ptlen: ::std::os::raw::c_ulong,
                       ct: *mut ::std::os::raw::c_uchar,
                       direction: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcm_done(gcm: *mut gcm_state, tag: *mut ::std::os::raw::c_uchar,
                    taglen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcm_memory(cipher: ::std::os::raw::c_int,
                      key: *const ::std::os::raw::c_uchar,
                      keylen: ::std::os::raw::c_ulong,
                      IV: *const ::std::os::raw::c_uchar,
                      IVlen: ::std::os::raw::c_ulong,
                      adata: *const ::std::os::raw::c_uchar,
                      adatalen: ::std::os::raw::c_ulong,
                      pt: *mut ::std::os::raw::c_uchar,
                      ptlen: ::std::os::raw::c_ulong,
                      ct: *mut ::std::os::raw::c_uchar,
                      tag: *mut ::std::os::raw::c_uchar,
                      taglen: *mut ::std::os::raw::c_ulong,
                      direction: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcm_test() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct pelican_state {
    pub K: symmetric_key,
    pub state: [::std::os::raw::c_uchar; 16usize],
    pub buflen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pelican_state() {
    assert_eq!(::std::mem::size_of::<pelican_state>() , 4280usize , concat ! (
               "Size of: " , stringify ! ( pelican_state ) ));
    assert_eq! (::std::mem::align_of::<pelican_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pelican_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pelican_state ) ) . K as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pelican_state ) , "::"
                , stringify ! ( K ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pelican_state ) ) . state as * const _ as
                usize } , 4256usize , concat ! (
                "Alignment of field: " , stringify ! ( pelican_state ) , "::"
                , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pelican_state ) ) . buflen as * const _
                as usize } , 4272usize , concat ! (
                "Alignment of field: " , stringify ! ( pelican_state ) , "::"
                , stringify ! ( buflen ) ));
}
impl Clone for pelican_state {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn pelican_init(pelmac: *mut pelican_state,
                        key: *const ::std::os::raw::c_uchar,
                        keylen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pelican_process(pelmac: *mut pelican_state,
                           in_: *const ::std::os::raw::c_uchar,
                           inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pelican_done(pelmac: *mut pelican_state,
                        out: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pelican_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pelican_memory(key: *const ::std::os::raw::c_uchar,
                          keylen: ::std::os::raw::c_ulong,
                          in_: *const ::std::os::raw::c_uchar,
                          inlen: ::std::os::raw::c_ulong,
                          out: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct xcbc_state {
    pub K: [[::std::os::raw::c_uchar; 128usize]; 3usize],
    pub IV: [::std::os::raw::c_uchar; 128usize],
    pub key: symmetric_key,
    pub cipher: ::std::os::raw::c_int,
    pub buflen: ::std::os::raw::c_int,
    pub blocksize: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcbc_state() {
    assert_eq!(::std::mem::size_of::<xcbc_state>() , 4784usize , concat ! (
               "Size of: " , stringify ! ( xcbc_state ) ));
    assert_eq! (::std::mem::align_of::<xcbc_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( xcbc_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcbc_state ) ) . K as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcbc_state ) , "::" ,
                stringify ! ( K ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcbc_state ) ) . IV as * const _ as usize
                } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( xcbc_state ) , "::" ,
                stringify ! ( IV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcbc_state ) ) . key as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( xcbc_state ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcbc_state ) ) . cipher as * const _ as
                usize } , 4768usize , concat ! (
                "Alignment of field: " , stringify ! ( xcbc_state ) , "::" ,
                stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcbc_state ) ) . buflen as * const _ as
                usize } , 4772usize , concat ! (
                "Alignment of field: " , stringify ! ( xcbc_state ) , "::" ,
                stringify ! ( buflen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcbc_state ) ) . blocksize as * const _
                as usize } , 4776usize , concat ! (
                "Alignment of field: " , stringify ! ( xcbc_state ) , "::" ,
                stringify ! ( blocksize ) ));
}
impl Clone for xcbc_state {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn xcbc_init(xcbc: *mut xcbc_state, cipher: ::std::os::raw::c_int,
                     key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcbc_process(xcbc: *mut xcbc_state,
                        in_: *const ::std::os::raw::c_uchar,
                        inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcbc_done(xcbc: *mut xcbc_state, out: *mut ::std::os::raw::c_uchar,
                     outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcbc_memory(cipher: ::std::os::raw::c_int,
                       key: *const ::std::os::raw::c_uchar,
                       keylen: ::std::os::raw::c_ulong,
                       in_: *const ::std::os::raw::c_uchar,
                       inlen: ::std::os::raw::c_ulong,
                       out: *mut ::std::os::raw::c_uchar,
                       outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcbc_memory_multi(cipher: ::std::os::raw::c_int,
                             key: *const ::std::os::raw::c_uchar,
                             keylen: ::std::os::raw::c_ulong,
                             out: *mut ::std::os::raw::c_uchar,
                             outlen: *mut ::std::os::raw::c_ulong,
                             in_: *const ::std::os::raw::c_uchar,
                             inlen: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcbc_file(cipher: ::std::os::raw::c_int,
                     key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_ulong,
                     filename: *const ::std::os::raw::c_char,
                     out: *mut ::std::os::raw::c_uchar,
                     outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcbc_test() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct f9_state {
    pub akey: [::std::os::raw::c_uchar; 128usize],
    pub ACC: [::std::os::raw::c_uchar; 128usize],
    pub IV: [::std::os::raw::c_uchar; 128usize],
    pub key: symmetric_key,
    pub cipher: ::std::os::raw::c_int,
    pub buflen: ::std::os::raw::c_int,
    pub keylen: ::std::os::raw::c_int,
    pub blocksize: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_f9_state() {
    assert_eq!(::std::mem::size_of::<f9_state>() , 4656usize , concat ! (
               "Size of: " , stringify ! ( f9_state ) ));
    assert_eq! (::std::mem::align_of::<f9_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( f9_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const f9_state ) ) . akey as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( f9_state ) , "::" ,
                stringify ! ( akey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const f9_state ) ) . ACC as * const _ as usize
                } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( f9_state ) , "::" ,
                stringify ! ( ACC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const f9_state ) ) . IV as * const _ as usize }
                , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( f9_state ) , "::" ,
                stringify ! ( IV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const f9_state ) ) . key as * const _ as usize
                } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( f9_state ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const f9_state ) ) . cipher as * const _ as
                usize } , 4640usize , concat ! (
                "Alignment of field: " , stringify ! ( f9_state ) , "::" ,
                stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const f9_state ) ) . buflen as * const _ as
                usize } , 4644usize , concat ! (
                "Alignment of field: " , stringify ! ( f9_state ) , "::" ,
                stringify ! ( buflen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const f9_state ) ) . keylen as * const _ as
                usize } , 4648usize , concat ! (
                "Alignment of field: " , stringify ! ( f9_state ) , "::" ,
                stringify ! ( keylen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const f9_state ) ) . blocksize as * const _ as
                usize } , 4652usize , concat ! (
                "Alignment of field: " , stringify ! ( f9_state ) , "::" ,
                stringify ! ( blocksize ) ));
}
impl Clone for f9_state {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn f9_init(f9: *mut f9_state, cipher: ::std::os::raw::c_int,
                   key: *const ::std::os::raw::c_uchar,
                   keylen: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn f9_process(f9: *mut f9_state, in_: *const ::std::os::raw::c_uchar,
                      inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn f9_done(f9: *mut f9_state, out: *mut ::std::os::raw::c_uchar,
                   outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn f9_memory(cipher: ::std::os::raw::c_int,
                     key: *const ::std::os::raw::c_uchar,
                     keylen: ::std::os::raw::c_ulong,
                     in_: *const ::std::os::raw::c_uchar,
                     inlen: ::std::os::raw::c_ulong,
                     out: *mut ::std::os::raw::c_uchar,
                     outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn f9_memory_multi(cipher: ::std::os::raw::c_int,
                           key: *const ::std::os::raw::c_uchar,
                           keylen: ::std::os::raw::c_ulong,
                           out: *mut ::std::os::raw::c_uchar,
                           outlen: *mut ::std::os::raw::c_ulong,
                           in_: *const ::std::os::raw::c_uchar,
                           inlen: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn f9_file(cipher: ::std::os::raw::c_int,
                   key: *const ::std::os::raw::c_uchar,
                   keylen: ::std::os::raw::c_ulong,
                   filename: *const ::std::os::raw::c_char,
                   out: *mut ::std::os::raw::c_uchar,
                   outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn f9_test() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct chacha20poly1305_state {
    pub poly: poly1305_state,
    pub chacha: chacha_state,
    pub aadlen: ulong64,
    pub ctlen: ulong64,
    pub aadflg: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_chacha20poly1305_state() {
    assert_eq!(::std::mem::size_of::<chacha20poly1305_state>() , 264usize ,
               concat ! ( "Size of: " , stringify ! ( chacha20poly1305_state )
               ));
    assert_eq! (::std::mem::align_of::<chacha20poly1305_state>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( chacha20poly1305_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chacha20poly1305_state ) ) . poly as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( chacha20poly1305_state
                ) , "::" , stringify ! ( poly ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chacha20poly1305_state ) ) . chacha as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( chacha20poly1305_state
                ) , "::" , stringify ! ( chacha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chacha20poly1305_state ) ) . aadlen as *
                const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( chacha20poly1305_state
                ) , "::" , stringify ! ( aadlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chacha20poly1305_state ) ) . ctlen as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( chacha20poly1305_state
                ) , "::" , stringify ! ( ctlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chacha20poly1305_state ) ) . aadflg as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( chacha20poly1305_state
                ) , "::" , stringify ! ( aadflg ) ));
}
impl Clone for chacha20poly1305_state {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn chacha20poly1305_init(st: *mut chacha20poly1305_state,
                                 key: *const ::std::os::raw::c_uchar,
                                 keylen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha20poly1305_setiv(st: *mut chacha20poly1305_state,
                                  iv: *const ::std::os::raw::c_uchar,
                                  ivlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha20poly1305_setiv_rfc7905(st: *mut chacha20poly1305_state,
                                          iv: *const ::std::os::raw::c_uchar,
                                          ivlen: ::std::os::raw::c_ulong,
                                          sequence_number: ulong64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha20poly1305_add_aad(st: *mut chacha20poly1305_state,
                                    in_: *const ::std::os::raw::c_uchar,
                                    inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha20poly1305_encrypt(st: *mut chacha20poly1305_state,
                                    in_: *const ::std::os::raw::c_uchar,
                                    inlen: ::std::os::raw::c_ulong,
                                    out: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha20poly1305_decrypt(st: *mut chacha20poly1305_state,
                                    in_: *const ::std::os::raw::c_uchar,
                                    inlen: ::std::os::raw::c_ulong,
                                    out: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha20poly1305_done(st: *mut chacha20poly1305_state,
                                 tag: *mut ::std::os::raw::c_uchar,
                                 taglen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha20poly1305_memory(key: *const ::std::os::raw::c_uchar,
                                   keylen: ::std::os::raw::c_ulong,
                                   iv: *const ::std::os::raw::c_uchar,
                                   ivlen: ::std::os::raw::c_ulong,
                                   aad: *const ::std::os::raw::c_uchar,
                                   aadlen: ::std::os::raw::c_ulong,
                                   in_: *const ::std::os::raw::c_uchar,
                                   inlen: ::std::os::raw::c_ulong,
                                   out: *mut ::std::os::raw::c_uchar,
                                   tag: *mut ::std::os::raw::c_uchar,
                                   taglen: *mut ::std::os::raw::c_ulong,
                                   direction: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha20poly1305_test() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct yarrow_prng {
    pub cipher: ::std::os::raw::c_int,
    pub hash: ::std::os::raw::c_int,
    pub pool: [::std::os::raw::c_uchar; 128usize],
    pub ctr: symmetric_CTR,
}
#[test]
fn bindgen_test_layout_yarrow_prng() {
    assert_eq!(::std::mem::size_of::<yarrow_prng>() , 4672usize , concat ! (
               "Size of: " , stringify ! ( yarrow_prng ) ));
    assert_eq! (::std::mem::align_of::<yarrow_prng>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( yarrow_prng ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const yarrow_prng ) ) . cipher as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( yarrow_prng ) , "::" ,
                stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const yarrow_prng ) ) . hash as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( yarrow_prng ) , "::" ,
                stringify ! ( hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const yarrow_prng ) ) . pool as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( yarrow_prng ) , "::" ,
                stringify ! ( pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const yarrow_prng ) ) . ctr as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( yarrow_prng ) , "::" ,
                stringify ! ( ctr ) ));
}
impl Clone for yarrow_prng {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct rc4_prng {
    pub s: rc4_state,
}
#[test]
fn bindgen_test_layout_rc4_prng() {
    assert_eq!(::std::mem::size_of::<rc4_prng>() , 264usize , concat ! (
               "Size of: " , stringify ! ( rc4_prng ) ));
    assert_eq! (::std::mem::align_of::<rc4_prng>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rc4_prng ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rc4_prng ) ) . s as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rc4_prng ) , "::" ,
                stringify ! ( s ) ));
}
impl Clone for rc4_prng {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct chacha20_prng {
    pub s: chacha_state,
    pub ent: [::std::os::raw::c_uchar; 40usize],
    pub idx: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_chacha20_prng() {
    assert_eq!(::std::mem::size_of::<chacha20_prng>() , 200usize , concat ! (
               "Size of: " , stringify ! ( chacha20_prng ) ));
    assert_eq! (::std::mem::align_of::<chacha20_prng>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( chacha20_prng ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chacha20_prng ) ) . s as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( chacha20_prng ) , "::"
                , stringify ! ( s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chacha20_prng ) ) . ent as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( chacha20_prng ) , "::"
                , stringify ! ( ent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const chacha20_prng ) ) . idx as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( chacha20_prng ) , "::"
                , stringify ! ( idx ) ));
}
impl Clone for chacha20_prng {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct fortuna_prng {
    pub pool: [hash_state; 32usize],
    pub skey: symmetric_key,
    pub K: [::std::os::raw::c_uchar; 32usize],
    pub IV: [::std::os::raw::c_uchar; 16usize],
    pub pool_idx: ::std::os::raw::c_ulong,
    pub pool0_len: ::std::os::raw::c_ulong,
    pub wd: ::std::os::raw::c_ulong,
    pub reset_cnt: ulong64,
}
#[test]
fn bindgen_test_layout_fortuna_prng() {
    assert_eq!(::std::mem::size_of::<fortuna_prng>() , 17648usize , concat ! (
               "Size of: " , stringify ! ( fortuna_prng ) ));
    assert_eq! (::std::mem::align_of::<fortuna_prng>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fortuna_prng ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fortuna_prng ) ) . pool as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fortuna_prng ) , "::" ,
                stringify ! ( pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fortuna_prng ) ) . skey as * const _ as
                usize } , 13312usize , concat ! (
                "Alignment of field: " , stringify ! ( fortuna_prng ) , "::" ,
                stringify ! ( skey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fortuna_prng ) ) . K as * const _ as
                usize } , 17568usize , concat ! (
                "Alignment of field: " , stringify ! ( fortuna_prng ) , "::" ,
                stringify ! ( K ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fortuna_prng ) ) . IV as * const _ as
                usize } , 17600usize , concat ! (
                "Alignment of field: " , stringify ! ( fortuna_prng ) , "::" ,
                stringify ! ( IV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fortuna_prng ) ) . pool_idx as * const _
                as usize } , 17616usize , concat ! (
                "Alignment of field: " , stringify ! ( fortuna_prng ) , "::" ,
                stringify ! ( pool_idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fortuna_prng ) ) . pool0_len as * const _
                as usize } , 17624usize , concat ! (
                "Alignment of field: " , stringify ! ( fortuna_prng ) , "::" ,
                stringify ! ( pool0_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fortuna_prng ) ) . wd as * const _ as
                usize } , 17632usize , concat ! (
                "Alignment of field: " , stringify ! ( fortuna_prng ) , "::" ,
                stringify ! ( wd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fortuna_prng ) ) . reset_cnt as * const _
                as usize } , 17640usize , concat ! (
                "Alignment of field: " , stringify ! ( fortuna_prng ) , "::" ,
                stringify ! ( reset_cnt ) ));
}
impl Clone for fortuna_prng {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sober128_prng {
    pub s: sober128_state,
    pub ent: [::std::os::raw::c_uchar; 40usize],
    pub idx: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sober128_prng() {
    assert_eq!(::std::mem::size_of::<sober128_prng>() , 200usize , concat ! (
               "Size of: " , stringify ! ( sober128_prng ) ));
    assert_eq! (::std::mem::align_of::<sober128_prng>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sober128_prng ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sober128_prng ) ) . s as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sober128_prng ) , "::"
                , stringify ! ( s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sober128_prng ) ) . ent as * const _ as
                usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( sober128_prng ) , "::"
                , stringify ! ( ent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sober128_prng ) ) . idx as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( sober128_prng ) , "::"
                , stringify ! ( idx ) ));
}
impl Clone for sober128_prng {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct prng_state {
    pub __bindgen_anon_1: prng_state__bindgen_ty_1,
    pub ready: ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Copy)]
pub union prng_state__bindgen_ty_1 {
    pub dummy: [::std::os::raw::c_char; 1usize],
    pub yarrow: yarrow_prng,
    pub rc4: rc4_prng,
    pub chacha: chacha20_prng,
    pub fortuna: fortuna_prng,
    pub sober128: sober128_prng,
    _bindgen_union_align: [u64; 2206usize],
}
#[test]
fn bindgen_test_layout_prng_state__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<prng_state__bindgen_ty_1>() , 17648usize
               , concat ! (
               "Size of: " , stringify ! ( prng_state__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<prng_state__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( prng_state__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const prng_state__bindgen_ty_1 ) ) . dummy as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                prng_state__bindgen_ty_1 ) , "::" , stringify ! ( dummy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const prng_state__bindgen_ty_1 ) ) . yarrow as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                prng_state__bindgen_ty_1 ) , "::" , stringify ! ( yarrow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const prng_state__bindgen_ty_1 ) ) . rc4 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                prng_state__bindgen_ty_1 ) , "::" , stringify ! ( rc4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const prng_state__bindgen_ty_1 ) ) . chacha as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                prng_state__bindgen_ty_1 ) , "::" , stringify ! ( chacha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const prng_state__bindgen_ty_1 ) ) . fortuna as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                prng_state__bindgen_ty_1 ) , "::" , stringify ! ( fortuna )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const prng_state__bindgen_ty_1 ) ) . sober128
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                prng_state__bindgen_ty_1 ) , "::" , stringify ! ( sober128 )
                ));
}
impl Clone for prng_state__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_prng_state() {
    assert_eq!(::std::mem::size_of::<prng_state>() , 17656usize , concat ! (
               "Size of: " , stringify ! ( prng_state ) ));
    assert_eq! (::std::mem::align_of::<prng_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( prng_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const prng_state ) ) . ready as * const _ as
                usize } , 17648usize , concat ! (
                "Alignment of field: " , stringify ! ( prng_state ) , "::" ,
                stringify ! ( ready ) ));
}
impl Clone for prng_state {
    fn clone(&self) -> Self { *self }
}
/// PRNG descriptor
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ltc_prng_descriptor {
    /// Name of the PRNG
    pub name: *const ::std::os::raw::c_char,
    /// size in bytes of exported state
    pub export_size: ::std::os::raw::c_int,
    /// Start a PRNG state
    /// @param prng   [out] The state to initialize
    /// @return CRYPT_OK if successful
    pub start: ::std::option::Option<unsafe extern "C" fn(prng:
                                                              *mut prng_state)
                                         -> ::std::os::raw::c_int>,
    /// Add entropy to the PRNG
    /// @param in         The entropy
    /// @param inlen      Length of the entropy (octets)\
    /// @param prng       The PRNG state
    /// @return CRYPT_OK if successful
    pub add_entropy: ::std::option::Option<unsafe extern "C" fn(in_:
                                                                    *const ::std::os::raw::c_uchar,
                                                                inlen:
                                                                    ::std::os::raw::c_ulong,
                                                                prng:
                                                                    *mut prng_state)
                                               -> ::std::os::raw::c_int>,
    /// Ready a PRNG state to read from
    /// @param prng       The PRNG state to ready
    /// @return CRYPT_OK if successful
    pub ready: ::std::option::Option<unsafe extern "C" fn(prng:
                                                              *mut prng_state)
                                         -> ::std::os::raw::c_int>,
    /// Read from the PRNG
    /// @param out     [out] Where to store the data
    /// @param outlen  Length of data desired (octets)
    /// @param prng    The PRNG state to read from
    /// @return Number of octets read
    pub read: ::std::option::Option<unsafe extern "C" fn(out:
                                                             *mut ::std::os::raw::c_uchar,
                                                         outlen:
                                                             ::std::os::raw::c_ulong,
                                                         prng:
                                                             *mut prng_state)
                                        -> ::std::os::raw::c_ulong>,
    /// Terminate a PRNG state
    /// @param prng   The PRNG state to terminate
    /// @return CRYPT_OK if successful
    pub done: ::std::option::Option<unsafe extern "C" fn(prng:
                                                             *mut prng_state)
                                        -> ::std::os::raw::c_int>,
    /// Export a PRNG state
    /// @param out     [out] The destination for the state
    /// @param outlen  [in/out] The max size and resulting size of the PRNG state
    /// @param prng    The PRNG to export
    /// @return CRYPT_OK if successful
    pub pexport: ::std::option::Option<unsafe extern "C" fn(out:
                                                                *mut ::std::os::raw::c_uchar,
                                                            outlen:
                                                                *mut ::std::os::raw::c_ulong,
                                                            prng:
                                                                *mut prng_state)
                                           -> ::std::os::raw::c_int>,
    /// Import a PRNG state
    /// @param in      The data to import
    /// @param inlen   The length of the data to import (octets)
    /// @param prng    The PRNG to initialize/import
    /// @return CRYPT_OK if successful
    pub pimport: ::std::option::Option<unsafe extern "C" fn(in_:
                                                                *const ::std::os::raw::c_uchar,
                                                            inlen:
                                                                ::std::os::raw::c_ulong,
                                                            prng:
                                                                *mut prng_state)
                                           -> ::std::os::raw::c_int>,
    /// Self-test the PRNG
    /// @return CRYPT_OK if successful, CRYPT_NOP if self-testing has been disabled
    pub test: ::std::option::Option<unsafe extern "C" fn()
                                        -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_ltc_prng_descriptor() {
    assert_eq!(::std::mem::size_of::<ltc_prng_descriptor>() , 80usize , concat
               ! ( "Size of: " , stringify ! ( ltc_prng_descriptor ) ));
    assert_eq! (::std::mem::align_of::<ltc_prng_descriptor>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ltc_prng_descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_prng_descriptor ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_prng_descriptor ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_prng_descriptor ) ) . export_size as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_prng_descriptor ) ,
                "::" , stringify ! ( export_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_prng_descriptor ) ) . start as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_prng_descriptor ) ,
                "::" , stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_prng_descriptor ) ) . add_entropy as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_prng_descriptor ) ,
                "::" , stringify ! ( add_entropy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_prng_descriptor ) ) . ready as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_prng_descriptor ) ,
                "::" , stringify ! ( ready ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_prng_descriptor ) ) . read as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_prng_descriptor ) ,
                "::" , stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_prng_descriptor ) ) . done as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_prng_descriptor ) ,
                "::" , stringify ! ( done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_prng_descriptor ) ) . pexport as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_prng_descriptor ) ,
                "::" , stringify ! ( pexport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_prng_descriptor ) ) . pimport as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_prng_descriptor ) ,
                "::" , stringify ! ( pimport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_prng_descriptor ) ) . test as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_prng_descriptor ) ,
                "::" , stringify ! ( test ) ));
}
impl Clone for ltc_prng_descriptor {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "prng_descriptor"]
    pub static mut prng_descriptor: [ltc_prng_descriptor; 0usize];
}
extern "C" {
    pub fn yarrow_start(prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yarrow_add_entropy(in_: *const ::std::os::raw::c_uchar,
                              inlen: ::std::os::raw::c_ulong,
                              prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yarrow_ready(prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yarrow_read(out: *mut ::std::os::raw::c_uchar,
                       outlen: ::std::os::raw::c_ulong, prng: *mut prng_state)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn yarrow_done(prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yarrow_export(out: *mut ::std::os::raw::c_uchar,
                         outlen: *mut ::std::os::raw::c_ulong,
                         prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yarrow_import(in_: *const ::std::os::raw::c_uchar,
                         inlen: ::std::os::raw::c_ulong,
                         prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yarrow_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "yarrow_desc"]
    pub static yarrow_desc: ltc_prng_descriptor;
}
extern "C" {
    pub fn fortuna_start(prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fortuna_add_entropy(in_: *const ::std::os::raw::c_uchar,
                               inlen: ::std::os::raw::c_ulong,
                               prng: *mut prng_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fortuna_ready(prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fortuna_read(out: *mut ::std::os::raw::c_uchar,
                        outlen: ::std::os::raw::c_ulong,
                        prng: *mut prng_state) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fortuna_done(prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fortuna_export(out: *mut ::std::os::raw::c_uchar,
                          outlen: *mut ::std::os::raw::c_ulong,
                          prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fortuna_import(in_: *const ::std::os::raw::c_uchar,
                          inlen: ::std::os::raw::c_ulong,
                          prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fortuna_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "fortuna_desc"]
    pub static fortuna_desc: ltc_prng_descriptor;
}
extern "C" {
    pub fn rc4_start(prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc4_add_entropy(in_: *const ::std::os::raw::c_uchar,
                           inlen: ::std::os::raw::c_ulong,
                           prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc4_ready(prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc4_read(out: *mut ::std::os::raw::c_uchar,
                    outlen: ::std::os::raw::c_ulong, prng: *mut prng_state)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rc4_done(prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc4_export(out: *mut ::std::os::raw::c_uchar,
                      outlen: *mut ::std::os::raw::c_ulong,
                      prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc4_import(in_: *const ::std::os::raw::c_uchar,
                      inlen: ::std::os::raw::c_ulong, prng: *mut prng_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rc4_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "rc4_desc"]
    pub static rc4_desc: ltc_prng_descriptor;
}
extern "C" {
    pub fn chacha20_prng_start(prng: *mut prng_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha20_prng_add_entropy(in_: *const ::std::os::raw::c_uchar,
                                     inlen: ::std::os::raw::c_ulong,
                                     prng: *mut prng_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha20_prng_ready(prng: *mut prng_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha20_prng_read(out: *mut ::std::os::raw::c_uchar,
                              outlen: ::std::os::raw::c_ulong,
                              prng: *mut prng_state)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn chacha20_prng_done(prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha20_prng_export(out: *mut ::std::os::raw::c_uchar,
                                outlen: *mut ::std::os::raw::c_ulong,
                                prng: *mut prng_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha20_prng_import(in_: *const ::std::os::raw::c_uchar,
                                inlen: ::std::os::raw::c_ulong,
                                prng: *mut prng_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chacha20_prng_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "chacha20_prng_desc"]
    pub static chacha20_prng_desc: ltc_prng_descriptor;
}
extern "C" {
    pub fn sprng_start(prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprng_add_entropy(in_: *const ::std::os::raw::c_uchar,
                             inlen: ::std::os::raw::c_ulong,
                             prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprng_ready(prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprng_read(out: *mut ::std::os::raw::c_uchar,
                      outlen: ::std::os::raw::c_ulong, prng: *mut prng_state)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn sprng_done(prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprng_export(out: *mut ::std::os::raw::c_uchar,
                        outlen: *mut ::std::os::raw::c_ulong,
                        prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprng_import(in_: *const ::std::os::raw::c_uchar,
                        inlen: ::std::os::raw::c_ulong, prng: *mut prng_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprng_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sprng_desc"]
    pub static sprng_desc: ltc_prng_descriptor;
}
extern "C" {
    pub fn sober128_start(prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sober128_add_entropy(in_: *const ::std::os::raw::c_uchar,
                                inlen: ::std::os::raw::c_ulong,
                                prng: *mut prng_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sober128_ready(prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sober128_read(out: *mut ::std::os::raw::c_uchar,
                         outlen: ::std::os::raw::c_ulong,
                         prng: *mut prng_state) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn sober128_done(prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sober128_export(out: *mut ::std::os::raw::c_uchar,
                           outlen: *mut ::std::os::raw::c_ulong,
                           prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sober128_import(in_: *const ::std::os::raw::c_uchar,
                           inlen: ::std::os::raw::c_ulong,
                           prng: *mut prng_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sober128_test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sober128_desc"]
    pub static sober128_desc: ltc_prng_descriptor;
}
extern "C" {
    pub fn find_prng(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn register_prng(prng: *const ltc_prng_descriptor)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unregister_prng(prng: *const ltc_prng_descriptor)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn register_all_prngs() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn prng_is_valid(idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rng_get_bytes(out: *mut ::std::os::raw::c_uchar,
                         outlen: ::std::os::raw::c_ulong,
                         callback:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rng_make_prng(bits: ::std::os::raw::c_int,
                         wprng: ::std::os::raw::c_int, prng: *mut prng_state,
                         callback:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
pub const PK_PUBLIC: _bindgen_ty_3 = _bindgen_ty_3::PK_PUBLIC;
pub const PK_PRIVATE: _bindgen_ty_3 = _bindgen_ty_3::PK_PRIVATE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 { PK_PUBLIC = 0, PK_PRIVATE = 1, }
extern "C" {
    pub fn rand_prime(N: *mut ::std::os::raw::c_void,
                      len: ::std::os::raw::c_long, prng: *mut prng_state,
                      wprng: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand_bn_bits(N: *mut ::std::os::raw::c_void,
                        bits: ::std::os::raw::c_int, prng: *mut prng_state,
                        wprng: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand_bn_upto(N: *mut ::std::os::raw::c_void,
                        limit: *mut ::std::os::raw::c_void,
                        prng: *mut prng_state, wprng: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum public_key_algorithms { PKA_RSA = 0, PKA_DSA = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Oid {
    pub OID: [::std::os::raw::c_ulong; 16usize],
    /// Length of DER encoding
    pub OIDlen: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_Oid() {
    assert_eq!(::std::mem::size_of::<Oid>() , 136usize , concat ! (
               "Size of: " , stringify ! ( Oid ) ));
    assert_eq! (::std::mem::align_of::<Oid>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Oid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Oid ) ) . OID as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( Oid ) , "::" ,
                stringify ! ( OID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Oid ) ) . OIDlen as * const _ as usize }
                , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( Oid ) , "::" ,
                stringify ! ( OIDlen ) ));
}
impl Clone for Oid {
    fn clone(&self) -> Self { *self }
}
pub type oid_st = Oid;
extern "C" {
    pub fn pk_get_oid(pk: ::std::os::raw::c_int, st: *mut oid_st)
     -> ::std::os::raw::c_int;
}
/// RSA PKCS style key
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Rsa_key {
    /// Type of key, PK_PRIVATE or PK_PUBLIC
    pub type_: ::std::os::raw::c_int,
    /// The public exponent
    pub e: *mut ::std::os::raw::c_void,
    /// The private exponent
    pub d: *mut ::std::os::raw::c_void,
    /// The modulus
    pub N: *mut ::std::os::raw::c_void,
    /// The p factor of N
    pub p: *mut ::std::os::raw::c_void,
    /// The q factor of N
    pub q: *mut ::std::os::raw::c_void,
    /// The 1/q mod p CRT param
    pub qP: *mut ::std::os::raw::c_void,
    /// The d mod (p - 1) CRT param
    pub dP: *mut ::std::os::raw::c_void,
    /// The d mod (q - 1) CRT param
    pub dQ: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_Rsa_key() {
    assert_eq!(::std::mem::size_of::<Rsa_key>() , 72usize , concat ! (
               "Size of: " , stringify ! ( Rsa_key ) ));
    assert_eq! (::std::mem::align_of::<Rsa_key>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Rsa_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Rsa_key ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Rsa_key ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Rsa_key ) ) . e as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! ( Rsa_key ) , "::" ,
                stringify ! ( e ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Rsa_key ) ) . d as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( Rsa_key ) , "::" ,
                stringify ! ( d ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Rsa_key ) ) . N as * const _ as usize } ,
                24usize , concat ! (
                "Alignment of field: " , stringify ! ( Rsa_key ) , "::" ,
                stringify ! ( N ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Rsa_key ) ) . p as * const _ as usize } ,
                32usize , concat ! (
                "Alignment of field: " , stringify ! ( Rsa_key ) , "::" ,
                stringify ! ( p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Rsa_key ) ) . q as * const _ as usize } ,
                40usize , concat ! (
                "Alignment of field: " , stringify ! ( Rsa_key ) , "::" ,
                stringify ! ( q ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Rsa_key ) ) . qP as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( Rsa_key ) , "::" ,
                stringify ! ( qP ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Rsa_key ) ) . dP as * const _ as usize }
                , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( Rsa_key ) , "::" ,
                stringify ! ( dP ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Rsa_key ) ) . dQ as * const _ as usize }
                , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( Rsa_key ) , "::" ,
                stringify ! ( dQ ) ));
}
impl Clone for Rsa_key {
    fn clone(&self) -> Self { *self }
}
pub type rsa_key = Rsa_key;
extern "C" {
    pub fn rsa_make_key(prng: *mut prng_state, wprng: ::std::os::raw::c_int,
                        size: ::std::os::raw::c_int,
                        e: ::std::os::raw::c_long, key: *mut rsa_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rsa_get_size(key: *mut rsa_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rsa_exptmod(in_: *const ::std::os::raw::c_uchar,
                       inlen: ::std::os::raw::c_ulong,
                       out: *mut ::std::os::raw::c_uchar,
                       outlen: *mut ::std::os::raw::c_ulong,
                       which: ::std::os::raw::c_int, key: *mut rsa_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rsa_free(key: *mut rsa_key);
}
extern "C" {
    pub fn rsa_encrypt_key_ex(in_: *const ::std::os::raw::c_uchar,
                              inlen: ::std::os::raw::c_ulong,
                              out: *mut ::std::os::raw::c_uchar,
                              outlen: *mut ::std::os::raw::c_ulong,
                              lparam: *const ::std::os::raw::c_uchar,
                              lparamlen: ::std::os::raw::c_ulong,
                              prng: *mut prng_state,
                              prng_idx: ::std::os::raw::c_int,
                              hash_idx: ::std::os::raw::c_int,
                              padding: ::std::os::raw::c_int,
                              key: *mut rsa_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rsa_decrypt_key_ex(in_: *const ::std::os::raw::c_uchar,
                              inlen: ::std::os::raw::c_ulong,
                              out: *mut ::std::os::raw::c_uchar,
                              outlen: *mut ::std::os::raw::c_ulong,
                              lparam: *const ::std::os::raw::c_uchar,
                              lparamlen: ::std::os::raw::c_ulong,
                              hash_idx: ::std::os::raw::c_int,
                              padding: ::std::os::raw::c_int,
                              stat: *mut ::std::os::raw::c_int,
                              key: *mut rsa_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rsa_sign_hash_ex(in_: *const ::std::os::raw::c_uchar,
                            inlen: ::std::os::raw::c_ulong,
                            out: *mut ::std::os::raw::c_uchar,
                            outlen: *mut ::std::os::raw::c_ulong,
                            padding: ::std::os::raw::c_int,
                            prng: *mut prng_state,
                            prng_idx: ::std::os::raw::c_int,
                            hash_idx: ::std::os::raw::c_int,
                            saltlen: ::std::os::raw::c_ulong,
                            key: *mut rsa_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rsa_verify_hash_ex(sig: *const ::std::os::raw::c_uchar,
                              siglen: ::std::os::raw::c_ulong,
                              hash: *const ::std::os::raw::c_uchar,
                              hashlen: ::std::os::raw::c_ulong,
                              padding: ::std::os::raw::c_int,
                              hash_idx: ::std::os::raw::c_int,
                              saltlen: ::std::os::raw::c_ulong,
                              stat: *mut ::std::os::raw::c_int,
                              key: *mut rsa_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rsa_sign_saltlen_get_max_ex(padding: ::std::os::raw::c_int,
                                       hash_idx: ::std::os::raw::c_int,
                                       key: *mut rsa_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rsa_export(out: *mut ::std::os::raw::c_uchar,
                      outlen: *mut ::std::os::raw::c_ulong,
                      type_: ::std::os::raw::c_int, key: *mut rsa_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rsa_import(in_: *const ::std::os::raw::c_uchar,
                      inlen: ::std::os::raw::c_ulong, key: *mut rsa_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rsa_import_x509(in_: *const ::std::os::raw::c_uchar,
                           inlen: ::std::os::raw::c_ulong, key: *mut rsa_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rsa_import_pkcs8(in_: *const ::std::os::raw::c_uchar,
                            inlen: ::std::os::raw::c_ulong,
                            passwd: *const ::std::os::raw::c_void,
                            passwdlen: ::std::os::raw::c_ulong,
                            key: *mut rsa_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rsa_set_key(N: *const ::std::os::raw::c_uchar,
                       Nlen: ::std::os::raw::c_ulong,
                       e: *const ::std::os::raw::c_uchar,
                       elen: ::std::os::raw::c_ulong,
                       d: *const ::std::os::raw::c_uchar,
                       dlen: ::std::os::raw::c_ulong, key: *mut rsa_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rsa_set_factors(p: *const ::std::os::raw::c_uchar,
                           plen: ::std::os::raw::c_ulong,
                           q: *const ::std::os::raw::c_uchar,
                           qlen: ::std::os::raw::c_ulong, key: *mut rsa_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rsa_set_crt_params(dP: *const ::std::os::raw::c_uchar,
                              dPlen: ::std::os::raw::c_ulong,
                              dQ: *const ::std::os::raw::c_uchar,
                              dQlen: ::std::os::raw::c_ulong,
                              qP: *const ::std::os::raw::c_uchar,
                              qPlen: ::std::os::raw::c_ulong,
                              key: *mut rsa_key) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dh_key {
    pub type_: ::std::os::raw::c_int,
    pub x: *mut ::std::os::raw::c_void,
    pub y: *mut ::std::os::raw::c_void,
    pub base: *mut ::std::os::raw::c_void,
    pub prime: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_dh_key() {
    assert_eq!(::std::mem::size_of::<dh_key>() , 40usize , concat ! (
               "Size of: " , stringify ! ( dh_key ) ));
    assert_eq! (::std::mem::align_of::<dh_key>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( dh_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dh_key ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dh_key ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dh_key ) ) . x as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! ( dh_key ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dh_key ) ) . y as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( dh_key ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dh_key ) ) . base as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( dh_key ) , "::" ,
                stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dh_key ) ) . prime as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( dh_key ) , "::" ,
                stringify ! ( prime ) ));
}
impl Clone for dh_key {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn dh_get_groupsize(key: *mut dh_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dh_export(out: *mut ::std::os::raw::c_uchar,
                     outlen: *mut ::std::os::raw::c_ulong,
                     type_: ::std::os::raw::c_int, key: *mut dh_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dh_import(in_: *const ::std::os::raw::c_uchar,
                     inlen: ::std::os::raw::c_ulong, key: *mut dh_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dh_set_pg(p: *const ::std::os::raw::c_uchar,
                     plen: ::std::os::raw::c_ulong,
                     g: *const ::std::os::raw::c_uchar,
                     glen: ::std::os::raw::c_ulong, key: *mut dh_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dh_set_pg_dhparam(dhparam: *const ::std::os::raw::c_uchar,
                             dhparamlen: ::std::os::raw::c_ulong,
                             key: *mut dh_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dh_set_pg_groupsize(groupsize: ::std::os::raw::c_int,
                               key: *mut dh_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dh_set_key(in_: *const ::std::os::raw::c_uchar,
                      inlen: ::std::os::raw::c_ulong,
                      type_: ::std::os::raw::c_int, key: *mut dh_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dh_generate_key(prng: *mut prng_state,
                           wprng: ::std::os::raw::c_int, key: *mut dh_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dh_shared_secret(private_key: *mut dh_key, public_key: *mut dh_key,
                            out: *mut ::std::os::raw::c_uchar,
                            outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dh_free(key: *mut dh_key);
}
extern "C" {
    pub fn dh_export_key(out: *mut ::std::os::raw::c_void,
                         outlen: *mut ::std::os::raw::c_ulong,
                         type_: ::std::os::raw::c_int, key: *mut dh_key)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ltc_dh_set_type {
    pub size: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
    pub base: *const ::std::os::raw::c_char,
    pub prime: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ltc_dh_set_type() {
    assert_eq!(::std::mem::size_of::<ltc_dh_set_type>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ltc_dh_set_type ) ));
    assert_eq! (::std::mem::align_of::<ltc_dh_set_type>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ltc_dh_set_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_dh_set_type ) ) . size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_dh_set_type ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_dh_set_type ) ) . name as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_dh_set_type ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_dh_set_type ) ) . base as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_dh_set_type ) ,
                "::" , stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_dh_set_type ) ) . prime as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_dh_set_type ) ,
                "::" , stringify ! ( prime ) ));
}
impl Clone for ltc_dh_set_type {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "ltc_dh_sets"]
    pub static mut ltc_dh_sets: [ltc_dh_set_type; 0usize];
}
extern "C" {
    pub fn dh_check_pubkey(key: *mut dh_key) -> ::std::os::raw::c_int;
}
/// Structure defines a NIST GF(p) curve
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ltc_ecc_set_type {
    /// The size of the curve in octets
    pub size: ::std::os::raw::c_int,
    /// name of curve
    pub name: *const ::std::os::raw::c_char,
    /// The prime that defines the field the curve is in (encoded in hex)
    pub prime: *const ::std::os::raw::c_char,
    /// The fields B param (hex)
    pub B: *const ::std::os::raw::c_char,
    /// The order of the curve (hex)
    pub order: *const ::std::os::raw::c_char,
    /// The x co-ordinate of the base point on the curve (hex)
    pub Gx: *const ::std::os::raw::c_char,
    /// The y co-ordinate of the base point on the curve (hex)
    pub Gy: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ltc_ecc_set_type() {
    assert_eq!(::std::mem::size_of::<ltc_ecc_set_type>() , 56usize , concat !
               ( "Size of: " , stringify ! ( ltc_ecc_set_type ) ));
    assert_eq! (::std::mem::align_of::<ltc_ecc_set_type>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ltc_ecc_set_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_ecc_set_type ) ) . size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_ecc_set_type ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_ecc_set_type ) ) . name as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_ecc_set_type ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_ecc_set_type ) ) . prime as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_ecc_set_type ) ,
                "::" , stringify ! ( prime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_ecc_set_type ) ) . B as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_ecc_set_type ) ,
                "::" , stringify ! ( B ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_ecc_set_type ) ) . order as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_ecc_set_type ) ,
                "::" , stringify ! ( order ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_ecc_set_type ) ) . Gx as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_ecc_set_type ) ,
                "::" , stringify ! ( Gx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_ecc_set_type ) ) . Gy as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_ecc_set_type ) ,
                "::" , stringify ! ( Gy ) ));
}
impl Clone for ltc_ecc_set_type {
    fn clone(&self) -> Self { *self }
}
/// A point on a ECC curve, stored in Jacbobian format such that (x,y,z) => (x/z^2, y/z^3, 1) when interpretted as affine
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ecc_point {
    /// The x co-ordinate
    pub x: *mut ::std::os::raw::c_void,
    /// The y co-ordinate
    pub y: *mut ::std::os::raw::c_void,
    /// The z co-ordinate
    pub z: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ecc_point() {
    assert_eq!(::std::mem::size_of::<ecc_point>() , 24usize , concat ! (
               "Size of: " , stringify ! ( ecc_point ) ));
    assert_eq! (::std::mem::align_of::<ecc_point>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ecc_point ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ecc_point ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ecc_point ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ecc_point ) ) . y as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ecc_point ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ecc_point ) ) . z as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ecc_point ) , "::" ,
                stringify ! ( z ) ));
}
impl Clone for ecc_point {
    fn clone(&self) -> Self { *self }
}
/// An ECC key
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ecc_key {
    /// Type of key, PK_PRIVATE or PK_PUBLIC
    pub type_: ::std::os::raw::c_int,
    /// Index into the ltc_ecc_sets[] for the parameters of this curve; if -1, then this key is using user supplied curve in dp
    pub idx: ::std::os::raw::c_int,
    /// pointer to domain parameters; either points to NIST curves (identified by idx >= 0) or user supplied curve
    pub dp: *const ltc_ecc_set_type,
    /// The public key
    pub pubkey: ecc_point,
    /// The private key
    pub k: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ecc_key() {
    assert_eq!(::std::mem::size_of::<ecc_key>() , 48usize , concat ! (
               "Size of: " , stringify ! ( ecc_key ) ));
    assert_eq! (::std::mem::align_of::<ecc_key>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ecc_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ecc_key ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ecc_key ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ecc_key ) ) . idx as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ecc_key ) , "::" ,
                stringify ! ( idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ecc_key ) ) . dp as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ecc_key ) , "::" ,
                stringify ! ( dp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ecc_key ) ) . pubkey as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ecc_key ) , "::" ,
                stringify ! ( pubkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ecc_key ) ) . k as * const _ as usize } ,
                40usize , concat ! (
                "Alignment of field: " , stringify ! ( ecc_key ) , "::" ,
                stringify ! ( k ) ));
}
impl Clone for ecc_key {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "ltc_ecc_sets"]
    pub static mut ltc_ecc_sets: [ltc_ecc_set_type; 0usize];
}
extern "C" {
    pub fn ecc_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecc_sizes(low: *mut ::std::os::raw::c_int,
                     high: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn ecc_get_size(key: *mut ecc_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecc_make_key(prng: *mut prng_state, wprng: ::std::os::raw::c_int,
                        keysize: ::std::os::raw::c_int, key: *mut ecc_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecc_make_key_ex(prng: *mut prng_state,
                           wprng: ::std::os::raw::c_int, key: *mut ecc_key,
                           dp: *const ltc_ecc_set_type)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecc_free(key: *mut ecc_key);
}
extern "C" {
    pub fn ecc_export(out: *mut ::std::os::raw::c_uchar,
                      outlen: *mut ::std::os::raw::c_ulong,
                      type_: ::std::os::raw::c_int, key: *mut ecc_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecc_import(in_: *const ::std::os::raw::c_uchar,
                      inlen: ::std::os::raw::c_ulong, key: *mut ecc_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecc_import_ex(in_: *const ::std::os::raw::c_uchar,
                         inlen: ::std::os::raw::c_ulong, key: *mut ecc_key,
                         dp: *const ltc_ecc_set_type)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecc_ansi_x963_export(key: *mut ecc_key,
                                out: *mut ::std::os::raw::c_uchar,
                                outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecc_ansi_x963_import(in_: *const ::std::os::raw::c_uchar,
                                inlen: ::std::os::raw::c_ulong,
                                key: *mut ecc_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecc_ansi_x963_import_ex(in_: *const ::std::os::raw::c_uchar,
                                   inlen: ::std::os::raw::c_ulong,
                                   key: *mut ecc_key,
                                   dp: *mut ltc_ecc_set_type)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecc_shared_secret(private_key: *mut ecc_key,
                             public_key: *mut ecc_key,
                             out: *mut ::std::os::raw::c_uchar,
                             outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecc_encrypt_key(in_: *const ::std::os::raw::c_uchar,
                           inlen: ::std::os::raw::c_ulong,
                           out: *mut ::std::os::raw::c_uchar,
                           outlen: *mut ::std::os::raw::c_ulong,
                           prng: *mut prng_state,
                           wprng: ::std::os::raw::c_int,
                           hash: ::std::os::raw::c_int, key: *mut ecc_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecc_decrypt_key(in_: *const ::std::os::raw::c_uchar,
                           inlen: ::std::os::raw::c_ulong,
                           out: *mut ::std::os::raw::c_uchar,
                           outlen: *mut ::std::os::raw::c_ulong,
                           key: *mut ecc_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecc_sign_hash_rfc7518(in_: *const ::std::os::raw::c_uchar,
                                 inlen: ::std::os::raw::c_ulong,
                                 out: *mut ::std::os::raw::c_uchar,
                                 outlen: *mut ::std::os::raw::c_ulong,
                                 prng: *mut prng_state,
                                 wprng: ::std::os::raw::c_int,
                                 key: *mut ecc_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecc_sign_hash(in_: *const ::std::os::raw::c_uchar,
                         inlen: ::std::os::raw::c_ulong,
                         out: *mut ::std::os::raw::c_uchar,
                         outlen: *mut ::std::os::raw::c_ulong,
                         prng: *mut prng_state, wprng: ::std::os::raw::c_int,
                         key: *mut ecc_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecc_verify_hash_rfc7518(sig: *const ::std::os::raw::c_uchar,
                                   siglen: ::std::os::raw::c_ulong,
                                   hash: *const ::std::os::raw::c_uchar,
                                   hashlen: ::std::os::raw::c_ulong,
                                   stat: *mut ::std::os::raw::c_int,
                                   key: *mut ecc_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecc_verify_hash(sig: *const ::std::os::raw::c_uchar,
                           siglen: ::std::os::raw::c_ulong,
                           hash: *const ::std::os::raw::c_uchar,
                           hashlen: ::std::os::raw::c_ulong,
                           stat: *mut ::std::os::raw::c_int,
                           key: *mut ecc_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ltc_ecc_new_point() -> *mut ecc_point;
}
extern "C" {
    pub fn ltc_ecc_del_point(p: *mut ecc_point);
}
extern "C" {
    pub fn ltc_ecc_is_valid_idx(n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ltc_ecc_mulmod(k: *mut ::std::os::raw::c_void, G: *mut ecc_point,
                          R: *mut ecc_point,
                          modulus: *mut ::std::os::raw::c_void,
                          map: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ltc_ecc_mul2add(A: *mut ecc_point, kA: *mut ::std::os::raw::c_void,
                           B: *mut ecc_point, kB: *mut ::std::os::raw::c_void,
                           C: *mut ecc_point,
                           modulus: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ltc_ecc_map(P: *mut ecc_point,
                       modulus: *mut ::std::os::raw::c_void,
                       mp: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
/// DSA key structure
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dsa_key {
    /// The key type, PK_PRIVATE or PK_PUBLIC
    pub type_: ::std::os::raw::c_int,
    /// The order of the sub-group used in octets
    pub qord: ::std::os::raw::c_int,
    /// The generator
    pub g: *mut ::std::os::raw::c_void,
    /// The prime used to generate the sub-group
    pub q: *mut ::std::os::raw::c_void,
    /// The large prime that generats the field the contains the sub-group
    pub p: *mut ::std::os::raw::c_void,
    /// The private key
    pub x: *mut ::std::os::raw::c_void,
    /// The public key
    pub y: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_dsa_key() {
    assert_eq!(::std::mem::size_of::<dsa_key>() , 48usize , concat ! (
               "Size of: " , stringify ! ( dsa_key ) ));
    assert_eq! (::std::mem::align_of::<dsa_key>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( dsa_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dsa_key ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dsa_key ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dsa_key ) ) . qord as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( dsa_key ) , "::" ,
                stringify ! ( qord ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dsa_key ) ) . g as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! ( dsa_key ) , "::" ,
                stringify ! ( g ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dsa_key ) ) . q as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( dsa_key ) , "::" ,
                stringify ! ( q ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dsa_key ) ) . p as * const _ as usize } ,
                24usize , concat ! (
                "Alignment of field: " , stringify ! ( dsa_key ) , "::" ,
                stringify ! ( p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dsa_key ) ) . x as * const _ as usize } ,
                32usize , concat ! (
                "Alignment of field: " , stringify ! ( dsa_key ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dsa_key ) ) . y as * const _ as usize } ,
                40usize , concat ! (
                "Alignment of field: " , stringify ! ( dsa_key ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for dsa_key {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn dsa_make_key(prng: *mut prng_state, wprng: ::std::os::raw::c_int,
                        group_size: ::std::os::raw::c_int,
                        modulus_size: ::std::os::raw::c_int,
                        key: *mut dsa_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_set_pqg(p: *const ::std::os::raw::c_uchar,
                       plen: ::std::os::raw::c_ulong,
                       q: *const ::std::os::raw::c_uchar,
                       qlen: ::std::os::raw::c_ulong,
                       g: *const ::std::os::raw::c_uchar,
                       glen: ::std::os::raw::c_ulong, key: *mut dsa_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_set_pqg_dsaparam(dsaparam: *const ::std::os::raw::c_uchar,
                                dsaparamlen: ::std::os::raw::c_ulong,
                                key: *mut dsa_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_generate_pqg(prng: *mut prng_state,
                            wprng: ::std::os::raw::c_int,
                            group_size: ::std::os::raw::c_int,
                            modulus_size: ::std::os::raw::c_int,
                            key: *mut dsa_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_set_key(in_: *const ::std::os::raw::c_uchar,
                       inlen: ::std::os::raw::c_ulong,
                       type_: ::std::os::raw::c_int, key: *mut dsa_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_generate_key(prng: *mut prng_state,
                            wprng: ::std::os::raw::c_int, key: *mut dsa_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_free(key: *mut dsa_key);
}
extern "C" {
    pub fn dsa_sign_hash_raw(in_: *const ::std::os::raw::c_uchar,
                             inlen: ::std::os::raw::c_ulong,
                             r: *mut ::std::os::raw::c_void,
                             s: *mut ::std::os::raw::c_void,
                             prng: *mut prng_state,
                             wprng: ::std::os::raw::c_int, key: *mut dsa_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_sign_hash(in_: *const ::std::os::raw::c_uchar,
                         inlen: ::std::os::raw::c_ulong,
                         out: *mut ::std::os::raw::c_uchar,
                         outlen: *mut ::std::os::raw::c_ulong,
                         prng: *mut prng_state, wprng: ::std::os::raw::c_int,
                         key: *mut dsa_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_verify_hash_raw(r: *mut ::std::os::raw::c_void,
                               s: *mut ::std::os::raw::c_void,
                               hash: *const ::std::os::raw::c_uchar,
                               hashlen: ::std::os::raw::c_ulong,
                               stat: *mut ::std::os::raw::c_int,
                               key: *mut dsa_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_verify_hash(sig: *const ::std::os::raw::c_uchar,
                           siglen: ::std::os::raw::c_ulong,
                           hash: *const ::std::os::raw::c_uchar,
                           hashlen: ::std::os::raw::c_ulong,
                           stat: *mut ::std::os::raw::c_int,
                           key: *mut dsa_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_encrypt_key(in_: *const ::std::os::raw::c_uchar,
                           inlen: ::std::os::raw::c_ulong,
                           out: *mut ::std::os::raw::c_uchar,
                           outlen: *mut ::std::os::raw::c_ulong,
                           prng: *mut prng_state,
                           wprng: ::std::os::raw::c_int,
                           hash: ::std::os::raw::c_int, key: *mut dsa_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_decrypt_key(in_: *const ::std::os::raw::c_uchar,
                           inlen: ::std::os::raw::c_ulong,
                           out: *mut ::std::os::raw::c_uchar,
                           outlen: *mut ::std::os::raw::c_ulong,
                           key: *mut dsa_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_import(in_: *const ::std::os::raw::c_uchar,
                      inlen: ::std::os::raw::c_ulong, key: *mut dsa_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_export(out: *mut ::std::os::raw::c_uchar,
                      outlen: *mut ::std::os::raw::c_ulong,
                      type_: ::std::os::raw::c_int, key: *mut dsa_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_verify_key(key: *mut dsa_key, stat: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_int_validate_xy(key: *mut dsa_key,
                               stat: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_int_validate_pqg(key: *mut dsa_key,
                                stat: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_int_validate_primes(key: *mut dsa_key,
                                   stat: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dsa_shared_secret(private_key: *mut ::std::os::raw::c_void,
                             base: *mut ::std::os::raw::c_void,
                             public_key: *mut dsa_key,
                             out: *mut ::std::os::raw::c_uchar,
                             outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ltc_asn1_type_ {
    LTC_ASN1_EOL = 0,
    LTC_ASN1_BOOLEAN = 1,
    LTC_ASN1_INTEGER = 2,
    LTC_ASN1_SHORT_INTEGER = 3,
    LTC_ASN1_BIT_STRING = 4,
    LTC_ASN1_OCTET_STRING = 5,
    LTC_ASN1_NULL = 6,
    LTC_ASN1_OBJECT_IDENTIFIER = 7,
    LTC_ASN1_IA5_STRING = 8,
    LTC_ASN1_PRINTABLE_STRING = 9,
    LTC_ASN1_UTF8_STRING = 10,
    LTC_ASN1_UTCTIME = 11,
    LTC_ASN1_CHOICE = 12,
    LTC_ASN1_SEQUENCE = 13,
    LTC_ASN1_SET = 14,
    LTC_ASN1_SETOF = 15,
    LTC_ASN1_RAW_BIT_STRING = 16,
    LTC_ASN1_TELETEX_STRING = 17,
    LTC_ASN1_CONSTRUCTED = 18,
    LTC_ASN1_CONTEXT_SPECIFIC = 19,
    LTC_ASN1_GENERALIZEDTIME = 20,
}
pub use self::ltc_asn1_type_ as ltc_asn1_type;
/// A LTC ASN.1 list type
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ltc_asn1_list_ {
    /// The LTC ASN.1 enumerated type identifier
    pub type_: ltc_asn1_type,
    /// The data to encode or place for decoding
    pub data: *mut ::std::os::raw::c_void,
    /// The size of the input or resulting output
    pub size: ::std::os::raw::c_ulong,
    /// The used flag, this is used by the CHOICE ASN.1 type to indicate which choice was made
    pub used: ::std::os::raw::c_int,
    /// prev/next entry in the list
    pub prev: *mut ltc_asn1_list_,
    /// prev/next entry in the list
    pub next: *mut ltc_asn1_list_,
    /// prev/next entry in the list
    pub child: *mut ltc_asn1_list_,
    /// prev/next entry in the list
    pub parent: *mut ltc_asn1_list_,
}
#[test]
fn bindgen_test_layout_ltc_asn1_list_() {
    assert_eq!(::std::mem::size_of::<ltc_asn1_list_>() , 64usize , concat ! (
               "Size of: " , stringify ! ( ltc_asn1_list_ ) ));
    assert_eq! (::std::mem::align_of::<ltc_asn1_list_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ltc_asn1_list_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_asn1_list_ ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_asn1_list_ ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_asn1_list_ ) ) . data as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_asn1_list_ ) , "::"
                , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_asn1_list_ ) ) . size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_asn1_list_ ) , "::"
                , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_asn1_list_ ) ) . used as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_asn1_list_ ) , "::"
                , stringify ! ( used ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_asn1_list_ ) ) . prev as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_asn1_list_ ) , "::"
                , stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_asn1_list_ ) ) . next as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_asn1_list_ ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_asn1_list_ ) ) . child as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_asn1_list_ ) , "::"
                , stringify ! ( child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_asn1_list_ ) ) . parent as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_asn1_list_ ) , "::"
                , stringify ! ( parent ) ));
}
impl Clone for ltc_asn1_list_ {
    fn clone(&self) -> Self { *self }
}
pub type ltc_asn1_list = ltc_asn1_list_;
extern "C" {
    pub fn der_encode_sequence_ex(list: *mut ltc_asn1_list,
                                  inlen: ::std::os::raw::c_ulong,
                                  out: *mut ::std::os::raw::c_uchar,
                                  outlen: *mut ::std::os::raw::c_ulong,
                                  type_of: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_sequence_ex(in_: *const ::std::os::raw::c_uchar,
                                  inlen: ::std::os::raw::c_ulong,
                                  list: *mut ltc_asn1_list,
                                  outlen: ::std::os::raw::c_ulong,
                                  ordered: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_length_sequence(list: *mut ltc_asn1_list,
                               inlen: ::std::os::raw::c_ulong,
                               outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_length_sequence_ex(list: *mut ltc_asn1_list,
                                  inlen: ::std::os::raw::c_ulong,
                                  outlen: *mut ::std::os::raw::c_ulong,
                                  payloadlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_encode_subject_public_key_info(out:
                                                  *mut ::std::os::raw::c_uchar,
                                              outlen:
                                                  *mut ::std::os::raw::c_ulong,
                                              algorithm:
                                                  ::std::os::raw::c_uint,
                                              public_key:
                                                  *mut ::std::os::raw::c_void,
                                              public_key_len:
                                                  ::std::os::raw::c_ulong,
                                              parameters_type:
                                                  ::std::os::raw::c_ulong,
                                              parameters:
                                                  *mut ::std::os::raw::c_void,
                                              parameters_len:
                                                  ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_subject_public_key_info(in_:
                                                  *const ::std::os::raw::c_uchar,
                                              inlen: ::std::os::raw::c_ulong,
                                              algorithm:
                                                  ::std::os::raw::c_uint,
                                              public_key:
                                                  *mut ::std::os::raw::c_void,
                                              public_key_len:
                                                  *mut ::std::os::raw::c_ulong,
                                              parameters_type:
                                                  ::std::os::raw::c_ulong,
                                              parameters: *mut ltc_asn1_list,
                                              parameters_len:
                                                  ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_encode_set(list: *mut ltc_asn1_list,
                          inlen: ::std::os::raw::c_ulong,
                          out: *mut ::std::os::raw::c_uchar,
                          outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_encode_setof(list: *mut ltc_asn1_list,
                            inlen: ::std::os::raw::c_ulong,
                            out: *mut ::std::os::raw::c_uchar,
                            outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_encode_sequence_multi(out: *mut ::std::os::raw::c_uchar,
                                     outlen:
                                         *mut ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_sequence_multi(in_: *const ::std::os::raw::c_uchar,
                                     inlen: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_sequence_flexi(in_: *const ::std::os::raw::c_uchar,
                                     inlen: *mut ::std::os::raw::c_ulong,
                                     out: *mut *mut ltc_asn1_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_sequence_free(in_: *mut ltc_asn1_list);
}
extern "C" {
    pub fn der_sequence_shrink(in_: *mut ltc_asn1_list);
}
extern "C" {
    pub fn der_length_boolean(outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_encode_boolean(in_: ::std::os::raw::c_int,
                              out: *mut ::std::os::raw::c_uchar,
                              outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_boolean(in_: *const ::std::os::raw::c_uchar,
                              inlen: ::std::os::raw::c_ulong,
                              out: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_encode_integer(num: *mut ::std::os::raw::c_void,
                              out: *mut ::std::os::raw::c_uchar,
                              outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_integer(in_: *const ::std::os::raw::c_uchar,
                              inlen: ::std::os::raw::c_ulong,
                              num: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_length_integer(num: *mut ::std::os::raw::c_void,
                              len: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_short_integer(in_: *const ::std::os::raw::c_uchar,
                                    inlen: ::std::os::raw::c_ulong,
                                    num: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_encode_short_integer(num: ::std::os::raw::c_ulong,
                                    out: *mut ::std::os::raw::c_uchar,
                                    outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_length_short_integer(num: ::std::os::raw::c_ulong,
                                    outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_encode_bit_string(in_: *const ::std::os::raw::c_uchar,
                                 inlen: ::std::os::raw::c_ulong,
                                 out: *mut ::std::os::raw::c_uchar,
                                 outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_bit_string(in_: *const ::std::os::raw::c_uchar,
                                 inlen: ::std::os::raw::c_ulong,
                                 out: *mut ::std::os::raw::c_uchar,
                                 outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_encode_raw_bit_string(in_: *const ::std::os::raw::c_uchar,
                                     inlen: ::std::os::raw::c_ulong,
                                     out: *mut ::std::os::raw::c_uchar,
                                     outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_raw_bit_string(in_: *const ::std::os::raw::c_uchar,
                                     inlen: ::std::os::raw::c_ulong,
                                     out: *mut ::std::os::raw::c_uchar,
                                     outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_length_bit_string(nbits: ::std::os::raw::c_ulong,
                                 outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_encode_octet_string(in_: *const ::std::os::raw::c_uchar,
                                   inlen: ::std::os::raw::c_ulong,
                                   out: *mut ::std::os::raw::c_uchar,
                                   outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_octet_string(in_: *const ::std::os::raw::c_uchar,
                                   inlen: ::std::os::raw::c_ulong,
                                   out: *mut ::std::os::raw::c_uchar,
                                   outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_length_octet_string(noctets: ::std::os::raw::c_ulong,
                                   outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_encode_object_identifier(words: *mut ::std::os::raw::c_ulong,
                                        nwords: ::std::os::raw::c_ulong,
                                        out: *mut ::std::os::raw::c_uchar,
                                        outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_object_identifier(in_: *const ::std::os::raw::c_uchar,
                                        inlen: ::std::os::raw::c_ulong,
                                        words: *mut ::std::os::raw::c_ulong,
                                        outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_length_object_identifier(words: *mut ::std::os::raw::c_ulong,
                                        nwords: ::std::os::raw::c_ulong,
                                        outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_object_identifier_bits(x: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn der_encode_ia5_string(in_: *const ::std::os::raw::c_uchar,
                                 inlen: ::std::os::raw::c_ulong,
                                 out: *mut ::std::os::raw::c_uchar,
                                 outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_ia5_string(in_: *const ::std::os::raw::c_uchar,
                                 inlen: ::std::os::raw::c_ulong,
                                 out: *mut ::std::os::raw::c_uchar,
                                 outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_length_ia5_string(octets: *const ::std::os::raw::c_uchar,
                                 noctets: ::std::os::raw::c_ulong,
                                 outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_ia5_char_encode(c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_ia5_value_decode(v: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_teletex_string(in_: *const ::std::os::raw::c_uchar,
                                     inlen: ::std::os::raw::c_ulong,
                                     out: *mut ::std::os::raw::c_uchar,
                                     outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_length_teletex_string(octets: *const ::std::os::raw::c_uchar,
                                     noctets: ::std::os::raw::c_ulong,
                                     outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_teletex_char_encode(c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_teletex_value_decode(v: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_encode_printable_string(in_: *const ::std::os::raw::c_uchar,
                                       inlen: ::std::os::raw::c_ulong,
                                       out: *mut ::std::os::raw::c_uchar,
                                       outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_printable_string(in_: *const ::std::os::raw::c_uchar,
                                       inlen: ::std::os::raw::c_ulong,
                                       out: *mut ::std::os::raw::c_uchar,
                                       outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_length_printable_string(octets: *const ::std::os::raw::c_uchar,
                                       noctets: ::std::os::raw::c_ulong,
                                       outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_printable_char_encode(c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_printable_value_decode(v: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type wint_t = ::std::os::raw::c_uint;
pub type mbstate_t = __mbstate_t;
extern "C" {
    pub fn wcscpy(__dest: *mut wchar_t, __src: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(__dest: *mut wchar_t, __src: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncat(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(__s1: *const wchar_t, __s2: *const wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncmp(__s1: *const wchar_t, __s2: *const wchar_t, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp(__s1: *const wchar_t, __s2: *const wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp(__s1: *const wchar_t, __s2: *const wchar_t, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp_l(__s1: *const wchar_t, __s2: *const wchar_t,
                        __loc: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp_l(__s1: *const wchar_t, __s2: *const wchar_t,
                         __n: usize, __loc: locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscoll(__s1: *const wchar_t, __s2: *const wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize)
     -> usize;
}
extern "C" {
    pub fn wcscoll_l(__s1: *const wchar_t, __s2: *const wchar_t,
                     __loc: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm_l(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize,
                     __loc: locale_t) -> usize;
}
extern "C" {
    pub fn wcsdup(__s: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcschr(__wcs: *const wchar_t, __wc: wchar_t)
     -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsrchr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(__wcs: *const wchar_t, __reject: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcsspn(__wcs: *const wchar_t, __accept: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcspbrk(__wcs: *const wchar_t, __accept: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(__haystack: *const wchar_t, __needle: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcstok(__s: *mut wchar_t, __delim: *const wchar_t,
                  __ptr: *mut *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslen(__s: *const wchar_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcsnlen(__s: *const wchar_t, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn wmemchr(__s: *const wchar_t, __c: wchar_t, __n: usize)
     -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcmp(__s1: *const wchar_t, __s2: *const wchar_t, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wmemmove(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wmemset(__s: *mut wchar_t, __c: wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn btowc(__c: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn wctob(__c: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbsinit(__ps: *const mbstate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbrtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                   __n: usize, __p: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcrtomb(__s: *mut ::std::os::raw::c_char, __wc: wchar_t,
                   __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn __mbrlen(__s: *const ::std::os::raw::c_char, __n: usize,
                    __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbrlen(__s: *const ::std::os::raw::c_char, __n: usize,
                  __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbsrtowcs(__dst: *mut wchar_t,
                     __src: *mut *const ::std::os::raw::c_char, __len: usize,
                     __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcsrtombs(__dst: *mut ::std::os::raw::c_char,
                     __src: *mut *const wchar_t, __len: usize,
                     __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbsnrtowcs(__dst: *mut wchar_t,
                      __src: *mut *const ::std::os::raw::c_char, __nmc: usize,
                      __len: usize, __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcsnrtombs(__dst: *mut ::std::os::raw::c_char,
                      __src: *mut *const wchar_t, __nwc: usize, __len: usize,
                      __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcstod(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn wcstof(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn wcstold(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t)
     -> f64;
}
extern "C" {
    pub fn wcstol(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoll(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcpcpy(__dest: *mut wchar_t, __src: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcpncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn open_wmemstream(__bufloc: *mut *mut wchar_t, __sizeloc: *mut usize)
     -> *mut __FILE;
}
extern "C" {
    pub fn fwide(__fp: *mut __FILE, __mode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwprintf(__stream: *mut __FILE, __format: *const wchar_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wprintf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swprintf(__s: *mut wchar_t, __n: usize,
                    __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwprintf(__s: *mut __FILE, __format: *const wchar_t,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf(__format: *const wchar_t, __arg: *mut __va_list_tag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf(__s: *mut wchar_t, __n: usize, __format: *const wchar_t,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf(__stream: *mut __FILE, __format: *const wchar_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf(__s: *const wchar_t, __format: *const wchar_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const wchar_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_wscanf"]
    pub fn wscanf1(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_swscanf"]
    pub fn swscanf1(__s: *const wchar_t, __format: *const wchar_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwscanf(__s: *mut __FILE, __format: *const wchar_t,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwscanf(__format: *const wchar_t, __arg: *mut __va_list_tag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswscanf(__s: *const wchar_t, __format: *const wchar_t,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfwscanf"]
    pub fn vfwscanf1(__s: *mut __FILE, __format: *const wchar_t,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vwscanf"]
    pub fn vwscanf1(__format: *const wchar_t, __arg: *mut __va_list_tag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vswscanf"]
    pub fn vswscanf1(__s: *const wchar_t, __format: *const wchar_t,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(__wc: wchar_t) -> wint_t;
}
extern "C" {
    pub fn fgetws(__ws: *mut wchar_t, __n: ::std::os::raw::c_int,
                  __stream: *mut __FILE) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(__ws: *const wchar_t, __stream: *mut __FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn wcsftime(__s: *mut wchar_t, __maxsize: usize,
                    __format: *const wchar_t, __tp: *const tm) -> usize;
}
extern "C" {
    pub fn der_encode_utf8_string(in_: *const wchar_t,
                                  inlen: ::std::os::raw::c_ulong,
                                  out: *mut ::std::os::raw::c_uchar,
                                  outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_utf8_string(in_: *const ::std::os::raw::c_uchar,
                                  inlen: ::std::os::raw::c_ulong,
                                  out: *mut wchar_t,
                                  outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_utf8_charsize(c: wchar_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn der_utf8_valid_char(c: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_length_utf8_string(in_: *const wchar_t,
                                  noctets: ::std::os::raw::c_ulong,
                                  outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_choice(in_: *const ::std::os::raw::c_uchar,
                             inlen: *mut ::std::os::raw::c_ulong,
                             list: *mut ltc_asn1_list,
                             outlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ltc_utctime {
    pub YY: ::std::os::raw::c_uint,
    pub MM: ::std::os::raw::c_uint,
    pub DD: ::std::os::raw::c_uint,
    pub hh: ::std::os::raw::c_uint,
    pub mm: ::std::os::raw::c_uint,
    pub ss: ::std::os::raw::c_uint,
    pub off_dir: ::std::os::raw::c_uint,
    pub off_hh: ::std::os::raw::c_uint,
    pub off_mm: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ltc_utctime() {
    assert_eq!(::std::mem::size_of::<ltc_utctime>() , 36usize , concat ! (
               "Size of: " , stringify ! ( ltc_utctime ) ));
    assert_eq! (::std::mem::align_of::<ltc_utctime>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ltc_utctime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_utctime ) ) . YY as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_utctime ) , "::" ,
                stringify ! ( YY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_utctime ) ) . MM as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_utctime ) , "::" ,
                stringify ! ( MM ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_utctime ) ) . DD as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_utctime ) , "::" ,
                stringify ! ( DD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_utctime ) ) . hh as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_utctime ) , "::" ,
                stringify ! ( hh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_utctime ) ) . mm as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_utctime ) , "::" ,
                stringify ! ( mm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_utctime ) ) . ss as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_utctime ) , "::" ,
                stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_utctime ) ) . off_dir as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_utctime ) , "::" ,
                stringify ! ( off_dir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_utctime ) ) . off_hh as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_utctime ) , "::" ,
                stringify ! ( off_hh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_utctime ) ) . off_mm as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_utctime ) , "::" ,
                stringify ! ( off_mm ) ));
}
impl Clone for ltc_utctime {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn der_encode_utctime(utctime: *mut ltc_utctime,
                              out: *mut ::std::os::raw::c_uchar,
                              outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_utctime(in_: *const ::std::os::raw::c_uchar,
                              inlen: *mut ::std::os::raw::c_ulong,
                              out: *mut ltc_utctime) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_length_utctime(utctime: *mut ltc_utctime,
                              outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ltc_generalizedtime {
    pub YYYY: ::std::os::raw::c_uint,
    pub MM: ::std::os::raw::c_uint,
    pub DD: ::std::os::raw::c_uint,
    pub hh: ::std::os::raw::c_uint,
    pub mm: ::std::os::raw::c_uint,
    pub ss: ::std::os::raw::c_uint,
    pub fs: ::std::os::raw::c_uint,
    pub off_dir: ::std::os::raw::c_uint,
    pub off_hh: ::std::os::raw::c_uint,
    pub off_mm: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ltc_generalizedtime() {
    assert_eq!(::std::mem::size_of::<ltc_generalizedtime>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( ltc_generalizedtime ) ));
    assert_eq! (::std::mem::align_of::<ltc_generalizedtime>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( ltc_generalizedtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_generalizedtime ) ) . YYYY as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_generalizedtime ) ,
                "::" , stringify ! ( YYYY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_generalizedtime ) ) . MM as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_generalizedtime ) ,
                "::" , stringify ! ( MM ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_generalizedtime ) ) . DD as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_generalizedtime ) ,
                "::" , stringify ! ( DD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_generalizedtime ) ) . hh as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_generalizedtime ) ,
                "::" , stringify ! ( hh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_generalizedtime ) ) . mm as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_generalizedtime ) ,
                "::" , stringify ! ( mm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_generalizedtime ) ) . ss as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_generalizedtime ) ,
                "::" , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_generalizedtime ) ) . fs as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_generalizedtime ) ,
                "::" , stringify ! ( fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_generalizedtime ) ) . off_dir as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_generalizedtime ) ,
                "::" , stringify ! ( off_dir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_generalizedtime ) ) . off_hh as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_generalizedtime ) ,
                "::" , stringify ! ( off_hh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_generalizedtime ) ) . off_mm as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_generalizedtime ) ,
                "::" , stringify ! ( off_mm ) ));
}
impl Clone for ltc_generalizedtime {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn der_encode_generalizedtime(gtime: *mut ltc_generalizedtime,
                                      out: *mut ::std::os::raw::c_uchar,
                                      outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_decode_generalizedtime(in_: *const ::std::os::raw::c_uchar,
                                      inlen: *mut ::std::os::raw::c_ulong,
                                      out: *mut ltc_generalizedtime)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn der_length_generalizedtime(gtime: *mut ltc_generalizedtime,
                                      outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn radix_to_bin(in_: *const ::std::os::raw::c_void,
                        radix: ::std::os::raw::c_int,
                        out: *mut ::std::os::raw::c_void,
                        len: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
/// math descriptor
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ltc_math_descriptor {
    /// Name of the math provider
    pub name: *const ::std::os::raw::c_char,
    /// Bits per digit, amount of bits must fit in an unsigned long
    pub bits_per_digit: ::std::os::raw::c_int,
    /// initialize a bignum
    /// @param   a     The number to initialize
    /// @return  CRYPT_OK on success
    pub init: ::std::option::Option<unsafe extern "C" fn(a:
                                                             *mut *mut ::std::os::raw::c_void)
                                        -> ::std::os::raw::c_int>,
    /// init copy
    /// @param  dst    The number to initialize and write to
    /// @param  src    The number to copy from
    /// @return CRYPT_OK on success
    pub init_copy: ::std::option::Option<unsafe extern "C" fn(dst:
                                                                  *mut *mut ::std::os::raw::c_void,
                                                              src:
                                                                  *mut ::std::os::raw::c_void)
                                             -> ::std::os::raw::c_int>,
    /// deinit
    /// @param   a    The number to free
    /// @return CRYPT_OK on success
    pub deinit: ::std::option::Option<unsafe extern "C" fn(a:
                                                               *mut ::std::os::raw::c_void)>,
    /// negate
    /// @param   src   The number to negate
    /// @param   dst   The destination
    /// @return CRYPT_OK on success
    pub neg: ::std::option::Option<unsafe extern "C" fn(src:
                                                            *mut ::std::os::raw::c_void,
                                                        dst:
                                                            *mut ::std::os::raw::c_void)
                                       -> ::std::os::raw::c_int>,
    /// copy
    /// @param   src   The number to copy from
    /// @param   dst   The number to write to
    /// @return CRYPT_OK on success
    pub copy: ::std::option::Option<unsafe extern "C" fn(src:
                                                             *mut ::std::os::raw::c_void,
                                                         dst:
                                                             *mut ::std::os::raw::c_void)
                                        -> ::std::os::raw::c_int>,
    /// set small constant
    /// @param a    Number to write to
    /// @param n    Source upto bits_per_digit (actually meant for very small constants)
    /// @return CRYPT_OK on success
    pub set_int: ::std::option::Option<unsafe extern "C" fn(a:
                                                                *mut ::std::os::raw::c_void,
                                                            n: ltc_mp_digit)
                                           -> ::std::os::raw::c_int>,
    /// get small constant
    /// @param a  Small number to read,
    /// only fetches up to bits_per_digit from the number
    /// @return   The lower bits_per_digit of the integer (unsigned)
    pub get_int: ::std::option::Option<unsafe extern "C" fn(a:
                                                                *mut ::std::os::raw::c_void)
                                           -> ::std::os::raw::c_ulong>,
    /// get digit n
    /// @param a  The number to read from
    /// @param n  The number of the digit to fetch
    /// @return  The bits_per_digit  sized n'th digit of a
    pub get_digit: ::std::option::Option<unsafe extern "C" fn(a:
                                                                  *mut ::std::os::raw::c_void,
                                                              n:
                                                                  ::std::os::raw::c_int)
                                             -> ltc_mp_digit>,
    /// Get the number of digits that represent the number
    /// @param a   The number to count
    /// @return The number of digits used to represent the number
    pub get_digit_count: ::std::option::Option<unsafe extern "C" fn(a:
                                                                        *mut ::std::os::raw::c_void)
                                                   -> ::std::os::raw::c_int>,
    /// compare two integers
    /// @param a   The left side integer
    /// @param b   The right side integer
    /// @return LTC_MP_LT if a < b,
    /// LTC_MP_GT if a > b and
    /// LTC_MP_EQ otherwise.  (signed comparison)
    pub compare: ::std::option::Option<unsafe extern "C" fn(a:
                                                                *mut ::std::os::raw::c_void,
                                                            b:
                                                                *mut ::std::os::raw::c_void)
                                           -> ::std::os::raw::c_int>,
    /// compare against int
    /// @param a   The left side integer
    /// @param b   The right side integer (upto bits_per_digit)
    /// @return LTC_MP_LT if a < b,
    /// LTC_MP_GT if a > b and
    /// LTC_MP_EQ otherwise.  (signed comparison)
    pub compare_d: ::std::option::Option<unsafe extern "C" fn(a:
                                                                  *mut ::std::os::raw::c_void,
                                                              n: ltc_mp_digit)
                                             -> ::std::os::raw::c_int>,
    /// Count the number of bits used to represent the integer
    /// @param a   The integer to count
    /// @return The number of bits required to represent the integer
    pub count_bits: ::std::option::Option<unsafe extern "C" fn(a:
                                                                   *mut ::std::os::raw::c_void)
                                              -> ::std::os::raw::c_int>,
    /// Count the number of LSB bits which are zero
    /// @param a   The integer to count
    /// @return The number of contiguous zero LSB bits
    pub count_lsb_bits: ::std::option::Option<unsafe extern "C" fn(a:
                                                                       *mut ::std::os::raw::c_void)
                                                  -> ::std::os::raw::c_int>,
    /// Compute a power of two
    /// @param a  The integer to store the power in
    /// @param n  The power of two you want to store (a = 2^n)
    /// @return CRYPT_OK on success
    pub twoexpt: ::std::option::Option<unsafe extern "C" fn(a:
                                                                *mut ::std::os::raw::c_void,
                                                            n:
                                                                ::std::os::raw::c_int)
                                           -> ::std::os::raw::c_int>,
    /// read ascii string
    /// @param a     The integer to store into
    /// @param str   The string to read
    /// @param radix The radix the integer has been represented in (2-64)
    /// @return CRYPT_OK on success
    pub read_radix: ::std::option::Option<unsafe extern "C" fn(a:
                                                                   *mut ::std::os::raw::c_void,
                                                               str:
                                                                   *const ::std::os::raw::c_char,
                                                               radix:
                                                                   ::std::os::raw::c_int)
                                              -> ::std::os::raw::c_int>,
    /// write number to string
    /// @param a     The integer to store
    /// @param str   The destination for the string
    /// @param radix The radix the integer is to be represented in (2-64)
    /// @return CRYPT_OK on success
    pub write_radix: ::std::option::Option<unsafe extern "C" fn(a:
                                                                    *mut ::std::os::raw::c_void,
                                                                str:
                                                                    *mut ::std::os::raw::c_char,
                                                                radix:
                                                                    ::std::os::raw::c_int)
                                               -> ::std::os::raw::c_int>,
    /// get size as unsigned char string
    /// @param a  The integer to get the size (when stored in array of octets)
    /// @return   The length of the integer in octets
    pub unsigned_size: ::std::option::Option<unsafe extern "C" fn(a:
                                                                      *mut ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_ulong>,
    /// store an integer as an array of octets
    /// @param src   The integer to store
    /// @param dst   The buffer to store the integer in
    /// @return CRYPT_OK on success
    pub unsigned_write: ::std::option::Option<unsafe extern "C" fn(src:
                                                                       *mut ::std::os::raw::c_void,
                                                                   dst:
                                                                       *mut ::std::os::raw::c_uchar)
                                                  -> ::std::os::raw::c_int>,
    /// read an array of octets and store as integer
    /// @param dst   The integer to load
    /// @param src   The array of octets
    /// @param len   The number of octets
    /// @return CRYPT_OK on success
    pub unsigned_read: ::std::option::Option<unsafe extern "C" fn(dst:
                                                                      *mut ::std::os::raw::c_void,
                                                                  src:
                                                                      *mut ::std::os::raw::c_uchar,
                                                                  len:
                                                                      ::std::os::raw::c_ulong)
                                                 -> ::std::os::raw::c_int>,
    /// add two integers
    /// @param a   The first source integer
    /// @param b   The second source integer
    /// @param c   The destination of "a + b"
    /// @return CRYPT_OK on success
    pub add: ::std::option::Option<unsafe extern "C" fn(a:
                                                            *mut ::std::os::raw::c_void,
                                                        b:
                                                            *mut ::std::os::raw::c_void,
                                                        c:
                                                            *mut ::std::os::raw::c_void)
                                       -> ::std::os::raw::c_int>,
    /// add two integers
    /// @param a   The first source integer
    /// @param b   The second source integer
    /// (single digit of upto bits_per_digit in length)
    /// @param c   The destination of "a + b"
    /// @return CRYPT_OK on success
    pub addi: ::std::option::Option<unsafe extern "C" fn(a:
                                                             *mut ::std::os::raw::c_void,
                                                         b: ltc_mp_digit,
                                                         c:
                                                             *mut ::std::os::raw::c_void)
                                        -> ::std::os::raw::c_int>,
    /// subtract two integers
    /// @param a   The first source integer
    /// @param b   The second source integer
    /// @param c   The destination of "a - b"
    /// @return CRYPT_OK on success
    pub sub: ::std::option::Option<unsafe extern "C" fn(a:
                                                            *mut ::std::os::raw::c_void,
                                                        b:
                                                            *mut ::std::os::raw::c_void,
                                                        c:
                                                            *mut ::std::os::raw::c_void)
                                       -> ::std::os::raw::c_int>,
    /// subtract two integers
    /// @param a   The first source integer
    /// @param b   The second source integer
    /// (single digit of upto bits_per_digit in length)
    /// @param c   The destination of "a - b"
    /// @return CRYPT_OK on success
    pub subi: ::std::option::Option<unsafe extern "C" fn(a:
                                                             *mut ::std::os::raw::c_void,
                                                         b: ltc_mp_digit,
                                                         c:
                                                             *mut ::std::os::raw::c_void)
                                        -> ::std::os::raw::c_int>,
    /// multiply two integers
    /// @param a   The first source integer
    /// @param b   The second source integer
    /// (single digit of upto bits_per_digit in length)
    /// @param c   The destination of "a * b"
    /// @return CRYPT_OK on success
    pub mul: ::std::option::Option<unsafe extern "C" fn(a:
                                                            *mut ::std::os::raw::c_void,
                                                        b:
                                                            *mut ::std::os::raw::c_void,
                                                        c:
                                                            *mut ::std::os::raw::c_void)
                                       -> ::std::os::raw::c_int>,
    /// multiply two integers
    /// @param a   The first source integer
    /// @param b   The second source integer
    /// (single digit of upto bits_per_digit in length)
    /// @param c   The destination of "a * b"
    /// @return CRYPT_OK on success
    pub muli: ::std::option::Option<unsafe extern "C" fn(a:
                                                             *mut ::std::os::raw::c_void,
                                                         b: ltc_mp_digit,
                                                         c:
                                                             *mut ::std::os::raw::c_void)
                                        -> ::std::os::raw::c_int>,
    /// Square an integer
    /// @param a    The integer to square
    /// @param b    The destination
    /// @return CRYPT_OK on success
    pub sqr: ::std::option::Option<unsafe extern "C" fn(a:
                                                            *mut ::std::os::raw::c_void,
                                                        b:
                                                            *mut ::std::os::raw::c_void)
                                       -> ::std::os::raw::c_int>,
    /// Divide an integer
    /// @param a    The dividend
    /// @param b    The divisor
    /// @param c    The quotient (can be NULL to signify don't care)
    /// @param d    The remainder (can be NULL to signify don't care)
    /// @return CRYPT_OK on success
    pub mpdiv: ::std::option::Option<unsafe extern "C" fn(a:
                                                              *mut ::std::os::raw::c_void,
                                                          b:
                                                              *mut ::std::os::raw::c_void,
                                                          c:
                                                              *mut ::std::os::raw::c_void,
                                                          d:
                                                              *mut ::std::os::raw::c_void)
                                         -> ::std::os::raw::c_int>,
    /// divide by two
    /// @param  a   The integer to divide (shift right)
    /// @param  b   The destination
    /// @return CRYPT_OK on success
    pub div_2: ::std::option::Option<unsafe extern "C" fn(a:
                                                              *mut ::std::os::raw::c_void,
                                                          b:
                                                              *mut ::std::os::raw::c_void)
                                         -> ::std::os::raw::c_int>,
    /// Get remainder (small value)
    /// @param  a    The integer to reduce
    /// @param  b    The modulus (upto bits_per_digit in length)
    /// @param  c    The destination for the residue
    /// @return CRYPT_OK on success
    pub modi: ::std::option::Option<unsafe extern "C" fn(a:
                                                             *mut ::std::os::raw::c_void,
                                                         b: ltc_mp_digit,
                                                         c: *mut ltc_mp_digit)
                                        -> ::std::os::raw::c_int>,
    /// gcd
    /// @param  a     The first integer
    /// @param  b     The second integer
    /// @param  c     The destination for (a, b)
    /// @return CRYPT_OK on success
    pub gcd: ::std::option::Option<unsafe extern "C" fn(a:
                                                            *mut ::std::os::raw::c_void,
                                                        b:
                                                            *mut ::std::os::raw::c_void,
                                                        c:
                                                            *mut ::std::os::raw::c_void)
                                       -> ::std::os::raw::c_int>,
    /// lcm
    /// @param  a     The first integer
    /// @param  b     The second integer
    /// @param  c     The destination for [a, b]
    /// @return CRYPT_OK on success
    pub lcm: ::std::option::Option<unsafe extern "C" fn(a:
                                                            *mut ::std::os::raw::c_void,
                                                        b:
                                                            *mut ::std::os::raw::c_void,
                                                        c:
                                                            *mut ::std::os::raw::c_void)
                                       -> ::std::os::raw::c_int>,
    /// Modular multiplication
    /// @param  a     The first source
    /// @param  b     The second source
    /// @param  c     The modulus
    /// @param  d     The destination (a*b mod c)
    /// @return CRYPT_OK on success
    pub mulmod: ::std::option::Option<unsafe extern "C" fn(a:
                                                               *mut ::std::os::raw::c_void,
                                                           b:
                                                               *mut ::std::os::raw::c_void,
                                                           c:
                                                               *mut ::std::os::raw::c_void,
                                                           d:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    /// Modular squaring
    /// @param  a     The first source
    /// @param  b     The modulus
    /// @param  c     The destination (a*a mod b)
    /// @return CRYPT_OK on success
    pub sqrmod: ::std::option::Option<unsafe extern "C" fn(a:
                                                               *mut ::std::os::raw::c_void,
                                                           b:
                                                               *mut ::std::os::raw::c_void,
                                                           c:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    /// Modular inversion
    /// @param  a     The value to invert
    /// @param  b     The modulus
    /// @param  c     The destination (1/a mod b)
    /// @return CRYPT_OK on success
    pub invmod: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void,
                                                           arg2:
                                                               *mut ::std::os::raw::c_void,
                                                           arg3:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    /// setup Montgomery
    /// @param a  The modulus
    /// @param b  The destination for the reduction digit
    /// @return CRYPT_OK on success
    pub montgomery_setup: ::std::option::Option<unsafe extern "C" fn(a:
                                                                         *mut ::std::os::raw::c_void,
                                                                     b:
                                                                         *mut *mut ::std::os::raw::c_void)
                                                    -> ::std::os::raw::c_int>,
    /// get normalization value
    /// @param a   The destination for the normalization value
    /// @param b   The modulus
    /// @return  CRYPT_OK on success
    pub montgomery_normalization: ::std::option::Option<unsafe extern "C" fn(a:
                                                                                 *mut ::std::os::raw::c_void,
                                                                             b:
                                                                                 *mut ::std::os::raw::c_void)
                                                            ->
                                                                ::std::os::raw::c_int>,
    /// reduce a number
    /// @param a   The number [and dest] to reduce
    /// @param b   The modulus
    /// @param c   The value "b" from montgomery_setup()
    /// @return CRYPT_OK on success
    pub montgomery_reduce: ::std::option::Option<unsafe extern "C" fn(a:
                                                                          *mut ::std::os::raw::c_void,
                                                                      b:
                                                                          *mut ::std::os::raw::c_void,
                                                                      c:
                                                                          *mut ::std::os::raw::c_void)
                                                     ->
                                                         ::std::os::raw::c_int>,
    /// clean up  (frees memory)
    /// @param a   The value "b" from montgomery_setup()
    /// @return CRYPT_OK on success
    pub montgomery_deinit: ::std::option::Option<unsafe extern "C" fn(a:
                                                                          *mut ::std::os::raw::c_void)>,
    /// Modular exponentiation
    /// @param a    The base integer
    /// @param b    The power (can be negative) integer
    /// @param c    The modulus integer
    /// @param d    The destination
    /// @return CRYPT_OK on success
    pub exptmod: ::std::option::Option<unsafe extern "C" fn(a:
                                                                *mut ::std::os::raw::c_void,
                                                            b:
                                                                *mut ::std::os::raw::c_void,
                                                            c:
                                                                *mut ::std::os::raw::c_void,
                                                            d:
                                                                *mut ::std::os::raw::c_void)
                                           -> ::std::os::raw::c_int>,
    /// Primality testing
    /// @param a     The integer to test
    /// @param b     The number of Miller-Rabin tests that shall be executed
    /// @param c     The destination of the result (FP_YES if prime)
    /// @return CRYPT_OK on success
    pub isprime: ::std::option::Option<unsafe extern "C" fn(a:
                                                                *mut ::std::os::raw::c_void,
                                                            b:
                                                                ::std::os::raw::c_int,
                                                            c:
                                                                *mut ::std::os::raw::c_int)
                                           -> ::std::os::raw::c_int>,
    /// ECC GF(p) point multiplication (from the NIST curves)
    /// @param k   The integer to multiply the point by
    /// @param G   The point to multiply
    /// @param R   The destination for kG
    /// @param modulus  The modulus for the field
    /// @param map Boolean indicated whether to map back to affine or not
    /// (can be ignored if you work in affine only)
    /// @return CRYPT_OK on success
    pub ecc_ptmul: ::std::option::Option<unsafe extern "C" fn(k:
                                                                  *mut ::std::os::raw::c_void,
                                                              G:
                                                                  *mut ecc_point,
                                                              R:
                                                                  *mut ecc_point,
                                                              modulus:
                                                                  *mut ::std::os::raw::c_void,
                                                              map:
                                                                  ::std::os::raw::c_int)
                                             -> ::std::os::raw::c_int>,
    /// ECC GF(p) point addition
    /// @param P    The first point
    /// @param Q    The second point
    /// @param R    The destination of P + Q
    /// @param modulus  The modulus
    /// @param mp   The "b" value from montgomery_setup()
    /// @return CRYPT_OK on success
    pub ecc_ptadd: ::std::option::Option<unsafe extern "C" fn(P:
                                                                  *mut ecc_point,
                                                              Q:
                                                                  *mut ecc_point,
                                                              R:
                                                                  *mut ecc_point,
                                                              modulus:
                                                                  *mut ::std::os::raw::c_void,
                                                              mp:
                                                                  *mut ::std::os::raw::c_void)
                                             -> ::std::os::raw::c_int>,
    /// ECC GF(p) point double
    /// @param P    The first point
    /// @param R    The destination of 2P
    /// @param modulus  The modulus
    /// @param mp   The "b" value from montgomery_setup()
    /// @return CRYPT_OK on success
    pub ecc_ptdbl: ::std::option::Option<unsafe extern "C" fn(P:
                                                                  *mut ecc_point,
                                                              R:
                                                                  *mut ecc_point,
                                                              modulus:
                                                                  *mut ::std::os::raw::c_void,
                                                              mp:
                                                                  *mut ::std::os::raw::c_void)
                                             -> ::std::os::raw::c_int>,
    /// ECC mapping from projective to affine,
    /// currently uses (x,y,z) => (x/z^2, y/z^3, 1)
    /// @param P     The point to map
    /// @param modulus The modulus
    /// @param mp    The "b" value from montgomery_setup()
    /// @return CRYPT_OK on success
    /// @remark The mapping can be different but keep in mind a
    /// ecc_point only has three integers (x,y,z) so if
    /// you use a different mapping you have to make it fit.
    pub ecc_map: ::std::option::Option<unsafe extern "C" fn(P: *mut ecc_point,
                                                            modulus:
                                                                *mut ::std::os::raw::c_void,
                                                            mp:
                                                                *mut ::std::os::raw::c_void)
                                           -> ::std::os::raw::c_int>,
    /// Computes kA*A + kB*B = C using Shamir's Trick
    /// @param A        First point to multiply
    /// @param kA       What to multiple A by
    /// @param B        Second point to multiply
    /// @param kB       What to multiple B by
    /// @param C        [out] Destination point (can overlap with A or B)
    /// @param modulus  Modulus for curve
    /// @return CRYPT_OK on success
    pub ecc_mul2add: ::std::option::Option<unsafe extern "C" fn(A:
                                                                    *mut ecc_point,
                                                                kA:
                                                                    *mut ::std::os::raw::c_void,
                                                                B:
                                                                    *mut ecc_point,
                                                                kB:
                                                                    *mut ::std::os::raw::c_void,
                                                                C:
                                                                    *mut ecc_point,
                                                                modulus:
                                                                    *mut ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>,
    /// RSA Key Generation
    /// @param prng     An active PRNG state
    /// @param wprng    The index of the PRNG desired
    /// @param size     The size of the key in octets
    /// @param e        The "e" value (public key).
    /// e==65537 is a good choice
    /// @param key      [out] Destination of a newly created private key pair
    /// @return CRYPT_OK if successful, upon error all allocated ram is freed
    pub rsa_keygen: ::std::option::Option<unsafe extern "C" fn(prng:
                                                                   *mut prng_state,
                                                               wprng:
                                                                   ::std::os::raw::c_int,
                                                               size:
                                                                   ::std::os::raw::c_int,
                                                               e:
                                                                   ::std::os::raw::c_long,
                                                               key:
                                                                   *mut rsa_key)
                                              -> ::std::os::raw::c_int>,
    /// RSA exponentiation
    /// @param in       The octet array representing the base
    /// @param inlen    The length of the input
    /// @param out      The destination (to be stored in an octet array format)
    /// @param outlen   The length of the output buffer and the resulting size
    /// (zero padded to the size of the modulus)
    /// @param which    PK_PUBLIC for public RSA and PK_PRIVATE for private RSA
    /// @param key      The RSA key to use
    /// @return CRYPT_OK on success
    pub rsa_me: ::std::option::Option<unsafe extern "C" fn(in_:
                                                               *const ::std::os::raw::c_uchar,
                                                           inlen:
                                                               ::std::os::raw::c_ulong,
                                                           out:
                                                               *mut ::std::os::raw::c_uchar,
                                                           outlen:
                                                               *mut ::std::os::raw::c_ulong,
                                                           which:
                                                               ::std::os::raw::c_int,
                                                           key: *mut rsa_key)
                                          -> ::std::os::raw::c_int>,
    /// Modular addition
    /// @param  a     The first source
    /// @param  b     The second source
    /// @param  c     The modulus
    /// @param  d     The destination (a + b mod c)
    /// @return CRYPT_OK on success
    pub addmod: ::std::option::Option<unsafe extern "C" fn(a:
                                                               *mut ::std::os::raw::c_void,
                                                           b:
                                                               *mut ::std::os::raw::c_void,
                                                           c:
                                                               *mut ::std::os::raw::c_void,
                                                           d:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    /// Modular substraction
    /// @param  a     The first source
    /// @param  b     The second source
    /// @param  c     The modulus
    /// @param  d     The destination (a - b mod c)
    /// @return CRYPT_OK on success
    pub submod: ::std::option::Option<unsafe extern "C" fn(a:
                                                               *mut ::std::os::raw::c_void,
                                                           b:
                                                               *mut ::std::os::raw::c_void,
                                                           c:
                                                               *mut ::std::os::raw::c_void,
                                                           d:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    /// Make a pseudo-random mpi
    /// @param  a     The mpi to make random
    /// @param  size  The desired length
    /// @return CRYPT_OK on success
    pub rand: ::std::option::Option<unsafe extern "C" fn(a:
                                                             *mut ::std::os::raw::c_void,
                                                         size:
                                                             ::std::os::raw::c_int)
                                        -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_ltc_math_descriptor() {
    assert_eq!(::std::mem::size_of::<ltc_math_descriptor>() , 416usize ,
               concat ! ( "Size of: " , stringify ! ( ltc_math_descriptor )
               ));
    assert_eq! (::std::mem::align_of::<ltc_math_descriptor>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ltc_math_descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . bits_per_digit
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( bits_per_digit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . init as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . init_copy as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( init_copy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . deinit as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( deinit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . neg as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( neg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . copy as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( copy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . set_int as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( set_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . get_int as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( get_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . get_digit as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( get_digit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . get_digit_count
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( get_digit_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . compare as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( compare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . compare_d as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( compare_d ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . count_bits as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( count_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . count_lsb_bits
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( count_lsb_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . twoexpt as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( twoexpt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . read_radix as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( read_radix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . write_radix as
                * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( write_radix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . unsigned_size
                as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( unsigned_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . unsigned_write
                as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( unsigned_write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . unsigned_read
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( unsigned_read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . add as * const
                _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( add ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . addi as * const
                _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( addi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . sub as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( sub ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . subi as * const
                _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( subi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . mul as * const
                _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( mul ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . muli as * const
                _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( muli ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . sqr as * const
                _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( sqr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . mpdiv as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( mpdiv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . div_2 as *
                const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( div_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . modi as * const
                _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( modi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . gcd as * const
                _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( gcd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . lcm as * const
                _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( lcm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . mulmod as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( mulmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . sqrmod as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( sqrmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . invmod as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( invmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) .
                montgomery_setup as * const _ as usize } , 288usize , concat !
                (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( montgomery_setup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) .
                montgomery_normalization as * const _ as usize } , 296usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( montgomery_normalization ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) .
                montgomery_reduce as * const _ as usize } , 304usize , concat
                ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( montgomery_reduce ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) .
                montgomery_deinit as * const _ as usize } , 312usize , concat
                ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( montgomery_deinit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . exptmod as *
                const _ as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( exptmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . isprime as *
                const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( isprime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . ecc_ptmul as *
                const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( ecc_ptmul ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . ecc_ptadd as *
                const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( ecc_ptadd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . ecc_ptdbl as *
                const _ as usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( ecc_ptdbl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . ecc_map as *
                const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( ecc_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . ecc_mul2add as
                * const _ as usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( ecc_mul2add ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . rsa_keygen as *
                const _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( rsa_keygen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . rsa_me as *
                const _ as usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( rsa_me ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . addmod as *
                const _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( addmod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . submod as *
                const _ as usize } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( submod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ltc_math_descriptor ) ) . rand as * const
                _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( ltc_math_descriptor ) ,
                "::" , stringify ! ( rand ) ));
}
impl Clone for ltc_math_descriptor {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "ltc_mp"]
    pub static mut ltc_mp: ltc_math_descriptor;
}
extern "C" {
    pub fn ltc_init_multi(a: *mut *mut ::std::os::raw::c_void, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ltc_deinit_multi(a: *mut ::std::os::raw::c_void, ...);
}
extern "C" {
    pub fn ltc_cleanup_multi(a: *mut *mut ::std::os::raw::c_void, ...);
}
extern "C" {
    #[link_name = "tfm_desc"]
    pub static tfm_desc: ltc_math_descriptor;
}
extern "C" {
    pub fn base64_encode(in_: *const ::std::os::raw::c_uchar,
                         len: ::std::os::raw::c_ulong,
                         out: *mut ::std::os::raw::c_uchar,
                         outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn base64_decode(in_: *const ::std::os::raw::c_uchar,
                         len: ::std::os::raw::c_ulong,
                         out: *mut ::std::os::raw::c_uchar,
                         outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn base64_strict_decode(in_: *const ::std::os::raw::c_uchar,
                                len: ::std::os::raw::c_ulong,
                                out: *mut ::std::os::raw::c_uchar,
                                outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn base64url_encode(in_: *const ::std::os::raw::c_uchar,
                            len: ::std::os::raw::c_ulong,
                            out: *mut ::std::os::raw::c_uchar,
                            outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn base64url_strict_encode(in_: *const ::std::os::raw::c_uchar,
                                   inlen: ::std::os::raw::c_ulong,
                                   out: *mut ::std::os::raw::c_uchar,
                                   outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn base64url_decode(in_: *const ::std::os::raw::c_uchar,
                            len: ::std::os::raw::c_ulong,
                            out: *mut ::std::os::raw::c_uchar,
                            outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn base64url_strict_decode(in_: *const ::std::os::raw::c_uchar,
                                   len: ::std::os::raw::c_ulong,
                                   out: *mut ::std::os::raw::c_uchar,
                                   outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hkdf_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hkdf_extract(hash_idx: ::std::os::raw::c_int,
                        salt: *const ::std::os::raw::c_uchar,
                        saltlen: ::std::os::raw::c_ulong,
                        in_: *const ::std::os::raw::c_uchar,
                        inlen: ::std::os::raw::c_ulong,
                        out: *mut ::std::os::raw::c_uchar,
                        outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hkdf_expand(hash_idx: ::std::os::raw::c_int,
                       info: *const ::std::os::raw::c_uchar,
                       infolen: ::std::os::raw::c_ulong,
                       in_: *const ::std::os::raw::c_uchar,
                       inlen: ::std::os::raw::c_ulong,
                       out: *mut ::std::os::raw::c_uchar,
                       outlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hkdf(hash_idx: ::std::os::raw::c_int,
                salt: *const ::std::os::raw::c_uchar,
                saltlen: ::std::os::raw::c_ulong,
                info: *const ::std::os::raw::c_uchar,
                infolen: ::std::os::raw::c_ulong,
                in_: *const ::std::os::raw::c_uchar,
                inlen: ::std::os::raw::c_ulong,
                out: *mut ::std::os::raw::c_uchar,
                outlen: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mem_neq(a: *const ::std::os::raw::c_void,
                   b: *const ::std::os::raw::c_void, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zeromem(dst: *mut ::std::os::raw::c_void, len: usize);
}
extern "C" {
    pub fn burn_stack(len: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn error_to_string(err: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "crypt_build_settings"]
    pub static mut crypt_build_settings: *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypt_fsa(mp: *mut ::std::os::raw::c_void, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt_get_constant(namein: *const ::std::os::raw::c_char,
                              valueout: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt_list_all_constants(names_list: *mut ::std::os::raw::c_char,
                                    names_list_size:
                                        *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt_get_size(namein: *const ::std::os::raw::c_char,
                          sizeout: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt_list_all_sizes(names_list: *mut ::std::os::raw::c_char,
                                names_list_size: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn init_TFM();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct adler32_state_s {
    pub s: [::std::os::raw::c_ushort; 2usize],
}
#[test]
fn bindgen_test_layout_adler32_state_s() {
    assert_eq!(::std::mem::size_of::<adler32_state_s>() , 4usize , concat ! (
               "Size of: " , stringify ! ( adler32_state_s ) ));
    assert_eq! (::std::mem::align_of::<adler32_state_s>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( adler32_state_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adler32_state_s ) ) . s as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( adler32_state_s ) ,
                "::" , stringify ! ( s ) ));
}
impl Clone for adler32_state_s {
    fn clone(&self) -> Self { *self }
}
pub type adler32_state = adler32_state_s;
extern "C" {
    pub fn adler32_init(ctx: *mut adler32_state);
}
extern "C" {
    pub fn adler32_update(ctx: *mut adler32_state,
                          input: *const ::std::os::raw::c_uchar,
                          length: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn adler32_finish(ctx: *mut adler32_state,
                          hash: *mut ::std::os::raw::c_void,
                          size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn adler32_test() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct crc32_state_s {
    pub crc: ulong32,
}
#[test]
fn bindgen_test_layout_crc32_state_s() {
    assert_eq!(::std::mem::size_of::<crc32_state_s>() , 4usize , concat ! (
               "Size of: " , stringify ! ( crc32_state_s ) ));
    assert_eq! (::std::mem::align_of::<crc32_state_s>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( crc32_state_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const crc32_state_s ) ) . crc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( crc32_state_s ) , "::"
                , stringify ! ( crc ) ));
}
impl Clone for crc32_state_s {
    fn clone(&self) -> Self { *self }
}
pub type crc32_state = crc32_state_s;
extern "C" {
    pub fn crc32_init(ctx: *mut crc32_state);
}
extern "C" {
    pub fn crc32_update(ctx: *mut crc32_state,
                        input: *const ::std::os::raw::c_uchar,
                        length: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn crc32_finish(ctx: *mut crc32_state,
                        hash: *mut ::std::os::raw::c_void,
                        size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn crc32_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn compare_testvector(is: *const ::std::os::raw::c_void,
                              is_len: ::std::os::raw::c_ulong,
                              should: *const ::std::os::raw::c_void,
                              should_len: ::std::os::raw::c_ulong,
                              what: *const ::std::os::raw::c_char,
                              which: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(::std::mem::size_of::<sigval>() , 8usize , concat ! (
               "Size of: " , stringify ! ( sigval ) ));
    assert_eq! (::std::mem::align_of::<sigval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_int as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_ptr ) ));
}
impl Clone for sigval {
    fn clone(&self) -> Self { *self }
}
pub type sigval_t = sigval;
#[repr(C)]
#[derive(Copy)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub __pad0: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
    _bindgen_union_align: [u64; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_1 ) )
                . si_pid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_1 ) )
                . si_uid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                si_uid ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_2 ) )
                . si_tid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                si_tid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_2 ) )
                . si_overrun as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                si_overrun ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_2 ) )
                . si_sigval as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                si_sigval ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_3 ) )
                . si_pid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_3 ) )
                . si_uid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_3 ) )
                . si_sigval as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                si_sigval ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_pid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_uid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_status as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_utime as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_utime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_stime as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_stime ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1
                ) ) . _lower as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( _lower ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1
                ) ) . _upper as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( _upper ) ));
}
impl Clone for
 siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ) .
                _addr_bnd as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) , "::" ,
                stringify ! ( _addr_bnd ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ) .
                _pkey as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) , "::" ,
                stringify ! ( _pkey ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5 ) )
                . si_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                si_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5 ) )
                . si_addr_lsb as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                si_addr_lsb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5 ) )
                . _bounds as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                _bounds ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_6 ) )
                . si_band as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! (
                si_band ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_6 ) )
                . si_fd as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! (
                si_fd ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_7 ) )
                . _call_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                _call_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_7 ) )
                . _syscall as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                _syscall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_7 ) )
                . _arch as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                _arch ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1>() , 112usize ,
               concat ! (
               "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _pad as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _kill as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _kill ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _timer as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _rt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _rt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigchld as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _sigchld ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigfault
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _sigfault ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigpoll as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _sigpoll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigsys as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _sigsys ) ));
}
impl Clone for siginfo_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(::std::mem::size_of::<siginfo_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( siginfo_t ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( siginfo_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . si_signo as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( si_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . si_errno as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( si_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . si_code as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( si_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . __pad0 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( __pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . _sifields as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( _sifields ) ));
}
impl Clone for siginfo_t {
    fn clone(&self) -> Self { *self }
}
pub const SI_ASYNCNL: _bindgen_ty_4 = _bindgen_ty_4::SI_ASYNCNL;
pub const SI_TKILL: _bindgen_ty_4 = _bindgen_ty_4::SI_TKILL;
pub const SI_SIGIO: _bindgen_ty_4 = _bindgen_ty_4::SI_SIGIO;
pub const SI_ASYNCIO: _bindgen_ty_4 = _bindgen_ty_4::SI_ASYNCIO;
pub const SI_MESGQ: _bindgen_ty_4 = _bindgen_ty_4::SI_MESGQ;
pub const SI_TIMER: _bindgen_ty_4 = _bindgen_ty_4::SI_TIMER;
pub const SI_QUEUE: _bindgen_ty_4 = _bindgen_ty_4::SI_QUEUE;
pub const SI_USER: _bindgen_ty_4 = _bindgen_ty_4::SI_USER;
pub const SI_KERNEL: _bindgen_ty_4 = _bindgen_ty_4::SI_KERNEL;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 {
    SI_ASYNCNL = -60,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128,
}
pub const ILL_ILLOPC: _bindgen_ty_5 = _bindgen_ty_5::ILL_ILLOPC;
pub const ILL_ILLOPN: _bindgen_ty_5 = _bindgen_ty_5::ILL_ILLOPN;
pub const ILL_ILLADR: _bindgen_ty_5 = _bindgen_ty_5::ILL_ILLADR;
pub const ILL_ILLTRP: _bindgen_ty_5 = _bindgen_ty_5::ILL_ILLTRP;
pub const ILL_PRVOPC: _bindgen_ty_5 = _bindgen_ty_5::ILL_PRVOPC;
pub const ILL_PRVREG: _bindgen_ty_5 = _bindgen_ty_5::ILL_PRVREG;
pub const ILL_COPROC: _bindgen_ty_5 = _bindgen_ty_5::ILL_COPROC;
pub const ILL_BADSTK: _bindgen_ty_5 = _bindgen_ty_5::ILL_BADSTK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8,
}
pub const FPE_INTDIV: _bindgen_ty_6 = _bindgen_ty_6::FPE_INTDIV;
pub const FPE_INTOVF: _bindgen_ty_6 = _bindgen_ty_6::FPE_INTOVF;
pub const FPE_FLTDIV: _bindgen_ty_6 = _bindgen_ty_6::FPE_FLTDIV;
pub const FPE_FLTOVF: _bindgen_ty_6 = _bindgen_ty_6::FPE_FLTOVF;
pub const FPE_FLTUND: _bindgen_ty_6 = _bindgen_ty_6::FPE_FLTUND;
pub const FPE_FLTRES: _bindgen_ty_6 = _bindgen_ty_6::FPE_FLTRES;
pub const FPE_FLTINV: _bindgen_ty_6 = _bindgen_ty_6::FPE_FLTINV;
pub const FPE_FLTSUB: _bindgen_ty_6 = _bindgen_ty_6::FPE_FLTSUB;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8,
}
pub const SEGV_MAPERR: _bindgen_ty_7 = _bindgen_ty_7::SEGV_MAPERR;
pub const SEGV_ACCERR: _bindgen_ty_7 = _bindgen_ty_7::SEGV_ACCERR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 { SEGV_MAPERR = 1, SEGV_ACCERR = 2, }
pub const BUS_ADRALN: _bindgen_ty_8 = _bindgen_ty_8::BUS_ADRALN;
pub const BUS_ADRERR: _bindgen_ty_8 = _bindgen_ty_8::BUS_ADRERR;
pub const BUS_OBJERR: _bindgen_ty_8 = _bindgen_ty_8::BUS_OBJERR;
pub const BUS_MCEERR_AR: _bindgen_ty_8 = _bindgen_ty_8::BUS_MCEERR_AR;
pub const BUS_MCEERR_AO: _bindgen_ty_8 = _bindgen_ty_8::BUS_MCEERR_AO;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3,
    BUS_MCEERR_AR = 4,
    BUS_MCEERR_AO = 5,
}
pub const CLD_EXITED: _bindgen_ty_9 = _bindgen_ty_9::CLD_EXITED;
pub const CLD_KILLED: _bindgen_ty_9 = _bindgen_ty_9::CLD_KILLED;
pub const CLD_DUMPED: _bindgen_ty_9 = _bindgen_ty_9::CLD_DUMPED;
pub const CLD_TRAPPED: _bindgen_ty_9 = _bindgen_ty_9::CLD_TRAPPED;
pub const CLD_STOPPED: _bindgen_ty_9 = _bindgen_ty_9::CLD_STOPPED;
pub const CLD_CONTINUED: _bindgen_ty_9 = _bindgen_ty_9::CLD_CONTINUED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6,
}
pub const POLL_IN: _bindgen_ty_10 = _bindgen_ty_10::POLL_IN;
pub const POLL_OUT: _bindgen_ty_10 = _bindgen_ty_10::POLL_OUT;
pub const POLL_MSG: _bindgen_ty_10 = _bindgen_ty_10::POLL_MSG;
pub const POLL_ERR: _bindgen_ty_10 = _bindgen_ty_10::POLL_ERR;
pub const POLL_PRI: _bindgen_ty_10 = _bindgen_ty_10::POLL_PRI;
pub const POLL_HUP: _bindgen_ty_10 = _bindgen_ty_10::POLL_HUP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_10 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6,
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_11 = _bindgen_ty_11::SIGEV_SIGNAL;
pub const SIGEV_NONE: _bindgen_ty_11 = _bindgen_ty_11::SIGEV_NONE;
pub const SIGEV_THREAD: _bindgen_ty_11 = _bindgen_ty_11::SIGEV_THREAD;
pub const SIGEV_THREAD_ID: _bindgen_ty_11 = _bindgen_ty_11::SIGEV_THREAD_ID;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_11 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4,
}
pub type __sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int,
                         __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int,
                   __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t,
                    __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(__set: *const sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     ::std::os::raw::c_int,
                                                                 arg2:
                                                                     *mut siginfo_t,
                                                                 arg3:
                                                                     *mut ::std::os::raw::c_void)>,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigaction__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( sigaction__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<sigaction__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigaction__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction__bindgen_ty_1 ) ) . sa_handler
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction__bindgen_ty_1
                ) , "::" , stringify ! ( sa_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction__bindgen_ty_1 ) ) .
                sa_sigaction as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction__bindgen_ty_1
                ) , "::" , stringify ! ( sa_sigaction ) ));
}
impl Clone for sigaction__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(::std::mem::size_of::<sigaction>() , 152usize , concat ! (
               "Size of: " , stringify ! ( sigaction ) ));
    assert_eq! (::std::mem::align_of::<sigaction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigaction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . __sigaction_handler as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( __sigaction_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_flags as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_restorer as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_restorer ) ));
}
impl Clone for sigaction {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn sigprocmask(__how: ::std::os::raw::c_int, __set: *const sigset_t,
                       __oset: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(__sig: ::std::os::raw::c_int, __act: *const sigaction,
                     __oact: *mut sigaction) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(__set: *const sigset_t, __sig: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait(__set: *const sigset_t, __info: *mut siginfo_t,
                        __timeout: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigqueue(__pid: __pid_t, __sig: ::std::os::raw::c_int,
                    __val: sigval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_sys_siglist"]
    pub static mut _sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
extern "C" {
    #[link_name = "sys_siglist"]
    pub static mut sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub __glibc_reserved1: [__uint32_t; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(::std::mem::size_of::<_fpx_sw_bytes>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _fpx_sw_bytes ) ));
    assert_eq! (::std::mem::align_of::<_fpx_sw_bytes>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _fpx_sw_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . magic1 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( magic1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . extended_size as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( extended_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . xstate_bv as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( xstate_bv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . xstate_size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( xstate_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . __glibc_reserved1 as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( __glibc_reserved1 ) ));
}
impl Clone for _fpx_sw_bytes {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(::std::mem::size_of::<_fpreg>() , 10usize , concat ! (
               "Size of: " , stringify ! ( _fpreg ) ));
    assert_eq! (::std::mem::align_of::<_fpreg>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( _fpreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpreg ) ) . significand as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpreg ) , "::" ,
                stringify ! ( significand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpreg ) ) . exponent as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpreg ) , "::" ,
                stringify ! ( exponent ) ));
}
impl Clone for _fpreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(::std::mem::size_of::<_fpxreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _fpxreg ) ));
    assert_eq! (::std::mem::align_of::<_fpxreg>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( _fpxreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpxreg ) ) . significand as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpxreg ) , "::" ,
                stringify ! ( significand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpxreg ) ) . exponent as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpxreg ) , "::" ,
                stringify ! ( exponent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpxreg ) ) . __glibc_reserved1 as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpxreg ) , "::" ,
                stringify ! ( __glibc_reserved1 ) ));
}
impl Clone for _fpxreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(::std::mem::size_of::<_xmmreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _xmmreg ) ));
    assert_eq! (::std::mem::align_of::<_xmmreg>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _xmmreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xmmreg ) ) . element as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _xmmreg ) , "::" ,
                stringify ! ( element ) ));
}
impl Clone for _xmmreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__fpstate() {
    assert_eq!(::std::mem::size_of::<_fpstate>() , 512usize , concat ! (
               "Size of: " , stringify ! ( _fpstate ) ));
    assert_eq! (::std::mem::align_of::<_fpstate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . cwd as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( cwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . swd as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( swd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . ftw as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( ftw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . fop as * const _ as usize
                } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( fop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . rip as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . rdp as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( rdp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . mxcsr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . mxcr_mask as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( mxcr_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . _st as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( _st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . _xmm as * const _ as usize
                } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( _xmm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . __glibc_reserved1 as *
                const _ as usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( __glibc_reserved1 ) ));
}
impl Clone for _fpstate {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigcontext__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigcontext__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( sigcontext__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<sigcontext__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigcontext__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext__bindgen_ty_1 ) ) . fpstate as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigcontext__bindgen_ty_1 ) , "::" , stringify ! ( fpstate )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext__bindgen_ty_1 ) ) .
                __fpstate_word as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigcontext__bindgen_ty_1 ) , "::" , stringify ! (
                __fpstate_word ) ));
}
impl Clone for sigcontext__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(::std::mem::size_of::<sigcontext>() , 256usize , concat ! (
               "Size of: " , stringify ! ( sigcontext ) ));
    assert_eq! (::std::mem::align_of::<sigcontext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r8 as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r9 as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r10 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r11 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r12 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r13 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r14 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r15 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rdi as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rdi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rsi as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rbp as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rbp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rbx as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rbx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rdx as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rax as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rcx as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rcx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rsp as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rip as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . eflags as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( eflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . cs as * const _ as usize
                } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . gs as * const _ as usize
                } , 146usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( gs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . fs as * const _ as usize
                } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . __pad0 as * const _ as
                usize } , 150usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( __pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . err as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . trapno as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . oldmask as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( oldmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . cr2 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( cr2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . __reserved1 as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( __reserved1 ) ));
}
impl Clone for sigcontext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub __glibc_reserved1: [__uint64_t; 2usize],
    pub __glibc_reserved2: [__uint64_t; 5usize],
}
#[test]
fn bindgen_test_layout__xsave_hdr() {
    assert_eq!(::std::mem::size_of::<_xsave_hdr>() , 64usize , concat ! (
               "Size of: " , stringify ! ( _xsave_hdr ) ));
    assert_eq! (::std::mem::align_of::<_xsave_hdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _xsave_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xsave_hdr ) ) . xstate_bv as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _xsave_hdr ) , "::" ,
                stringify ! ( xstate_bv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xsave_hdr ) ) . __glibc_reserved1 as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _xsave_hdr ) , "::" ,
                stringify ! ( __glibc_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xsave_hdr ) ) . __glibc_reserved2 as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _xsave_hdr ) , "::" ,
                stringify ! ( __glibc_reserved2 ) ));
}
impl Clone for _xsave_hdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(::std::mem::size_of::<_ymmh_state>() , 256usize , concat ! (
               "Size of: " , stringify ! ( _ymmh_state ) ));
    assert_eq! (::std::mem::align_of::<_ymmh_state>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _ymmh_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ymmh_state ) ) . ymmh_space as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _ymmh_state ) , "::" ,
                stringify ! ( ymmh_space ) ));
}
impl Clone for _ymmh_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(::std::mem::size_of::<_xstate>() , 832usize , concat ! (
               "Size of: " , stringify ! ( _xstate ) ));
    assert_eq! (::std::mem::align_of::<_xstate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _xstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xstate ) ) . fpstate as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _xstate ) , "::" ,
                stringify ! ( fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xstate ) ) . xstate_hdr as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( _xstate ) , "::" ,
                stringify ! ( xstate_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xstate ) ) . ymmh as * const _ as usize
                } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( _xstate ) , "::" ,
                stringify ! ( ymmh ) ));
}
impl Clone for _xstate {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct stack_t {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: usize,
}
#[test]
fn bindgen_test_layout_stack_t() {
    assert_eq!(::std::mem::size_of::<stack_t>() , 24usize , concat ! (
               "Size of: " , stringify ! ( stack_t ) ));
    assert_eq! (::std::mem::align_of::<stack_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( stack_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stack_t ) ) . ss_sp as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( stack_t ) , "::" ,
                stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stack_t ) ) . ss_flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( stack_t ) , "::" ,
                stringify ! ( ss_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stack_t ) ) . ss_size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( stack_t ) , "::" ,
                stringify ! ( ss_size ) ));
}
impl Clone for stack_t {
    fn clone(&self) -> Self { *self }
}
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__libc_fpxreg() {
    assert_eq!(::std::mem::size_of::<_libc_fpxreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _libc_fpxreg ) ));
    assert_eq! (::std::mem::align_of::<_libc_fpxreg>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( _libc_fpxreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpxreg ) ) . significand as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpxreg ) , "::" ,
                stringify ! ( significand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpxreg ) ) . exponent as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpxreg ) , "::" ,
                stringify ! ( exponent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpxreg ) ) . __glibc_reserved1 as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpxreg ) , "::" ,
                stringify ! ( __glibc_reserved1 ) ));
}
impl Clone for _libc_fpxreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__libc_xmmreg() {
    assert_eq!(::std::mem::size_of::<_libc_xmmreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _libc_xmmreg ) ));
    assert_eq! (::std::mem::align_of::<_libc_xmmreg>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _libc_xmmreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_xmmreg ) ) . element as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_xmmreg ) , "::" ,
                stringify ! ( element ) ));
}
impl Clone for _libc_xmmreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__libc_fpstate() {
    assert_eq!(::std::mem::size_of::<_libc_fpstate>() , 512usize , concat ! (
               "Size of: " , stringify ! ( _libc_fpstate ) ));
    assert_eq! (::std::mem::align_of::<_libc_fpstate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _libc_fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . cwd as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( cwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . swd as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( swd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . ftw as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( ftw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . fop as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( fop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . rip as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . rdp as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( rdp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . mxcsr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . mxcr_mask as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( mxcr_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . _st as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( _st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . _xmm as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( _xmm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . __glibc_reserved1 as
                * const _ as usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( __glibc_reserved1 ) ));
}
impl Clone for _libc_fpstate {
    fn clone(&self) -> Self { *self }
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    assert_eq!(::std::mem::size_of::<mcontext_t>() , 256usize , concat ! (
               "Size of: " , stringify ! ( mcontext_t ) ));
    assert_eq! (::std::mem::align_of::<mcontext_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mcontext_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcontext_t ) ) . gregs as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mcontext_t ) , "::" ,
                stringify ! ( gregs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcontext_t ) ) . fpregs as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( mcontext_t ) , "::" ,
                stringify ! ( fpregs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcontext_t ) ) . __reserved1 as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( mcontext_t ) , "::" ,
                stringify ! ( __reserved1 ) ));
}
impl Clone for mcontext_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ucontext_t {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
}
#[test]
fn bindgen_test_layout_ucontext_t() {
    assert_eq!(::std::mem::size_of::<ucontext_t>() , 936usize , concat ! (
               "Size of: " , stringify ! ( ucontext_t ) ));
    assert_eq! (::std::mem::align_of::<ucontext_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ucontext_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext_t ) ) . uc_flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext_t ) , "::" ,
                stringify ! ( uc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext_t ) ) . uc_link as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext_t ) , "::" ,
                stringify ! ( uc_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext_t ) ) . uc_stack as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext_t ) , "::" ,
                stringify ! ( uc_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext_t ) ) . uc_mcontext as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext_t ) , "::" ,
                stringify ! ( uc_mcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext_t ) ) . uc_sigmask as * const _
                as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext_t ) , "::" ,
                stringify ! ( uc_sigmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext_t ) ) . __fpregs_mem as * const
                _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext_t ) , "::" ,
                stringify ! ( __fpregs_mem ) ));
}
impl Clone for ucontext_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn siginterrupt(__sig: ::std::os::raw::c_int,
                        __interrupt: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub const SS_ONSTACK: _bindgen_ty_12 = _bindgen_ty_12::SS_ONSTACK;
pub const SS_DISABLE: _bindgen_ty_12 = _bindgen_ty_12::SS_DISABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_12 { SS_ONSTACK = 1, SS_DISABLE = 2, }
extern "C" {
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(::std::mem::size_of::<sigstack>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigstack ) ));
    assert_eq! (::std::mem::align_of::<sigstack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_sp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_onstack as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_onstack ) ));
}
impl Clone for sigstack {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(__how: ::std::os::raw::c_int,
                           __newmask: *const __sigset_t,
                           __oldmask: *mut __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(__threadid: pthread_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt_argchk(v: *const ::std::os::raw::c_char,
                        s: *const ::std::os::raw::c_char,
                        d: ::std::os::raw::c_int);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ltc_pkcs_1_v1_5_blocks { LTC_PKCS_1_EMSA = 1, LTC_PKCS_1_EME = 2, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ltc_pkcs_1_paddings {
    LTC_PKCS_1_V1_5 = 1,
    LTC_PKCS_1_OAEP = 2,
    LTC_PKCS_1_PSS = 3,
    LTC_PKCS_1_V1_5_NA1 = 4,
}
extern "C" {
    pub fn pkcs_1_mgf1(hash_idx: ::std::os::raw::c_int,
                       seed: *const ::std::os::raw::c_uchar,
                       seedlen: ::std::os::raw::c_ulong,
                       mask: *mut ::std::os::raw::c_uchar,
                       masklen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pkcs_1_i2osp(n: *mut ::std::os::raw::c_void,
                        modulus_len: ::std::os::raw::c_ulong,
                        out: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pkcs_1_os2ip(n: *mut ::std::os::raw::c_void,
                        in_: *mut ::std::os::raw::c_uchar,
                        inlen: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pkcs_1_v1_5_encode(msg: *const ::std::os::raw::c_uchar,
                              msglen: ::std::os::raw::c_ulong,
                              block_type: ::std::os::raw::c_int,
                              modulus_bitlen: ::std::os::raw::c_ulong,
                              prng: *mut prng_state,
                              prng_idx: ::std::os::raw::c_int,
                              out: *mut ::std::os::raw::c_uchar,
                              outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pkcs_1_v1_5_decode(msg: *const ::std::os::raw::c_uchar,
                              msglen: ::std::os::raw::c_ulong,
                              block_type: ::std::os::raw::c_int,
                              modulus_bitlen: ::std::os::raw::c_ulong,
                              out: *mut ::std::os::raw::c_uchar,
                              outlen: *mut ::std::os::raw::c_ulong,
                              is_valid: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pkcs_1_oaep_encode(msg: *const ::std::os::raw::c_uchar,
                              msglen: ::std::os::raw::c_ulong,
                              lparam: *const ::std::os::raw::c_uchar,
                              lparamlen: ::std::os::raw::c_ulong,
                              modulus_bitlen: ::std::os::raw::c_ulong,
                              prng: *mut prng_state,
                              prng_idx: ::std::os::raw::c_int,
                              hash_idx: ::std::os::raw::c_int,
                              out: *mut ::std::os::raw::c_uchar,
                              outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pkcs_1_oaep_decode(msg: *const ::std::os::raw::c_uchar,
                              msglen: ::std::os::raw::c_ulong,
                              lparam: *const ::std::os::raw::c_uchar,
                              lparamlen: ::std::os::raw::c_ulong,
                              modulus_bitlen: ::std::os::raw::c_ulong,
                              hash_idx: ::std::os::raw::c_int,
                              out: *mut ::std::os::raw::c_uchar,
                              outlen: *mut ::std::os::raw::c_ulong,
                              res: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pkcs_1_pss_encode(msghash: *const ::std::os::raw::c_uchar,
                             msghashlen: ::std::os::raw::c_ulong,
                             saltlen: ::std::os::raw::c_ulong,
                             prng: *mut prng_state,
                             prng_idx: ::std::os::raw::c_int,
                             hash_idx: ::std::os::raw::c_int,
                             modulus_bitlen: ::std::os::raw::c_ulong,
                             out: *mut ::std::os::raw::c_uchar,
                             outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pkcs_1_pss_decode(msghash: *const ::std::os::raw::c_uchar,
                             msghashlen: ::std::os::raw::c_ulong,
                             sig: *const ::std::os::raw::c_uchar,
                             siglen: ::std::os::raw::c_ulong,
                             saltlen: ::std::os::raw::c_ulong,
                             hash_idx: ::std::os::raw::c_int,
                             modulus_bitlen: ::std::os::raw::c_ulong,
                             res: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pkcs_5_alg1(password: *const ::std::os::raw::c_uchar,
                       password_len: ::std::os::raw::c_ulong,
                       salt: *const ::std::os::raw::c_uchar,
                       iteration_count: ::std::os::raw::c_int,
                       hash_idx: ::std::os::raw::c_int,
                       out: *mut ::std::os::raw::c_uchar,
                       outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pkcs_5_alg1_openssl(password: *const ::std::os::raw::c_uchar,
                               password_len: ::std::os::raw::c_ulong,
                               salt: *const ::std::os::raw::c_uchar,
                               iteration_count: ::std::os::raw::c_int,
                               hash_idx: ::std::os::raw::c_int,
                               out: *mut ::std::os::raw::c_uchar,
                               outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pkcs_5_alg2(password: *const ::std::os::raw::c_uchar,
                       password_len: ::std::os::raw::c_ulong,
                       salt: *const ::std::os::raw::c_uchar,
                       salt_len: ::std::os::raw::c_ulong,
                       iteration_count: ::std::os::raw::c_int,
                       hash_idx: ::std::os::raw::c_int,
                       out: *mut ::std::os::raw::c_uchar,
                       outlen: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pkcs_5_test() -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_data {
    pub _address: u8,
}
impl Clone for __locale_data {
    fn clone(&self) -> Self { *self }
}
